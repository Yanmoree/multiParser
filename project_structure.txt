СТРУКТУРА ПРОЕКТА
=================
Директория: /Users/yanmore/IdeaProjects/multiParser
Дата создания отчета: 2026-01-20T12:20:02.465074

================================================================================

[DIR] multiParser

  [FILE] cookies_debug_20260119_111051.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_debug_20260119_111051.properties
    Размер: 707 байт
    Дата изменения: 2026-01-19T08:10:51.547108795Z
    Содержимое:
    ----------------------------------------
    #Debug cookies from Selenium
    #Mon Jan 19 11:10:51 MSK 2026
    _m_h5_tk=b12d2a731e6520d120e8161ce5fe04b9_1768819591926
    _m_h5_tk_enc=249a48b09dd379e555bcfb051f1bcd97
    _samesite_flag_=true
    _tb_token_=f9e88355b71e3
    cna=/NT0IfVnoCECAZH5bfmSUNgE
    cookie2=1e0d1a49c3fe5c7836bd5bc4c9285c87
    mtop_partitioned_detect=1
    t=d09c844f0516a76e622a53cf60c5c174
    tfstk=gz1nfMbBrhiblCnai0RQLxvSAiwTdBOWAghJ2QKzQh-62ytpvaSlrZJPvBdKE7bPYL5p9wIGZMIOJksJ90VljhI-wwClCbbfP6UBwyOCRQOzDoFAZw_BNDIjhkqO7z8WZe-n8GC5RQOzDaBi9lQCvGjOqQRzSC8k80RrTQzi_UtZTUlezczMPhRrTXlEQN8p-XlyLg7aSUtw4QJF4CzMPh-yaQ7wgu-h4iCa2fSpf0bwW1YHKn7UsbllsjpH0w-iamfM-u-V8hcrZnWq5v_P4ucJgtsGZK-G4TDZ3qZINFzRsYMWLFTMDGwoA-6vlsk_SPD0Rp86WIUgSYgHLFTMzP4ihJ9e5eEA.
    xlly_s=1
    ----------------------------------------

  [FILE] cookies_backup.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_backup.json
    Размер: 234 байт
    Дата изменения: 2026-01-15T21:52:33.371178586Z
    Содержимое:
    ----------------------------------------
    {"cookie2":"5a79ddd35987b6f0","t":"1768513953364","cna":"494076cb8fea546e6cf5b1ce","_m_h5_tk_enc":"dd9f12d7ed319f2cd4f8f1ff2f0e9078","isg":"BO559b452585b8aa255d6fc31daab814","_m_h5_tk":"e9da8ac727806d44dbb99febdd72dbd9_1768513953364"}
    ----------------------------------------

  [FILE] cookies.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies.properties
    Размер: 2153 байт
    Дата изменения: 2026-01-20T09:18:21.759869925Z
    Содержимое:
    ----------------------------------------
    #Cookies for HTTP requests
    #Auto-generated file
    #Tue Jan 20 12:18:21 MSK 2026
    h5api.m.goofish.com.cookies=t\=e6abfc7d5afcbbd647a001a7878a35aa; cna\=STb2ISe2XWcCAbJFfm+LP/ja; _m_h5_tk_enc\=f7e04dbefd1223e75c0946f34a7e2eeb; _samesite_flag_\=true; tfstk\=g6iIfgOq4bnwefJpw6JN1Z4YGxESVd-q9Tw-nYIFekEKeuM-E7PUz7u1NfhizvPE4VNS6fNL82kyVflisXkEUYB7efrLr2PzT7ZSEj9wgn-qKvquvIR20utanoZuw3rJ7lh3Q646gn-qKUtEnHAq8kWMQ8282JUR21p_H8E8egh86PeY36E82bp_W8eA9wF8JNKTe5F82uh-Bdwz6JE82bH9C8bwBEw6d7kB3yRd_cJ09vF12gn9RyNjpaSR2cwQRokL1vkEfJaQGziyvgojHvn0F0vAP7wC4HI4G4SVPOac2RN2Cd_lr82LmJZC8EpzJR2iQd91kT4LIRwJCd_ldyegdPJ6C63l.; mtop_partitioned_detect\=1; _tb_token_\=e39338d333b05; _m_h5_tk\=ab5f541416459b2a2f91b2fcb232b906_1768909321004; xlly_s\=1; cookie2\=19414c231439bbf72aa9291da256599c
    m.goofish.com.cookies=t\=e6abfc7d5afcbbd647a001a7878a35aa; cna\=STb2ISe2XWcCAbJFfm+LP/ja; _m_h5_tk_enc\=f7e04dbefd1223e75c0946f34a7e2eeb; _samesite_flag_\=true; tfstk\=g6iIfgOq4bnwefJpw6JN1Z4YGxESVd-q9Tw-nYIFekEKeuM-E7PUz7u1NfhizvPE4VNS6fNL82kyVflisXkEUYB7efrLr2PzT7ZSEj9wgn-qKvquvIR20utanoZuw3rJ7lh3Q646gn-qKUtEnHAq8kWMQ8282JUR21p_H8E8egh86PeY36E82bp_W8eA9wF8JNKTe5F82uh-Bdwz6JE82bH9C8bwBEw6d7kB3yRd_cJ09vF12gn9RyNjpaSR2cwQRokL1vkEfJaQGziyvgojHvn0F0vAP7wC4HI4G4SVPOac2RN2Cd_lr82LmJZC8EpzJR2iQd91kT4LIRwJCd_ldyegdPJ6C63l.; mtop_partitioned_detect\=1; _tb_token_\=e39338d333b05; _m_h5_tk\=ab5f541416459b2a2f91b2fcb232b906_1768909321004; xlly_s\=1; cookie2\=19414c231439bbf72aa9291da256599c
    www.goofish.com.cookies=t\=e6abfc7d5afcbbd647a001a7878a35aa; cna\=STb2ISe2XWcCAbJFfm+LP/ja; _m_h5_tk_enc\=f7e04dbefd1223e75c0946f34a7e2eeb; _samesite_flag_\=true; tfstk\=g6iIfgOq4bnwefJpw6JN1Z4YGxESVd-q9Tw-nYIFekEKeuM-E7PUz7u1NfhizvPE4VNS6fNL82kyVflisXkEUYB7efrLr2PzT7ZSEj9wgn-qKvquvIR20utanoZuw3rJ7lh3Q646gn-qKUtEnHAq8kWMQ8282JUR21p_H8E8egh86PeY36E82bp_W8eA9wF8JNKTe5F82uh-Bdwz6JE82bH9C8bwBEw6d7kB3yRd_cJ09vF12gn9RyNjpaSR2cwQRokL1vkEfJaQGziyvgojHvn0F0vAP7wC4HI4G4SVPOac2RN2Cd_lr82LmJZC8EpzJR2iQd91kT4LIRwJCd_ldyegdPJ6C63l.; mtop_partitioned_detect\=1; _tb_token_\=e39338d333b05; _m_h5_tk\=ab5f541416459b2a2f91b2fcb232b906_1768909321004; xlly_s\=1; cookie2\=19414c231439bbf72aa9291da256599c
    ----------------------------------------

  [FILE] cookies_debug_20260119_110719.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_debug_20260119_110719.properties
    Размер: 707 байт
    Дата изменения: 2026-01-19T08:07:19.924885946Z
    Содержимое:
    ----------------------------------------
    #Debug cookies from Selenium
    #Mon Jan 19 11:07:19 MSK 2026
    _m_h5_tk=a2fb5ecd01473606f2bfd7945c52c0be_1768817939872
    _m_h5_tk_enc=44dce6002c231414b419f226d3965ae8
    _samesite_flag_=true
    _tb_token_=3087353eee3f7
    cna=J9T0IXmu2XgCAZH5bfkjRUxx
    cookie2=1403bde346bb58557e386148aeba44a0
    mtop_partitioned_detect=1
    t=64133aecceeb26e02f50523e13365762
    tfstk=gShIfFtqa0hZA08p2M8NfPxg6mNWuFRqvaa-o4CFyWFKy7g-rurUUuk1VcniU2rEaAZSXcZLLvuyNcoijDuEz4Q7ycPLEvrzYuNSrmTw0IRq-2Vu9n-2ghVGckFu2QPJQ5n37M260IRq-LOEoBxqL2SQWz48wyeRwGL_kzFR9yn8XRUYuMF8w0L_Br4C9wCRpNCT8lE8w7n-WFazXyF8w0395zbwRKa6RuuBu-MZWAA472E1w_h6dJZjJT5RwfaQd7uLf2gI1ywQc8G805Gjk2h0PbYAFuaC4YC4cY5VFNwcwPZ25F6lE657l0PfA60_pP4i7FT1Ha2LSPaJ5F6lRJUgRR865MHl.
    xlly_s=1
    ----------------------------------------

  [FILE] cookies_debug_20260119_110644.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_debug_20260119_110644.properties
    Размер: 914 байт
    Дата изменения: 2026-01-19T08:06:44.215926548Z
    Содержимое:
    ----------------------------------------
    #Debug cookies from Selenium
    #Mon Jan 19 11:06:44 MSK 2026
    _m_h5_tk=7d68b9a8674a1132b8409fa14f718b8d_1768820435299
    _m_h5_tk_enc=483c9281f86a55476fbbad9e30330cd1
    _samesite_flag_=true
    _tb_token_=f7334330313bf
    cna=DdT0IfMdNC4CAZH5bflo0D4h
    cookie2=1e2b09a51b2586a50f3677fbb24e450a
    mtop_partitioned_detect=1
    t=f2a9ba561f3ed1eec3a8f82a1ee30ebb
    tfstk=gZPKdb1c4NLdNjf1DBXGqIVdfg_GIO4UKkzXZ0mHFlETlr-nFWc32LE3zuD5YXV8XzZA84jUZeyamrO3t9lkwXlrNijcisYU8blSPpECDDz_74_iRCylTacrNijGis4U8brKK-DKdP_tr4vWRuMBChiZueGSAYt6CqisVbZSFf9szqvWADi75N3rf0GSNuG1W4msVbG7VP_N5QnWdDR8K9aPkoTSVQO762HdGyi6NVPtJvnbRXRWNEgKpmaIfMdfYqD8vvFG9nuLCrnf4nF0MQZ2mm3kdNQ9ULkI7hJCkUI0QsUIWmbw0LJrLAutmNIeULkIvVncJ_pyUA7N.
    x5secdata=xg009017cece8e3989jaee31abb12c2ae6ec2a9abdbb212344cb1768809997a-717315356a1781995901abaad3eaa33b4c7594061890541dfbd6da8ac0c001efxianyuSpace_default__bx__h5api.m.goofish.com\:443/h5/mtop.taobao.idlemtopsearch.pc.search/1.0
    ----------------------------------------

  [FILE] pom.xml
    Путь: /Users/yanmore/IdeaProjects/multiParser/pom.xml
    Размер: 5093 байт
    Дата изменения: 2026-01-19T23:35:23.299531773Z
    Содержимое:
    ----------------------------------------
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
             http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
    
        <groupId>com.parser</groupId>
        <artifactId>product-parser</artifactId>
        <version>1.0.0</version>
        <packaging>jar</packaging>
    
        <properties>
            <maven.compiler.source>17</maven.compiler.source>
            <maven.compiler.target>17</maven.compiler.target>
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
            <selenium.version>4.20.0</selenium.version>
        </properties>
    
        <dependencies>
            <!-- HTTP клиент -->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>4.5.14</version>
            </dependency>
    
            <!-- JSON -->
            <dependency>
                <groupId>org.json</groupId>
                <artifactId>json</artifactId>
                <version>20231013</version>
            </dependency>
    
    
            <dependency>
                <groupId>io.github.bonigarcia</groupId>
                <artifactId>webdrivermanager</artifactId>
                <version>5.8.0</version>
            </dependency>
    
            <!-- Telegram -->
            <dependency>
                <groupId>org.telegram</groupId>
                <artifactId>telegrambots</artifactId>
                <version>6.8.0</version>
            </dependency>
    
            <!-- Logging -->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>1.4.11</version>
            </dependency>
    
            <!-- Jackson -->
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.15.3</version>
            </dependency>
    
            <!-- Selenium -->
            <dependency>
                <groupId>org.seleniumhq.selenium</groupId>
                <artifactId>selenium-java</artifactId>
                <version>${selenium.version}</version>
            </dependency>
    
    
            <!-- Apache Commons для удобства -->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>3.14.0</version>
            </dependency>
    
            <dependency>
                <groupId>com.github.luben</groupId>
                <artifactId>zstd-jni</artifactId>
                <version>1.5.5-5</version>
            </dependency>
    
            <!-- SLF4J API -->
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
                <version>2.0.9</version>
            </dependency>
        </dependencies>
    
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.11.0</version>
                    <configuration>
                        <source>17</source>
                        <target>17</target>
                        <encoding>UTF-8</encoding>
                    </configuration>
                </plugin>
    
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-shade-plugin</artifactId>
                    <version>3.5.0</version>
                    <executions>
                        <execution>
                            <phase>package</phase>
                            <goals>
                                <goal>shade</goal>
                            </goals>
                            <configuration>
                                <transformers>
                                    <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                        <mainClass>com.parser.Main</mainClass>
                                    </transformer>
                                </transformers>
                                <filters>
                                    <filter>
                                        <artifact>*:*</artifact>
                                        <excludes>
                                            <exclude>META-INF/*.SF</exclude>
                                            <exclude>META-INF/*.DSA</exclude>
                                            <exclude>META-INF/*.RSA</exclude>
                                            <exclude>META-INF/*.EC</exclude>
                                            <exclude>META-INF/NOTICE*</exclude>
                                            <exclude>META-INF/LICENSE*</exclude>
                                            <exclude>META-INF/versions/*</exclude>
                                            <exclude>META-INF/maven/**</exclude>
                                        </excludes>
                                    </filter>
                                </filters>
                            </configuration>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </build>
    </project>
    ----------------------------------------

  [FILE] real_cookies.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/real_cookies.json
    Размер: 441 байт
    Дата изменения: 2026-01-16T08:19:01.367306132Z
    Содержимое:
    ----------------------------------------
    {
      "last_updated" : "Fri Jan 16 11:19:01 MSK 2026",
      "source" : "real_fetch",
      "cookies" : {
        "t" : "1768551541334",
        "cna" : "fun9mzovhxzth4rldf2656m3",
        "_m_h5_tk_enc" : "7rd0clwyamrrfzasobpgl5fzyiug6xgj",
        "isg" : "BObzsa6rgms0ke9k0mi619ntc5h9nivx",
        "_m_h5_tk" : "p2075mgals5mmin8jc4llglr3daov5ng_1768551541334",
        "_tb_token_" : "ou76zszav01n",
        "cookie2" : "u4vgb35oy9kuwy17"
      },
      "timestamp" : 1768551541334
    }
    ----------------------------------------
  [DIR] logs

    [FILE] parser.2026-01-19.log
      Путь: /Users/yanmore/IdeaProjects/multiParser/logs/parser.2026-01-19.log
      Размер: 105724 байт
      Дата изменения: 2026-01-19T09:35:23.622305088Z
      [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]

    [FILE] parser.2026-01-17.log
      Путь: /Users/yanmore/IdeaProjects/multiParser/logs/parser.2026-01-17.log
      Размер: 1493006 байт
      Дата изменения: 2026-01-19T09:31:29.760266716Z
      [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]

    [FILE] parser.2026-01-16.log
      Путь: /Users/yanmore/IdeaProjects/multiParser/logs/parser.2026-01-16.log
      Размер: 206820 байт
      Дата изменения: 2026-01-19T09:31:29.755772968Z
      [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]

    [FILE] parser.log
      Путь: /Users/yanmore/IdeaProjects/multiParser/logs/parser.log
      Размер: 330979 байт
      Дата изменения: 2026-01-20T09:19:10.020563094Z
      [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]

  [FILE] api_response.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/api_response.json
    Размер: 3028 байт
    Дата изменения: 2026-01-16T20:06:11.352475191Z
    Содержимое:
    ----------------------------------------
    {"api":"mtop.taobao.idlemtopsearch.pc.search","v":"1.0", "ret": ["RGV587_ERROR::SM::哎哟喂,被挤爆啦,请稍后重试!"],"data": { "url": "https://passport.goofish.com/mini_login.htm?lang=zh_cn&appName=xianyu&appEntrance=baxia&redirectType=iframeRedirect&styleType=vertical&bizParams=&notLoadSsoView=true&notKeepLogin=false&isMobile=false&qrCodeFirst=false&rnd=0.7405678221745524&returnUrl=https%3a%2f%2fh5api.m.goofish.com:443/h5/mtop.taobao.idlemtopsearch.pc.search/1.0%2F_____tmd_____%2Fpage%2Fmtoph5_close_iframe_page%3Frand%3DS3WxGHAgAt756EpznwfNzJq2AFA2qBNla3j6EINUS8We9dazM_iKElp8DwVSHZUevpC41Bx7RzivXIj9RnZgdg%26uuid%3D0c554ce36815acdfa722dafce91d8863%26_lgt_%3D0c554ce36815acdfa722dafce91d8863___305220___d57171f5eb6e272202b5487a483d5dfa___eaebc79cac1eb5d2f7d8b4595e00ec73344a42d5a0b8cf56539c823cd24ac06c092f67171550cb6cbbc4aaaa937e5ef4f60277010dffec5689671a57f915809888d25ef3220a7c2464a290cff32056669f3d6a459ad2c296ee8cbb5a8d67c1a029af9254ddea98f951f5ea79ca6d68afacb857c81ed97566c7ec74b7eb613fa519b4c3107e712c0b12b48606e859d16ccbd4fb8cf17cff382cca796b27b42f93bdd660982d155ad900bd3837f5da3e57ca78869e9450dde1ca0616ecc84d1bef86a07297d351a5f1954e205f0907ed8ab9518cbf4cff63eb12033451f3cce3ec58715d624adb927aaa033fb788a8928b84bbc28e79d0d752ddcd10ee29db7b904fd08591e292b488a8748becc81d31ed20f50715c332ef14fe2906c58135278f61177841a36789ac8d0efdb86bbd42388e984c4f3c9f78190b7d525276218f543735df556116b6b4f0c837e6021fa5473cd742cc3b4bcbc79f2b2b1dda4ba31835c41fe5998c210b7575bb4bc702aebacd5c40286fce09dcb3d11fd149fb1e363d4a43213597d5e2249ec2536825bd75918316a8d62033b9ebf7b284e2a36b48", "h5url": "https://passport.goofish.com/mini_login.htm?appName=xianyu&appEntrance=baxia&isMobile=true&redirectType=iframeRedirect&returnUrl=https%3a%2f%2fh5api.m.goofish.com:443/h5/mtop.taobao.idlemtopsearch.pc.search/1.0%2F_____tmd_____%2Fpage%2Fmtoph5_close_iframe_page%3Frand%3DS3WxGHAgAt756EpznwfNzJq2AFA2qBNla3j6EINUS8We9dazM_iKElp8DwVSHZUevpC41Bx7RzivXIj9RnZgdg%26uuid%3D0c554ce36815acdfa722dafce91d8863%26_lgt_%3D0c554ce36815acdfa722dafce91d8863___305220___d57171f5eb6e272202b5487a483d5dfa___eaebc79cac1eb5d2f7d8b4595e00ec73344a42d5a0b8cf56539c823cd24ac06c092f67171550cb6cbbc4aaaa937e5ef4f60277010dffec5689671a57f915809888d25ef3220a7c2464a290cff32056669f3d6a459ad2c296ee8cbb5a8d67c1a029af9254ddea98f951f5ea79ca6d68afacb857c81ed97566c7ec74b7eb613fa519b4c3107e712c0b12b48606e859d16ccbd4fb8cf17cff382cca796b27b42f93bdd660982d155ad900bd3837f5da3e57ca78869e9450dde1ca0616ecc84d1bef86a07297d351a5f1954e205f0907ed8ab9518cbf4cff63eb12033451f3cce3ec58715d624adb927aaa033fb788a8928b84bbc28e79d0d752ddcd10ee29db7b904fd08591e292b488a8748becc81d31ed20f50715c332ef14fe2906c58135278f61177841a36789ac8d0efdb86bbd42388e984c4f3c9f78190b7d525276218f543735df556116b6b4f0c837e6021fa5473cd742cc3b4bcbc79f2b2b1dda4ba31835c41fe5998c210b7575bb4bc702aebacd5c40286fce09dcb3d11fd149fb1e363d4a43213597d5e2249ec2536825bd75918316a8d62033b9ebf7b284e2a36b48", "dialogSize": {"width": "856px", "height": "454px"}}, "dialogSize": {"width": "856px", "height": "454px"}}
    ----------------------------------------

  [FILE] dependency-reduced-pom.xml
    Путь: /Users/yanmore/IdeaProjects/multiParser/dependency-reduced-pom.xml
    Размер: 2216 байт
    Дата изменения: 2026-01-20T09:17:48.303399871Z
    Содержимое:
    ----------------------------------------
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
      <modelVersion>4.0.0</modelVersion>
      <groupId>com.parser</groupId>
      <artifactId>product-parser</artifactId>
      <version>1.0.0</version>
      <build>
        <plugins>
          <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <configuration>
              <source>17</source>
              <target>17</target>
              <encoding>UTF-8</encoding>
            </configuration>
          </plugin>
          <plugin>
            <artifactId>maven-shade-plugin</artifactId>
            <version>3.5.0</version>
            <executions>
              <execution>
                <phase>package</phase>
                <goals>
                  <goal>shade</goal>
                </goals>
                <configuration>
                  <transformers>
                    <transformer>
                      <mainClass>com.parser.Main</mainClass>
                    </transformer>
                  </transformers>
                  <filters>
                    <filter>
                      <artifact>*:*</artifact>
                      <excludes>
                        <exclude>META-INF/*.SF</exclude>
                        <exclude>META-INF/*.DSA</exclude>
                        <exclude>META-INF/*.RSA</exclude>
                        <exclude>META-INF/*.EC</exclude>
                        <exclude>META-INF/NOTICE*</exclude>
                        <exclude>META-INF/LICENSE*</exclude>
                        <exclude>META-INF/versions/*</exclude>
                        <exclude>META-INF/maven/**</exclude>
                      </excludes>
                    </filter>
                  </filters>
                </configuration>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
      <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.target>17</maven.compiler.target>
        <selenium.version>4.20.0</selenium.version>
        <maven.compiler.source>17</maven.compiler.source>
      </properties>
    </project>
    ----------------------------------------

  [FILE] .gitignore
    Путь: /Users/yanmore/IdeaProjects/multiParser/.gitignore
    Размер: 0 байт
    Дата изменения: 2026-01-17T12:50:01.802474294Z
    [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]
  [DIR] .mvn

  [FILE] cookies.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies.json
    Размер: 419 байт
    Дата изменения: 2026-01-16T07:59:20.60810124Z
    Содержимое:
    ----------------------------------------
    {
      "last_updated" : "Fri Jan 16 10:59:20 MSK 2026",
      "cookies" : {
        "t" : "1768550339826",
        "cna" : "yf3PXI6YB2MCAXE5zQoJABCD",
        "_m_h5_tk_enc" : "f83c9d0d8b3a2e1c4f7d8e06a2cbd5e6",
        "isg" : "BOB4X6Y7Z8A9B0C1D2E3F4G5H6I7J8K9L",
        "_m_h5_tk" : "06a2cbd5e6f83c9d0d8b3a2e1c4f7d8e_1768550339826",
        "_tb_token_" : "e3f4g5h6i7j8k9l0m1n2o3p4q5r6s7t",
        "cookie2" : "179e5ac7f7b2c4d8e9f0a1b2c3d4e5f6"
      }
    }
    ----------------------------------------
  [DIR] data

    [FILE] whitelist.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/whitelist.txt
      Размер: 243 байт
      Дата изменения: 2026-01-19T09:35:20.946615773Z
      Содержимое:
      ----------------------------------------
      # Whitelist - список авторизованных пользователей
      # Формат: один ID пользователя на строке
      # Создан: Sat Jan 17 17:36:55 MSK 2026
      
      1080595280
      1652510924
      6937423668
      5328022266
      ----------------------------------------
    [DIR] user_queries

      [FILE] 1080595280.txt
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_queries/1080595280.txt
        Размер: 22 байт
        Дата изменения: 2026-01-19T07:36:06.709025027Z
        Содержимое:
        ----------------------------------------
        stone island
        cav empt
        ----------------------------------------

      [FILE] 5328022266.txt
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_queries/5328022266.txt
        Размер: 23 байт
        Дата изменения: 2026-01-19T07:42:44.706382918Z
        Содержимое:
        ----------------------------------------
        number nine
        raf simons
        ----------------------------------------
    [DIR] user_products

      [FILE] 6937423668.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_products/6937423668.json
        Размер: 3664 байт
        Дата изменения: 2026-01-17T21:21:02.695697176Z
        Содержимое:
        ----------------------------------------
        [{"id":"1014278121369","title":"Stone Island/石头岛美式翻领夹克外套 【面料】外层面料采用了加厚加密的锦纶斜纹面料，兼具耐穿性和耐久防水功能。现代感时尚廓型剪裁，帅气百搭。内部采用柔软里布，螺纹全部面料对色定染定织！两个外口袋设计，内里竖口袋设计，收纳方便、走线的细节全部打套节处理，飞行员军工风上身帅气十足，非常适合日常休闲穿搭！胳膊上的袖章的刺绣工艺流程采用日本进口机器进行作业 字母图案清晰立体，有质感 ！-...","price":159.0,"url":"https://www.goofish.com/item?id=1014278121369","site":"goofish","location":"江苏","ageMinutes":781,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i3/2220983028576/O1CN01Gan7hi2DDrmJykcEF_!!4611686018427382624-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862681,"isNew":true},{"id":"1014956044370","title":"【STONE ISLAND石头岛经典徽章羊羔毛棉服外套】 定制主标 辅料 水洗齐全 原版一致徽章 纽扣开模订做宽松版型 甄选优质麂皮防风面料 内里填充高克重羽绒棉 舒适温暖羊羔毛领 亲肤柔软立体剪裁 防风保暖 随性时髦可搭配任意下装 轻松凹造型 显瘦显高 男女均可完美驾驭！color：黑色/咖色size：M.L.XL.2XL.3XLM胸围120 肩宽51 衣长66   L 胸围124 肩宽5...","price":252.0,"url":"https://www.goofish.com/item?id=1014956044370","site":"goofish","location":"山东","ageMinutes":1115,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i4/2219863640002/O1CN01mTD99V1BsxuVPC5Gj_!!4611686018427381698-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862681,"isNew":true},{"id":"1014277989994","title":"石头岛哈灵顿夹克 非正 高版本 L码能穿到180 150斤能刀","price":250.0,"url":"https://www.goofish.com/item?id=1014277989994","site":"goofish","location":"北京","ageMinutes":780,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i1/2214700202885/O1CN01y3cIr71XBNlgmzqyb_!!4611686018427386757-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862682,"isNew":true},{"id":"1013439486344","title":"STONE ISLAND石头岛 FW23 圆领基础套头Log o卫衣 男款 灰色在意大利佛罗伦萨市中心石头岛专卖店折扣价购买268欧元约2200人民币保证正品已经购买一年，有洗过，低价出售L码175-185都可以穿","price":629.0,"url":"https://www.goofish.com/item?id=1013439486344","site":"goofish","location":"浙江","ageMinutes":677,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i1/2212676127444/O1CN01TMCJCx24rPQpeM3hc_!!4611686018427382484-0-xy_item.jpg"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862682,"isNew":true},{"id":"1012740567979","title":"【捡漏】STONE ISLAND x  New Balanc e New Balance x TDS 联名系列 舒适耐磨 低帮跑步鞋 男款 米白色断码库存、图中就是实拍，价格已是低价、不议价！！尺码：39～45  正码正拍 断码清仓拍前私信客服有无码数！！！售后:非偏远包邮、质量问题支持退换，七天无理由","price":89.0,"url":"https://www.goofish.com/item?id=1012740567979","site":"goofish","location":"山西","ageMinutes":910,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i4/2219176448221/O1CN01hz843X2AbHAus1wva_!!4611686018427384029-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862683,"isNew":true}]
        ----------------------------------------

      [FILE] 1080595280.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_products/1080595280.json
        Размер: 1609 байт
        Дата изменения: 2026-01-20T09:19:06.840027162Z
        Содержимое:
        ----------------------------------------
        [{"id":"1014997073429","title":"No title","price":1869.0,"url":"https://www.goofish.com/item?id=1014997073429","site":"goofish","location":"Unknown","ageMinutes":478,"query":"jeremy scott","images":["http://img.alicdn.com/bao/uploaded/i2/4020309979/O1CN01joH2Me2NaRSXYJF0p_!!4611686018427383771-0-xy_item.jpg"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768900737909,"isNew":true},{"id":"1013428463027","title":"No title","price":399.0,"url":"https://www.goofish.com/item?id=1013428463027","site":"goofish","location":"Unknown","ageMinutes":1019,"query":"jeremy scott","images":["http://img.alicdn.com/bao/uploaded/i2/O1CN013uxtzP1hA8qycspxh_!!4611686018427380124-53-fleamarket.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768900737909,"isNew":true},{"id":"1015705392466","title":"No title","price":693.0,"url":"https://www.goofish.com/item?id=1015705392466","site":"goofish","location":"Unknown","ageMinutes":930,"query":"jeremy scott","images":["http://img.alicdn.com/bao/uploaded/i3/O1CN01hkPt261Gy4P8ZZAFH_!!4611686018427387106-0-fleamarket.jpg"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768900737910,"isNew":true},{"id":"1014073978495","title":"No title","price":1399.0,"url":"https://www.goofish.com/item?id=1014073978495","site":"goofish","location":"Unknown","ageMinutes":987,"query":"jeremy scott","images":["http://img.alicdn.com/bao/uploaded/i3/3804186192/O1CN01CWviZr1vbzYfMaRDw_!!4611686018427381328-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768900737910,"isNew":true}]
        ----------------------------------------
    [DIR] user_settings

      [FILE] 6937423668.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/6937423668.json
        Размер: 334 байт
        Дата изменения: 2026-01-17T21:22:17.000818167Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":20,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":500,"priceCurrency":"rubles","notifyNewOnly":true,"notifyTelegram":true,"notifyEmail":false,"notifySound":true,"minPrice":0.0,"maxPrice":0.0,"locations":[],"excludedKeywords":[],"enableProxy":false,"proxyAddress":"","proxyPort":0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

      [FILE] 5328022266.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/5328022266.json
        Размер: 227 байт
        Дата изменения: 2026-01-19T07:43:10.908043946Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":300,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":100,"priceCurrency":"rubles","notifyNewOnly":true,"notifyTelegram":true,"notifyEmail":false,"minPrice":0.0,"maxPrice":0.0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

      [FILE] 1080595280.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/1080595280.json
        Размер: 335 байт
        Дата изменения: 2026-01-19T09:31:29.753238094Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":20,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":500,"priceCurrency":"rubles","notifyNewOnly":false,"notifyTelegram":true,"notifyEmail":false,"notifySound":true,"minPrice":0.0,"maxPrice":0.0,"locations":[],"excludedKeywords":[],"enableProxy":false,"proxyAddress":"","proxyPort":0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

    [FILE] user_6937423668_queries.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_6937423668_queries.txt
      Размер: 13 байт
      Дата изменения: 2026-01-17T15:22:23.938396657Z
      Содержимое:
      ----------------------------------------
      stone island
      ----------------------------------------
    [DIR] data

      [FILE] whitelist.txt
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/data/whitelist.txt
        Размер: 114 байт
        Дата изменения: 2026-01-20T08:42:33.667681455Z
        Содержимое:
        ----------------------------------------
        # Whitelist - authorized users
        # Format: one user ID per line
        # Created: Tue Jan 20 11:42:33 MSK 2026
        
        1080595280
        ----------------------------------------

    [FILE] user_1080595280_queries.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_1080595280_queries.txt
      Размер: 35 байт
      Дата изменения: 2026-01-20T08:53:19.272749598Z
      Содержимое:
      ----------------------------------------
      Stone Island
      cav empt
      jeremy scott
      ----------------------------------------

  [FILE] cookies_debug_20260119_110601.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_debug_20260119_110601.properties
    Размер: 707 байт
    Дата изменения: 2026-01-19T08:06:01.137442836Z
    Содержимое:
    ----------------------------------------
    #Debug cookies from Selenium
    #Mon Jan 19 11:06:01 MSK 2026
    _m_h5_tk=03ffba78ff01b19a143f62da64ed7518_1768819991518
    _m_h5_tk_enc=fbbdfeddb5169b78b9cd607444edc4b4
    _samesite_flag_=true
    _tb_token_=30534765ade34
    cna=vNP0ITpe7B4CAZH5bfmZYBFQ
    cookie2=14d4fe13fa81de8fa73e38ce3ce3eb9a
    mtop_partitioned_detect=1
    t=9bbd9ee8e9bdd9d9ebbebb787f244820
    tfstk=gvcjfutE_chyRdYvXi8PVzAkW4VsMUREDNat-VCVWSFxW5gtSlr4Qlk5f0noQqrq_YZs20ZY3xuw10ooqmuq7VQ_W0PYIxra0lNsSDTyYBREoqVgMH-eTqnZJ2PgXCP9U7n0zi2WYBREoKU0_4KE3qWfcP4T6reO6aL7JPFODRnT28UL8iFT6cL7eP4QWZCYDuE8RuET65ntyUaa2rFT6c3JPPbCQpaWlluX8JM85X9Hkqr561h7lEZKluaurbabhkHuV13jNrwbvqGpVjd85vhQnDKP3oHQhgrhTkMNTO_7K1U7YUT5IOfV1yiaVC_E1-Uur48WP9QgHz47WUT5IZwYrrwyPUsxI
    xlly_s=1
    ----------------------------------------
  [DIR] src
    [DIR] test
      [DIR] java
    [DIR] main
      [DIR] resources

        [FILE] logback.xml
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/logback.xml
          Размер: 1358 байт
          Дата изменения: 2026-01-16T19:18:24.207912756Z
          Содержимое:
          ----------------------------------------
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
              <property name="LOG_DIR" value="./logs" />
              <property name="LOG_FILE" value="parser" />
          
              <!-- Консольный аппендер -->
              <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
                  <encoder>
                      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <!-- Файловый аппендер -->
              <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
                  <file>${LOG_DIR}/${LOG_FILE}.log</file>
                  <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                      <fileNamePattern>${LOG_DIR}/${LOG_FILE}.%d{yyyy-MM-dd}.log</fileNamePattern>
                      <maxHistory>30</maxHistory>
                      <totalSizeCap>1GB</totalSizeCap>
                  </rollingPolicy>
                  <encoder>
                      <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <!-- Логирование Selenium -->
              <logger name="org.openqa.selenium" level="WARN" />
              <logger name="io.github.bonigarcia" level="WARN" />
          
              <!-- Корневой логгер -->
              <root level="INFO">
                  <appender-ref ref="CONSOLE" />
                  <appender-ref ref="FILE" />
              </root>
          </configuration>
          ----------------------------------------

        [FILE] cookie.properties
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/cookie.properties
          Размер: 233 байт
          Дата изменения: 2026-01-19T09:31:29.778055459Z
          Содержимое:
          ----------------------------------------
          h5api.m.goofish.com.cookies=_m_h5_tk=abc123def456_1705420800000; _m_h5_tk_enc=abc123def456_1705420800000; _tb_token_=xyz789; cna=test123; t=md5hash123; cookie2=md5hash456; _samesite_flag_=true; XSRF-TOKEN=token123; isg=BC_randomtoken
          ----------------------------------------

        [FILE] logback-debug.xml
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/logback-debug.xml
          Размер: 363 байт
          Дата изменения: 2026-01-16T19:22:31.341841447Z
          Содержимое:
          ----------------------------------------
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
              <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
                  <encoder>
                      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <root level="DEBUG">
                  <appender-ref ref="CONSOLE" />
              </root>
          </configuration>
          ----------------------------------------

        [FILE] config.properties
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/config.properties
          Размер: 1367 байт
          Дата изменения: 2026-01-19T22:20:24.813727344Z
          Содержимое:
          ----------------------------------------
          # ======================
          # Telegram Bot Settings
          # ======================
          telegram.bot.token=8538627254:AAE_niIKdyWgM69JSrto7tKntao5vS7qj5g
          telegram.bot.username=multiparse_bot
          telegram.admin.id=1080595280
          
          # Parser Configuration
          parser.default.check_interval=20
          parser.default.max_age_minutes=1440
          parser.default.max_pages=3
          parser.default.rows_per_page=500
          parser.default.notify_new_only=true
          
          # Thread Pool Configuration
          thread.pool.core.size=5
          thread.pool.max.size=20
          thread.pool.queue.capacity=100
          thread.pool.keepalive.seconds=60
          
          # Storage Configuration
          storage.data.dir=./data
          storage.backup.enabled=true
          storage.backup.interval.hours=24
          
          # HTTP Configuration
          http.connect.timeout=30000
          http.read.timeout=45000
          http.user.agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
          http.max.retries=3
          http.retry.delay=1000
          
          # Cookie Configuration
          cookie.file=cookies.properties
          cookie.auto.update=true
          cookie.update.interval.minutes=60
          cookie.backup.enabled=true
          cookie.dynamic.enabled=true
          cookie.cache.ttl.minutes=30
          
          # Logging Configuration
          logging.level=INFO
          logging.file=parser.log
          logging.max.size.mb=10
          logging.max.backups=5
          
          # API Configuration
          api.goofish.base_url=https://h5api.m.goofish.com
          api.goofish.search.endpoint=/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/
          api.goofish.delay.between.requests=2000
          api.goofish.max.products.per.page=500
          ----------------------------------------
      [DIR] java
        [DIR] com
          [DIR] parser
            [DIR] core

              [FILE] UserSession.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/core/UserSession.java
                Размер: 9510 байт
                Дата изменения: 2026-01-19T09:31:29.768832921Z
                Содержимое:
                ----------------------------------------
                package com.parser.core;
                
                import com.parser.config.ParserSettings;
                import com.parser.model.UserSettings;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.util.*;
                
                /**
                 * Класс, представляющий сессию парсера для пользователя
                 */
                public class UserSession {
                    private static final Logger logger = LoggerFactory.getLogger(UserSession.class);
                
                    private final long userId;
                    private final List<String> queries;
                    private final UserSettings settings;
                
                    // Состояние
                    private volatile boolean running;
                    private volatile boolean paused;
                    private String status;
                    private String lastError;
                
                    // Статистика
                    private int totalProductsFound;
                    private int requestsMade;
                    private int errorsCount;
                
                    // Временные метки
                    private Date startTime;
                    private Date endTime;
                    private Date lastIterationTime;
                    private Date lastProductFoundTime;
                
                    // История найденных товаров (последние 100)
                    private final List<Map<String, Object>> recentProducts;
                
                    public UserSession(long userId, List<String> queries, UserSettings settings) {
                        this.userId = userId;
                        this.queries = new ArrayList<>(queries);
                        this.settings = settings;
                        this.running = false;
                        this.paused = false;
                        this.status = ParserSettings.STATUS_STOPPED;
                        this.totalProductsFound = 0;
                        this.requestsMade = 0;
                        this.errorsCount = 0;
                        this.recentProducts = new LinkedList<>();
                    }
                
                    // Геттеры
                    public long getUserId() {
                        return userId;
                    }
                
                    public List<String> getQueries() {
                        return new ArrayList<>(queries);
                    }
                
                    public UserSettings getSettings() {
                        return settings;
                    }
                
                    public boolean isRunning() {
                        return running;
                    }
                
                    public boolean isPaused() {
                        return paused;
                    }
                
                    public String getStatus() {
                        return status;
                    }
                
                    public String getLastError() {
                        return lastError;
                    }
                
                    public int getTotalProductsFound() {
                        return totalProductsFound;
                    }
                
                    public int getRequestsMade() {
                        return requestsMade;
                    }
                
                    public int getErrorsCount() {
                        return errorsCount;
                    }
                
                    public Date getStartTime() {
                        return startTime;
                    }
                
                    public Date getEndTime() {
                        return endTime;
                    }
                
                    public Date getLastIterationTime() {
                        return lastIterationTime;
                    }
                
                    public Date getLastProductFoundTime() {
                        return lastProductFoundTime;
                    }
                
                    public List<Map<String, Object>> getRecentProducts() {
                        return new ArrayList<>(recentProducts);
                    }
                
                    // Сеттеры
                    public void setRunning(boolean running) {
                        this.running = running;
                        this.status = running ? ParserSettings.STATUS_RUNNING : ParserSettings.STATUS_STOPPED;
                        if (running) {
                            this.startTime = new Date();
                        } else {
                            this.endTime = new Date();
                        }
                    }
                
                    public void setPaused(boolean paused) {
                        this.paused = paused;
                        this.status = paused ? ParserSettings.STATUS_PAUSED :
                                (running ? ParserSettings.STATUS_RUNNING : ParserSettings.STATUS_STOPPED);
                    }
                
                    public void setStatus(String status) {
                        this.status = status;
                    }
                
                    public void setLastError(String lastError) {
                        this.lastError = lastError;
                    }
                
                    public void setStartTime(Date startTime) {
                        this.startTime = startTime;
                    }
                
                    public void setEndTime(Date endTime) {
                        this.endTime = endTime;
                    }
                
                    public void setLastIterationTime(Date lastIterationTime) {
                        this.lastIterationTime = lastIterationTime;
                    }
                
                    public void setLastProductFoundTime(Date lastProductFoundTime) {
                        this.lastProductFoundTime = lastProductFoundTime;
                    }
                
                    // Методы для работы со статистикой
                    public void addProductsFound(int count) {
                        this.totalProductsFound += count;
                        this.lastProductFoundTime = new Date();
                    }
                
                    public void incrementRequestsMade() {
                        this.requestsMade++;
                    }
                
                    public void incrementErrors() {
                        this.errorsCount++;
                    }
                
                    public void addRecentProduct(Map<String, Object> productInfo) {
                        synchronized (recentProducts) {
                            recentProducts.add(0, productInfo); // Добавляем в начало
                
                            // Ограничиваем размер истории
                            if (recentProducts.size() > 100) {
                                recentProducts.remove(recentProducts.size() - 1);
                            }
                        }
                    }
                
                    /**
                     * Получение подробного статуса сессии
                     */
                    public Map<String, Object> getDetailedStatus() {
                        Map<String, Object> status = new HashMap<>();
                
                        status.put("userId", userId);
                        status.put("running", running);
                        status.put("paused", paused);
                        status.put("status", this.status);
                        status.put("queriesCount", queries.size());
                        status.put("totalProductsFound", totalProductsFound);
                        status.put("requestsMade", requestsMade);
                        status.put("errorsCount", errorsCount);
                        status.put("lastError", lastError);
                
                        // Временные метки
                        status.put("startTime", startTime != null ? startTime.getTime() : null);
                        status.put("endTime", endTime != null ? endTime.getTime() : null);
                        status.put("lastIterationTime", lastIterationTime != null ? lastIterationTime.getTime() : null);
                        status.put("lastProductFoundTime", lastProductFoundTime != null ? lastProductFoundTime.getTime() : null);
                
                        // Uptime
                        if (startTime != null) {
                            long uptime = System.currentTimeMillis() - startTime.getTime();
                            status.put("uptime", formatUptime(uptime));
                        }
                
                        // Настройки
                        if (settings != null) {
                            Map<String, Object> settingsMap = new HashMap<>();
                            settingsMap.put("checkInterval", settings.getCheckInterval());
                            settingsMap.put("maxAgeMinutes", settings.getMaxAgeMinutes());
                            settingsMap.put("maxPages", settings.getMaxPages());
                            settingsMap.put("rowsPerPage", settings.getRowsPerPage());
                            settingsMap.put("priceCurrency", settings.getPriceCurrency());
                            settingsMap.put("notifyNewOnly", settings.isNotifyNewOnly());
                            status.put("settings", settingsMap);
                        }
                
                        // Запросы (первые 5)
                        status.put("sampleQueries", queries.size() > 5 ?
                                queries.subList(0, 5) : queries);
                
                        return status;
                    }
                
                    /**
                     * Форматирование времени работы
                     */
                    private String formatUptime(long millis) {
                        long seconds = millis / 1000;
                        long minutes = seconds / 60;
                        long hours = minutes / 60;
                        long days = hours / 24;
                
                        if (days > 0) {
                            return String.format("%dд %dч %dм", days, hours % 24, minutes % 60);
                        } else if (hours > 0) {
                            return String.format("%dч %dм %dс", hours, minutes % 60, seconds % 60);
                        } else if (minutes > 0) {
                            return String.format("%dм %dс", minutes, seconds % 60);
                        } else {
                            return String.format("%dс", seconds);
                        }
                    }
                
                    /**
                     * Получение статистики эффективности
                     */
                    public Map<String, Object> getEfficiencyStats() {
                        Map<String, Object> stats = new HashMap<>();
                
                        if (requestsMade > 0) {
                            double productsPerRequest = (double) totalProductsFound / requestsMade;
                            double errorRate = (double) errorsCount / requestsMade;
                
                            stats.put("productsPerRequest", Math.round(productsPerRequest * 100.0) / 100.0);
                            stats.put("errorRate", Math.round(errorRate * 10000.0) / 100.0); // в процентах
                            stats.put("successRate", Math.round((1 - errorRate) * 10000.0) / 100.0);
                        }
                
                        if (startTime != null && lastIterationTime != null) {
                            long avgIterationTime = (lastIterationTime.getTime() - startTime.getTime()) /
                                    Math.max(requestsMade, 1);
                            stats.put("avgIterationTimeMs", avgIterationTime);
                        }
                
                        return stats;
                    }
                
                    /**
                     * Сброс статистика
                     */
                    public void resetStatistics() {
                        totalProductsFound = 0;
                        requestsMade = 0;
                        errorsCount = 0;
                        recentProducts.clear();
                        lastError = null;
                        logger.info("Statistics reset for user {}", userId);
                    }
                
                    /**
                     * Обновление списка запросов
                     */
                    public boolean updateQueries(List<String> newQueries) {
                        if (newQueries == null || newQueries.isEmpty()) {
                            logger.warn("Attempted to set empty queries for user {}", userId);
                            return false;
                        }
                
                        this.queries.clear();
                        this.queries.addAll(newQueries);
                        logger.debug("Queries updated for user {}, now has {} queries",
                                userId, queries.size());
                        return true;
                    }
                
                    /**
                     * Проверка, активна ли сессия
                     */
                    public boolean isActive() {
                        return running && !paused;
                    }
                
                    @Override
                    public String toString() {
                        return String.format("UserSession{userId=%d, running=%s, queries=%d, found=%d}",
                                userId, running, queries.size(), totalProductsFound);
                    }
                }
                ----------------------------------------

              [FILE] ThreadManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/core/ThreadManager.java
                Размер: 16895 байт
                Дата изменения: 2026-01-20T09:17:42.9105603Z
                Содержимое:
                ----------------------------------------
                package com.parser.core;
                
                import com.parser.config.Config;
                import com.parser.model.Product;
                import com.parser.model.UserSettings;
                import com.parser.parser.ParserFactory;
                import com.parser.parser.SiteParser;
                import com.parser.service.CookieService;
                import com.parser.storage.ProductDuplicateFilter;
                import com.parser.storage.UserDataManager;
                import com.parser.storage.WhitelistManager;
                import com.parser.telegram.TelegramNotificationService;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.nio.charset.StandardCharsets;
                import java.util.*;
                import java.util.concurrent.*;
                
                /**
                 * Управление потоками парсеров пользователей
                 */
                public class ThreadManager {
                    private static final Logger logger = LoggerFactory.getLogger(ThreadManager.class);
                
                    private final Map<Long, UserSession> userSessions = new ConcurrentHashMap<>();
                    private final ThreadPoolExecutor threadPool;
                    private final ScheduledExecutorService scheduler;
                
                    private int totalProductsFound = 0;
                    private int totalRequestsMade = 0;
                    private final Date startTime = new Date();
                
                    public ThreadManager() {
                        int coreSize = Config.getThreadPoolCoreSize();
                        int maxSize = Config.getThreadPoolMaxSize();
                        int keepAlive = Config.getInt("thread.pool.keepalive.seconds", 60);
                
                        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>(50);
                        threadPool = new ThreadPoolExecutor(coreSize, maxSize, keepAlive, TimeUnit.SECONDS,
                                workQueue, new ThreadPoolExecutor.CallerRunsPolicy());
                
                        scheduler = Executors.newScheduledThreadPool(1);
                
                        // Логирование статистики каждые 10 минут
                        scheduler.scheduleAtFixedRate(this::logStatistics, 10, 10, TimeUnit.MINUTES);
                
                        // Автообновление кук каждые 2 часа
                        if (Config.getCookieAutoUpdate()) {
                            int interval = Config.getCookieUpdateInterval();
                            scheduler.scheduleAtFixedRate(() -> {
                                try {
                                    if (Config.isDynamicCookiesEnabled()) {
                                        logger.info("Auto-updating cookies...");
                                        CookieService.refreshCookies("www.goofish.com");
                                    }
                                } catch (Exception e) {
                                    logger.error("Cookie auto-update failed: {}", e.getMessage());
                                }
                            }, interval, interval, TimeUnit.MINUTES);
                        }
                
                        logger.info("ThreadManager initialized: core={}, max={}", coreSize, maxSize);
                    }
                
                    public boolean startUserParser(long userId) {
                        logger.info("Starting parser for user {}", userId);
                
                        // 🔴 ПРОВЕРКА WHITELIST
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            logger.warn("User {} not in whitelist", userId);
                            TelegramNotificationService.sendMessage(userId, "❌ You are not authorized to use this bot");
                            return false;
                        }
                
                        if (userSessions.containsKey(userId) && userSessions.get(userId).isRunning()) {
                            TelegramNotificationService.sendMessage(userId, "⚠️ Parser already running");
                            return false;
                        }
                
                        List<String> queries = UserDataManager.getUserQueries(userId);
                        if (queries.isEmpty()) {
                            TelegramNotificationService.sendMessage(userId, "📭 No search queries added. Use /addquery");
                            return false;
                        }
                
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                        UserSession session = new UserSession(userId, queries, settings);
                        userSessions.put(userId, session);
                
                        threadPool.submit(() -> runUserParser(session));
                
                        logger.info("Parser started for user {}: {} queries", userId, queries.size());
                        TelegramNotificationService.sendMessage(userId,
                                "✅ Parser started!\nQueries: " + queries.size() + "\nCheck interval: " + settings.getCheckInterval() + " sec");
                
                        return true;
                    }
                
                    private void runUserParser(UserSession session) {
                        long userId = session.getUserId();
                        session.setRunning(true);
                
                        logger.info("Parser loop started for user {}", userId);
                
                        try {
                            SiteParser parser = ParserFactory.createParser("goofish");
                
                            while (session.isRunning() && !Thread.currentThread().isInterrupted()) {
                                for (String query : session.getQueries()) {
                                    if (!session.isRunning()) break;
                
                                    try {
                                        List<Product> products = parser.search(
                                                query,
                                                session.getSettings().getMaxPages(),
                                                session.getSettings().getRowsPerPage(),
                                                session.getSettings().getMaxAgeMinutes()
                                        );
                
                                        totalRequestsMade++;
                                        session.incrementRequestsMade();
                
                                        if (!products.isEmpty()) {
                                            session.addProductsFound(products.size());
                                            totalProductsFound += products.size();
                
                                            if (shouldSendNotification(session, products)) {
                                                sendProductNotifications(userId, products, query, session.getSettings());
                                            }
                
                                            UserDataManager.saveUserProducts(userId, products);
                                        }
                
                                        Thread.sleep(Config.getInt("api.goofish.delay.between.requests", 2000));
                
                                    } catch (Exception e) {
                                        logger.error("Error searching '{}' for user {}: {}", query, userId, e.getMessage());
                                        session.incrementErrors();
                                        session.setLastError("Search error: " + e.getMessage());
                
                                        // Отправляем уведомление об ошибке пользователю
                                        TelegramNotificationService.sendMessage(userId,
                                                "❌ Ошибка при поиске '" + query + "': " + e.getMessage());
                
                                        Thread.sleep(5000);
                                    }
                                }
                
                                int interval = session.getSettings().getCheckInterval();
                                for (int i = 0; i < interval && session.isRunning(); i++) {
                                    Thread.sleep(1000);
                                }
                
                                session.setLastIterationTime(new Date());
                            }
                
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            logger.info("Parser thread interrupted for user {}", userId);
                        } catch (Exception e) {
                            logger.error("Parser error for user {}: {}", userId, e.getMessage(), e);
                            TelegramNotificationService.sendMessage(userId,
                                    "❌ Критическая ошибка парсера: " + e.getMessage());
                        } finally {
                            session.setRunning(false);
                            userSessions.remove(userId);
                            String message = String.format("🛑 Parser stopped\nTotal found: %d products\nErrors: %d",
                                    session.getTotalProductsFound(), session.getErrorsCount());
                            TelegramNotificationService.sendMessage(userId, message);
                        }
                    }
                
                    // Остальные методы остаются без изменений...
                    private boolean shouldSendNotification(UserSession session, List<Product> products) {
                        if (products.isEmpty()) return false;
                
                        if (session.getSettings().isNotifyNewOnly()) {
                            // Без использования ProductDuplicateFilter, чтобы избежать рекурсии
                            List<Product> existingProducts = UserDataManager.getUserProducts(session.getUserId());
                            Set<String> existingIds = new HashSet<>();
                            for (Product p : existingProducts) {
                                existingIds.add(p.getId());
                            }
                
                            for (Product p : products) {
                                if (!existingIds.contains(p.getId())) {
                                    return true;
                                }
                            }
                            return false;
                        }
                        return true;
                    }
                
                
                    private void sendProductNotifications(long userId, List<Product> products, String query, UserSettings settings) {
                        if (products == null || products.isEmpty()) {
                            return;
                        }
                
                        logger.info("Sending notifications: {} products for user {}", products.size(), userId);
                
                        // 🔴 ПРОСТОЕ РЕШЕНИЕ: Сохраняем без сложной логики
                        try {
                            // Просто сохраняем товары (без проверки дубликатов для устранения рекурсии)
                            String json = new com.fasterxml.jackson.databind.ObjectMapper()
                                    .writeValueAsString(products);
                
                            String filepath = Config.getStorageDataDir() + "/user_products/" + userId + ".json";
                            java.nio.file.Files.write(
                                    java.nio.file.Paths.get(filepath),
                                    json.getBytes(StandardCharsets.UTF_8)
                            );
                
                            logger.debug("✅ Товары сохранены для пользователя {}", userId);
                        } catch (Exception e) {
                            logger.error("Ошибка сохранения товаров: {}", e.getMessage());
                        }
                
                        // 🟢 Отправляем уведомления
                        String summary = String.format("🔍 Found %d products for '<b>%s</b>'\n\n",
                                products.size(), escapeHtml(query));
                        TelegramNotificationService.sendHtmlMessage(userId, summary);
                
                        // Отправляем товары по одному
                        for (int i = 0; i < products.size(); i++) {
                            Product p = products.get(i);
                
                            try {
                                if (p.hasCoverImage()) {
                                    sendProductWithPhoto(userId, p, i + 1, products.size());
                                } else {
                                    sendProductAsText(userId, p, i + 1, products.size());
                                }
                
                                Thread.sleep(800);
                            } catch (InterruptedException e) {
                                Thread.currentThread().interrupt();
                                break;
                            } catch (Exception e) {
                                logger.error("Error sending notification for product {}: {}", p.getId(), e.getMessage());
                            }
                        }
                    }
                
                    private void sendProductWithPhoto(long userId, Product p, int number, int total) {
                        try {
                            // Создаем подпись под фото
                            String caption = formatProductCaption(p, number, total);
                
                            // Отправляем фото с подписью
                            boolean sent = TelegramNotificationService.sendPhotoWithHtmlCaption(userId,
                                    p.getCoverImageUrl(), caption);
                
                            // Если не удалось отправить фото, отправляем текст
                            if (!sent) {
                                sendProductAsText(userId, p, number, total);
                            }
                        } catch (Exception e) {
                            logger.warn("Failed to send photo for product {}, sending as text: {}",
                                    p.getId(), e.getMessage());
                            sendProductAsText(userId, p, number, total);
                        }
                    }
                
                    private void sendProductAsText(long userId, Product p, int number, int total) {
                        try {
                            String message = formatProductCaption(p, number, total);
                            TelegramNotificationService.sendHtmlMessage(userId, message);
                        } catch (Exception e) {
                            logger.error("Failed to send product text for {}: {}", p.getId(), e.getMessage());
                        }
                    }
                
                
                    private String formatProductMessage(Product p, UserSettings settings) {
                        return String.format("🛍️ <a href=\"%s\">%s</a>\n💰 %s\n📍 %s\n⏳ %s",
                                p.getUrl(), escapeHtml(p.getTitle()), p.getPriceDisplay(),
                                escapeHtml(p.getLocation()), p.getAgeDisplay());
                    }
                
                    private String getNumberEmoji(int number) {
                        String[] emojis = {"1️⃣", "2️⃣", "3️⃣", "4️⃣", "5️⃣", "6️⃣", "7️⃣", "8️⃣", "9️⃣", "🔟"};
                        if (number > 0 && number <= emojis.length) {
                            return emojis[number - 1];
                        }
                        return number + ".";
                    }
                
                    private String formatProductCaption(Product p, int number, int total) {
                        // Номер товара с эмодзи
                        String numberEmoji = getNumberEmoji(number);
                
                        // Название как гиперссылка
                        String titleLink = String.format("<a href=\"%s\"><b>%s</b></a>",
                                escapeHtml(p.getUrl()),
                                escapeHtml(p.getShortTitle()));
                
                        // Цена: юани и рубли
                        String priceRub = String.format("%.0f", p.getPriceRubles());
                        String price = String.format("💰 <b>%s ¥</b> | %s руб",
                                String.format("%.0f", p.getPrice()),
                                priceRub);
                
                        // Локация
                        String location = String.format("📍 <i>%s</i>", escapeHtml(p.getLocation()));
                
                        // Возраст
                        String age = String.format("⏳ %s", p.getAgeDisplay());
                
                        // Собираем итоговое сообщение
                        return String.format("%s %s\n\n%s\n%s\n%s",
                                numberEmoji, titleLink, price, location, age);
                    }
                
                    private String escapeHtml(String text) {
                        if (text == null) return "";
                        return text.replace("&", "&amp;")
                                .replace("<", "&lt;")
                                .replace(">", "&gt;")
                                .replace("\"", "&quot;")
                                .replace("'", "&#39;");
                    }
                
                    public boolean stopUserParser(long userId) {
                        UserSession session = userSessions.get(userId);
                        if (session != null) {
                            session.setRunning(false);
                            userSessions.remove(userId);
                            logger.info("Parser stopped for user {}", userId);
                
                            // Очищаем кэш фильтра при остановке
                            ProductDuplicateFilter.clearUserCache(userId);
                
                            return true;
                        }
                        return false;
                    }
                
                    public boolean pauseUserParser(long userId) {
                        UserSession session = userSessions.get(userId);
                        if (session != null && session.isRunning()) {
                            session.setPaused(true);
                            logger.info("Parser paused for user {}", userId);
                            return true;
                        }
                        return false;
                    }
                
                    public boolean resumeUserParser(long userId) {
                        UserSession session = userSessions.get(userId);
                        if (session != null && session.isPaused()) {
                            session.setPaused(false);
                            logger.info("Parser resumed for user {}", userId);
                            return true;
                        }
                        return false;
                    }
                
                    public Map<String, Object> getUserStatus(long userId) {
                        UserSession session = userSessions.get(userId);
                        return session != null ? session.getDetailedStatus() : null;
                    }
                
                    public Map<String, Object> getGlobalStatistics() {
                        Map<String, Object> stats = new HashMap<>();
                        stats.put("totalUsers", userSessions.size());
                        stats.put("totalProductsFound", totalProductsFound);
                        stats.put("totalRequestsMade", totalRequestsMade);
                        stats.put("uptime", System.currentTimeMillis() - startTime.getTime());
                        stats.put("activeThreads", threadPool.getActiveCount());
                        stats.put("poolSize", threadPool.getPoolSize());
                        stats.put("dynamicCookiesEnabled", Config.isDynamicCookiesEnabled());
                        return stats;
                    }
                
                    private void logStatistics() {
                        logger.info("Stats: users={}, products={}, requests={}, threads={}/{}",
                                userSessions.size(), totalProductsFound, totalRequestsMade,
                                threadPool.getActiveCount(), threadPool.getPoolSize());
                    }
                
                    public List<Long> getActiveUsers() {
                        return new ArrayList<>(userSessions.keySet());
                    }
                
                    public boolean isUserParserRunning(long userId) {
                        UserSession session = userSessions.get(userId);
                        return session != null && session.isRunning();
                    }
                
                    public void shutdown() {
                        logger.info("Shutting down ThreadManager...");
                
                        for (long userId : new ArrayList<>(userSessions.keySet())) {
                            stopUserParser(userId);
                        }
                
                        threadPool.shutdown();
                        scheduler.shutdown();
                
                        try {
                            if (!threadPool.awaitTermination(30, TimeUnit.SECONDS)) {
                                threadPool.shutdownNow();
                            }
                            if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                                scheduler.shutdownNow();
                            }
                            logger.info("ThreadManager shutdown complete");
                        } catch (InterruptedException e) {
                            threadPool.shutdownNow();
                            scheduler.shutdownNow();
                            Thread.currentThread().interrupt();
                        }
                    }
                }
                ----------------------------------------
            [DIR] test

              [FILE] SimpleTest.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/test/SimpleTest.java
                Размер: 1033 байт
                Дата изменения: 2026-01-19T23:09:01.610800597Z
                Содержимое:
                ----------------------------------------
                package com.parser.test;
                
                import org.apache.http.client.methods.HttpGet;
                import org.apache.http.util.EntityUtils;
                
                public class SimpleTest {
                    public static void main(String[] args) throws Exception {
                        // Простой GET запрос на сайт
                        String url = "https://www.goofish.com/search?q=stone%20island&spm=a21ybx.search.searchInput.0";
                
                        HttpGet request = new HttpGet(url);
                        request.setHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36");
                
                        try (var response = org.apache.http.impl.client.HttpClients.createDefault().execute(request)) {
                            String body = EntityUtils.toString(response.getEntity());
                            System.out.println("Статус: " + response.getStatusLine().getStatusCode());
                            System.out.println("Длина ответа: " + body.length());
                            System.out.println("Первые 500 символов:");
                            System.out.println(body.substring(0, Math.min(500, body.length())));
                        }
                    }
                }
                ----------------------------------------

              [FILE] ApiTester.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/test/ApiTester.java
                Размер: 25478 байт
                Дата изменения: 2026-01-19T23:35:14.091230081Z
                Содержимое:
                ----------------------------------------
                package com.parser.test;
                
                import com.parser.service.CookieService;
                import org.apache.http.client.methods.HttpPost;
                import org.apache.http.entity.StringEntity;
                import org.apache.http.impl.client.CloseableHttpClient;
                import org.apache.http.impl.client.HttpClients;
                import org.apache.http.util.EntityUtils;
                import org.json.JSONArray;
                import org.json.JSONObject;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.io.ByteArrayInputStream;
                import java.io.ByteArrayOutputStream;
                import java.nio.charset.StandardCharsets;
                import java.security.MessageDigest;
                import java.util.Arrays;
                import java.util.HashMap;
                import java.util.LinkedHashMap;
                import java.util.Map;
                
                // Для zstd декомпрессии - две опции:
                // Вариант 1: Используем Apache Commons Compress (уже есть в зависимостях через docker-java)
                import org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream;
                // Или Вариант 2: Используем чистую Java библиотеку (добавить в pom.xml)
                // import com.github.luben.zstd.ZstdInputStream;
                
                public class ApiTester {
                    private static final Logger logger = LoggerFactory.getLogger(ApiTester.class);
                    private static final String APP_KEY = "34839810";
                
                    public static void main(String[] args) {
                        try {
                            System.out.println("🧪 Тестирование API Goofish с динамической подписью...");
                
                            // Инициализируем куки
                            CookieService.initialize();
                
                            // Получаем свежие куки
                            String domain = "h5api.m.goofish.com";
                            String cookieHeader = CookieService.getCookieHeader(domain);
                            System.out.println("🍪 Куки получены (длина: " + cookieHeader.length() + " символов)");
                
                            // Извлекаем токен из куки _m_h5_tk
                            String token = extractTokenFromCookies(cookieHeader);
                            if (token.isEmpty()) {
                                System.err.println("❌ Не удалось извлечь токен из куки");
                                return;
                            }
                            System.out.println("🔑 Токен: " + (token.length() > 20 ? token.substring(0, 17) + "..." : token));
                
                            // Используем текущее время
                            long timestamp = System.currentTimeMillis();
                            System.out.println("⏰ Текущее время: " + timestamp);
                
                            // Формируем данные для запроса
                            String data = buildSearchData("stone island", 1, 30);
                            System.out.println("📝 Данные запроса: " + data.substring(0, Math.min(100, data.length())) + "...");
                
                            // Генерируем подпись
                            String sign = generateSignature(token, timestamp, data);
                            System.out.println("🔐 Подпись: " + sign);
                
                            // Строим URL с параметрами
                            String url = buildApiUrl(timestamp, sign);
                            System.out.println("📤 URL запроса: " + url);
                
                            // Создаем POST запрос
                            HttpPost request = new HttpPost(url);
                
                            // Устанавливаем заголовки как в реальном браузере
                            setBrowserHeaders(request);
                
                            // Добавляем куки
                            if (cookieHeader != null && !cookieHeader.isEmpty()) {
                                request.setHeader("Cookie", cookieHeader);
                                System.out.println("✅ Добавлены куки в заголовок");
                            } else {
                                System.err.println("⚠️ Куки пустые!");
                            }
                
                            // Формируем тело запроса (application/x-www-form-urlencoded)
                            String formData = "data=" + java.net.URLEncoder.encode(data, "UTF-8");
                            request.setEntity(new StringEntity(formData, StandardCharsets.UTF_8));
                
                            // Выполняем запрос
                            try (CloseableHttpClient client = HttpClients.createDefault();
                                 var response = client.execute(request)) {
                
                                int statusCode = response.getStatusLine().getStatusCode();
                                String contentType = response.getFirstHeader("Content-Type") != null ?
                                        response.getFirstHeader("Content-Type").getValue() : "unknown";
                                String contentEncoding = response.getFirstHeader("Content-Encoding") != null ?
                                        response.getFirstHeader("Content-Encoding").getValue() : "unknown";
                
                                System.out.println("\n📥 Ответ сервера:");
                                System.out.println("Статус: " + statusCode);
                                System.out.println("Content-Type: " + contentType);
                                System.out.println("Content-Encoding: " + contentEncoding);
                
                                // Выводим заголовки ответа
                                System.out.println("\n📋 Заголовки ответа:");
                                for (org.apache.http.Header header : response.getAllHeaders()) {
                                    String headerName = header.getName();
                                    String headerValue = header.getValue();
                
                                    // Сокращаем длинные значения
                                    if (headerValue.length() > 100) {
                                        headerValue = headerValue.substring(0, 97) + "...";
                                    }
                
                                    System.out.println("  " + headerName + ": " + headerValue);
                
                                    // Отслеживаем обновление куки
                                    if ("Set-Cookie".equalsIgnoreCase(headerName)) {
                                        System.out.println("  ⚠️ Сервер обновил куки!");
                                    }
                                }
                
                                // Получаем сырые байты ответа
                                byte[] responseBytes = EntityUtils.toByteArray(response.getEntity());
                                String responseBody;
                
                                // Обрабатываем сжатие в зависимости от Content-Encoding
                                if ("zstd".equalsIgnoreCase(contentEncoding)) {
                                    System.out.println("\n🔄 Распаковываем zstd сжатие...");
                                    responseBody = decompressZstd(responseBytes);
                                } else if ("gzip".equalsIgnoreCase(contentEncoding) || "deflate".equalsIgnoreCase(contentEncoding)) {
                                    // HttpClient обычно автоматически обрабатывает gzip/deflate
                                    responseBody = new String(responseBytes, StandardCharsets.UTF_8);
                                } else {
                                    // Без сжатия
                                    responseBody = new String(responseBytes, StandardCharsets.UTF_8);
                                }
                
                                System.out.println("\n📄 Тело ответа:");
                                if (responseBody.length() > 1000) {
                                    System.out.println(responseBody.substring(0, 1000) + "...");
                                    System.out.println("... (полный ответ: " + responseBody.length() + " символов)");
                                } else {
                                    System.out.println(responseBody);
                                }
                
                                // Парсим JSON ответ
                                if (responseBody.trim().startsWith("{") || responseBody.trim().startsWith("[")) {
                                    try {
                                        JSONObject json = new JSONObject(responseBody);
                                        System.out.println("\n✅ JSON успешно распарсен");
                
                                        if (json.has("ret")) {
                                            Object ret = json.get("ret");
                                            System.out.println("ret: " + ret);
                
                                            if (ret instanceof org.json.JSONArray) {
                                                org.json.JSONArray retArray = (org.json.JSONArray) ret;
                                                for (int i = 0; i < retArray.length(); i++) {
                                                    String retItem = retArray.getString(i);
                                                    System.out.println("  ret[" + i + "]: " + retItem);
                
                                                    if (retItem.contains("FAIL_SYS_ILLEGAL_ACCESS")) {
                                                        System.err.println("❌ ОШИБКА: НЕЗАКОННЫЙ ЗАПРОС!");
                                                        System.err.println("   Причина: неверная подпись или устаревшие параметры");
                                                    } else if (retItem.contains("被挤爆啦")) {
                                                        System.err.println("❌ ОШИБКА: СЕРВЕР ПЕРЕГРУЖЕН!");
                                                        System.err.println("   Сообщение: " + retItem);
                                                    }
                                                }
                                            }
                                        }
                
                                        if (json.has("data")) {
                                            Object dataObj = json.get("data");
                                            System.out.println("data тип: " + dataObj.getClass().getSimpleName());
                
                                            if (dataObj instanceof JSONObject) {
                                                JSONObject dataJson = (JSONObject) dataObj;
                
                                                // Проверяем различные возможные структуры данных
                                                if (dataJson.has("resultList")) {
                                                    System.out.println("✅ Найдены товары в resultList!");
                                                    Object resultList = dataJson.get("resultList");
                                                    if (resultList instanceof JSONArray) {
                                                        JSONArray items = (JSONArray) resultList;
                                                        System.out.println("   Количество товаров: " + items.length());
                                                        for (int i = 0; i < Math.min(3, items.length()); i++) {
                                                            System.out.println("   Товар " + (i+1) + ": " + items.get(i));
                                                        }
                                                    }
                                                } else if (dataJson.has("items")) {
                                                    System.out.println("✅ Найдены товары в items!");
                                                } else if (dataJson.has("list")) {
                                                    System.out.println("✅ Найдены товары в list!");
                                                } else {
                                                    System.out.println("📊 Структура data: " + dataJson.toString(2));
                                                }
                                            } else if (dataObj instanceof String) {
                                                System.out.println("data (строка): " + dataObj);
                                                // Проверяем, не является ли это URL для редиректа/авторизации
                                                String dataStr = (String) dataObj;
                                                if (dataStr.contains("http") || dataStr.contains("login")) {
                                                    System.err.println("⚠️  Возможно требуется авторизация!");
                                                }
                                            }
                                        } else {
                                            System.out.println("📊 Полная структура JSON: " + json.toString(2));
                                        }
                
                                    } catch (Exception e) {
                                        System.err.println("❌ Ошибка парсинга JSON: " + e.getMessage());
                                        e.printStackTrace();
                
                                        // Показываем начало ответа для отладки
                                        if (responseBody.length() > 200) {
                                            System.err.println("Первые 200 символов ответа: " + responseBody.substring(0, 200));
                                        }
                                    }
                                } else {
                                    System.err.println("❌ Ответ не в формате JSON");
                                    if (responseBody.contains("<html") || responseBody.contains("<!DOCTYPE")) {
                                        System.err.println("⚠️ Получена HTML страница вместо JSON. Возможно, куки недействительны.");
                                    } else if (responseBody.length() < 100) {
                                        System.err.println("Короткий ответ: " + responseBody);
                                    }
                                }
                
                                // Анализ ответа
                                analyzeResponse(statusCode, responseBody);
                
                            }
                
                        } catch (Exception e) {
                            System.err.println("❌ Критическая ошибка: " + e.getMessage());
                            e.printStackTrace();
                        }
                    }
                
                    /**
                     * Распаковка zstd сжатых данных
                     */
                    /**
                     * Распаковка zstd сжатых данных
                     */
                    private static String decompressZstd(byte[] compressedData) {
                        try {
                            System.out.println("📦 Размер сжатых данных: " + compressedData.length + " байт");
                
                            try (ByteArrayInputStream bais = new ByteArrayInputStream(compressedData);
                                 org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream zstdIn =
                                         new org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream(bais);
                                 ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                
                                byte[] buffer = new byte[8192];
                                int len;
                                while ((len = zstdIn.read(buffer)) > 0) {
                                    baos.write(buffer, 0, len);
                                }
                
                                String result = baos.toString("UTF-8");
                                System.out.println("✅ Zstd успешно распакован");
                                System.out.println("📄 Размер распакованных данных: " + result.length() + " символов");
                                return result;
                            }
                
                        } catch (Exception e) {
                            System.err.println("❌ Ошибка распаковки zstd: " + e.getMessage());
                            e.printStackTrace();
                
                            // Пробуем прочитать как обычную строку (на случай, если это не zstd)
                            try {
                                String fallback = new String(compressedData, StandardCharsets.UTF_8);
                                System.out.println("⚠️  Используем fallback чтение как UTF-8");
                                return fallback;
                            } catch (Exception e2) {
                                return "Ошибка при обработке ответа: " + e.getMessage();
                            }
                        }
                    }
                
                    /**
                     * Извлечение токена из строки куки
                     */
                    private static String extractTokenFromCookies(String cookieHeader) {
                        if (cookieHeader == null || cookieHeader.isEmpty()) {
                            return "";
                        }
                
                        // Разделяем куки по точке с запятой
                        String[] cookiePairs = cookieHeader.split("; ");
                        for (String pair : cookiePairs) {
                            if (pair.startsWith("_m_h5_tk=")) {
                                String value = pair.substring(9); // Убираем "_m_h5_tk="
                                // Токен - часть до первого подчеркивания
                                int underscoreIndex = value.indexOf('_');
                                if (underscoreIndex != -1) {
                                    return value.substring(0, underscoreIndex);
                                }
                                return value;
                            }
                        }
                
                        return "";
                    }
                
                    /**
                     * Генерация подписи MD5
                     */
                    private static String generateSignature(String token, long timestamp, String data) {
                        try {
                            String signString = token + "&" + timestamp + "&" + APP_KEY + "&" + data;
                
                            MessageDigest md = MessageDigest.getInstance("MD5");
                            byte[] hash = md.digest(signString.getBytes(StandardCharsets.UTF_8));
                
                            StringBuilder hex = new StringBuilder();
                            for (byte b : hash) {
                                String h = Integer.toHexString(0xff & b);
                                if (h.length() == 1) {
                                    hex.append('0');
                                }
                                hex.append(h);
                            }
                
                            return hex.toString();
                        } catch (Exception e) {
                            System.err.println("❌ Ошибка генерации подписи: " + e.getMessage());
                            return "";
                        }
                    }
                
                    /**
                     * Формирование данных для поиска
                     */
                    private static String buildSearchData(String query, int page, int rows) {
                        JSONObject data = new JSONObject();
                        data.put("pageNumber", page);
                        data.put("keyword", query);
                        data.put("fromFilter", false);
                        data.put("rowsPerPage", rows);
                        data.put("sortValue", "");
                        data.put("sortField", "");
                        data.put("customDistance", "");
                        data.put("gps", "");
                        data.put("propValueStr", new JSONObject());
                        data.put("customGps", "");
                        data.put("searchReqFromPage", "pcSearch");
                        data.put("extraFilterValue", "{}");
                        data.put("userPositionJson", "{}");
                
                        return data.toString();
                    }
                
                    /**
                     * Построение URL API с параметрами
                     */
                    private static String buildApiUrl(long timestamp, String sign) {
                        Map<String, String> params = new LinkedHashMap<>();
                        params.put("jsv", "2.7.2");
                        params.put("appKey", APP_KEY);
                        params.put("t", String.valueOf(timestamp));
                        params.put("sign", sign);
                        params.put("v", "1.0");
                        params.put("type", "originaljson");
                        params.put("accountSite", "xianyu");
                        params.put("dataType", "json");
                        params.put("timeout", "20000");
                        params.put("api", "mtop.taobao.idlemtopsearch.pc.search");
                        params.put("sessionOption", "AutoLoginOnly");
                        params.put("spm_cnt", "a21ybx.search.0.0");
                        params.put("spm_pre", "a21ybx.search.searchInput.0");
                
                        StringBuilder url = new StringBuilder("https://h5api.m.goofish.com/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/?");
                
                        boolean first = true;
                        for (Map.Entry<String, String> entry : params.entrySet()) {
                            if (!first) {
                                url.append("&");
                            }
                            url.append(entry.getKey())
                                    .append("=")
                                    .append(java.net.URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8));
                            first = false;
                        }
                
                        return url.toString();
                    }
                
                    /**
                     * Установка заголовков браузера
                     */
                    private static void setBrowserHeaders(HttpPost request) {
                        request.setHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 YaBrowser/25.10.0.0 Safari/537.36");
                        request.setHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
                        request.setHeader("Accept", "application/json");
                        request.setHeader("Accept-Encoding", "gzip, deflate, br, zstd");
                        request.setHeader("Accept-Language", "ru,en;q=0.9");
                        request.setHeader("Origin", "https://www.goofish.com");
                        request.setHeader("Referer", "https://www.goofish.com/");
                        request.setHeader("Sec-Fetch-Dest", "empty");
                        request.setHeader("Sec-Fetch-Mode", "cors");
                        request.setHeader("Sec-Fetch-Site", "same-site");
                        request.setHeader("sec-ch-ua", "\"Chromium\";v=\"140\", \"Not=A?Brand\";v=\"24\", \"YaBrowser\";v=\"25.10\", \"Yowser\";v=\"2.5\", \"YaBrowserCorp\";v=\"140\"");
                        request.setHeader("sec-ch-ua-mobile", "?0");
                        request.setHeader("sec-ch-ua-platform", "\"macOS\"");
                        request.setHeader("x-accept-terminal", "pc");
                        request.setHeader("Connection", "keep-alive");
                        request.setHeader("Pragma", "no-cache");
                        request.setHeader("Cache-Control", "no-cache");
                    }
                
                    /**
                     * Анализ ответа сервера
                     */
                    private static void analyzeResponse(int statusCode, String responseBody) {
                        System.out.println("\n🔍 Анализ ответа:");
                
                        if (statusCode == 200) {
                            System.out.println("✅ HTTP статус: 200 OK");
                
                            if (responseBody.contains("FAIL_SYS_ILLEGAL_ACCESS")) {
                                System.err.println("❌ Содержимое: НЕЗАКОННЫЙ ЗАПРОС");
                                System.err.println("   Возможные причины:");
                                System.err.println("   1. Неверная подпись (sign)");
                                System.err.println("   2. Устаревший timestamp (t)");
                                System.err.println("   3. Неверный токен из куки _m_h5_tk");
                                System.err.println("   4. Неверный формат данных (data)");
                            } else if (responseBody.contains("FAIL_SYS_SESSION_EXPIRED")) {
                                System.err.println("❌ Содержимое: СЕССИЯ ИСТЕКЛА");
                                System.err.println("   Требуется обновление куки");
                            } else if (responseBody.contains("SUCCESS")) {
                                System.out.println("✅ Содержимое: УСПЕШНЫЙ ЗАПРОС");
                            } else if (responseBody.contains("resultList") || responseBody.contains("\"data\":")) {
                                System.out.println("✅ Содержимое: НАЙДЕНЫ ДАННЫЕ");
                            } else if (responseBody.contains("\"ret\":") && responseBody.contains("SUCCESS")) {
                                System.out.println("✅ Содержимое: API УСПЕШНО ВЫПОЛНЕНО");
                            } else {
                                System.out.println("⚠️  Содержимое: НЕИЗВЕСТНЫЙ ОТВЕТ");
                                System.out.println("   Первые 200 символов: " +
                                        (responseBody.length() > 200 ? responseBody.substring(0, 200) + "..." : responseBody));
                            }
                        } else if (statusCode == 403) {
                            System.err.println("❌ HTTP статус: 403 FORBIDDEN");
                            System.err.println("   Доступ запрещен. Возможно, куки недействительны.");
                        } else if (statusCode == 429) {
                            System.err.println("❌ HTTP статус: 429 TOO MANY REQUESTS");
                            System.err.println("   Слишком много запросов. Нужно добавить задержку.");
                        } else if (statusCode == 401) {
                            System.err.println("❌ HTTP статус: 401 UNAUTHORIZED");
                            System.err.println("   Требуется авторизация. Куки устарели.");
                        } else {
                            System.err.println("❌ HTTP статус: " + statusCode);
                        }
                    }
                
                    /**
                     * Дополнительный метод для отладки куки
                     */
                    private static void debugCookies(String cookieHeader) {
                        System.out.println("\n🔍 Отладка куки:");
                
                        if (cookieHeader == null || cookieHeader.isEmpty()) {
                            System.err.println("❌ Куки пустые");
                            return;
                        }
                
                        String[] cookies = cookieHeader.split("; ");
                        System.out.println("📊 Всего куки: " + cookies.length);
                
                        // Важные куки для проверки
                        String[] importantCookies = {"_m_h5_tk", "_m_h5_tk_enc", "_tb_token_", "cna", "cookie2", "t", "tfstk"};
                
                        for (String cookie : cookies) {
                            String[] parts = cookie.split("=", 2);
                            if (parts.length == 2) {
                                String name = parts[0];
                                String value = parts[1];
                
                                // Проверяем, важная ли это кука
                                boolean isImportant = Arrays.asList(importantCookies).contains(name);
                
                                if (isImportant) {
                                    System.out.print("⭐ ");
                                } else {
                                    System.out.print("   ");
                                }
                
                                System.out.print(String.format("%-25s", name + ":"));
                
                                // Обрезаем длинные значения
                                if (value.length() > 50) {
                                    System.out.println(value.substring(0, 47) + "...");
                                } else {
                                    System.out.println(value);
                                }
                
                                // Особый анализ для _m_h5_tk
                                if ("_m_h5_tk".equals(name)) {
                                    if (value.contains("_")) {
                                        String[] tokenParts = value.split("_", 2);
                                        System.out.println("        Токен: " + tokenParts[0]);
                                        System.out.println("        Время: " + tokenParts[1]);
                                        System.out.println("        Статус: " + (tokenParts[0].length() == 32 ? "✅ Корректный" : "❌ Некорректный"));
                                    } else {
                                        System.err.println("        ⚠️ Нет временной метки в _m_h5_tk!");
                                    }
                                }
                            }
                        }
                    }
                }
                ----------------------------------------
            [DIR] util

              [FILE] HttpUtils.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/util/HttpUtils.java
                Размер: 20508 байт
                Дата изменения: 2026-01-19T09:31:29.777394501Z
                Содержимое:
                ----------------------------------------
                package com.parser.util;
                
                import com.parser.config.Config;
                import com.parser.config.CookieConfig;
                import com.parser.service.CookieService;
                import org.apache.http.HttpHeaders;
                import org.apache.http.HttpStatus;
                import org.apache.http.client.config.CookieSpecs;
                import org.apache.http.client.config.RequestConfig;
                import org.apache.http.client.methods.CloseableHttpResponse;
                import org.apache.http.client.methods.HttpGet;
                import org.apache.http.client.methods.HttpPost;
                import org.apache.http.entity.StringEntity;
                import org.apache.http.impl.client.CloseableHttpClient;
                import org.apache.http.impl.client.HttpClients;
                import org.apache.http.impl.client.LaxRedirectStrategy;
                import org.apache.http.util.EntityUtils;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.net.URL;
                import java.nio.charset.StandardCharsets;
                import java.util.HashMap;
                import java.util.Map;
                import java.util.Random;
                
                /**
                 * Утилиты для работы с HTTP запросами
                 */
                public class HttpUtils {
                    private static final Logger logger = LoggerFactory.getLogger(HttpUtils.class);
                    private static final Random random = new Random();
                
                    // Константы для заголовков кук
                    private static final String HEADER_COOKIE = "Cookie";
                    private static final String HEADER_SET_COOKIE = "Set-Cookie";
                    private static final String HEADER_CONTENT_LENGTH = "Content-Length";
                
                    // Конфигурация HTTP клиента
                    private static final RequestConfig requestConfig = RequestConfig.custom()
                            .setConnectTimeout(Config.getHttpConnectTimeout())
                            .setSocketTimeout(Config.getHttpReadTimeout())
                            .setConnectionRequestTimeout(5000)
                            .setRedirectsEnabled(true)
                            .setCookieSpec(CookieSpecs.STANDARD)
                            .build();
                
                    // Пул HTTP клиентов
                    private static volatile CloseableHttpClient httpClient = null;
                
                    /**
                     * Получение HTTP клиента
                     */
                    private static synchronized CloseableHttpClient getHttpClient() {
                        if (httpClient == null) {
                            httpClient = HttpClients.custom()
                                    .setDefaultRequestConfig(requestConfig)
                                    .setRedirectStrategy(new LaxRedirectStrategy())
                                    .setUserAgent(getRandomUserAgent())
                                    .setMaxConnTotal(100)
                                    .setMaxConnPerRoute(20)
                                    .disableCookieManagement() // Управляем куками вручную
                                    .build();
                            logger.debug("HTTP client initialized");
                        }
                        return httpClient;
                    }
                
                    /**
                     * Отправка GET запроса
                     */
                    public static String sendGetRequest(String url) throws Exception {
                        return sendGetRequest(url, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * Отправка GET запроса с указанием User-Agent
                     */
                    public static String sendGetRequest(String url, String userAgent) throws Exception {
                        return sendGetRequest(url, userAgent, true);
                    }
                
                    /**
                     * Отправка GET запроса с расширенными параметрами
                     */
                    public static String sendGetRequest(String url, String userAgent, boolean useCookies) throws Exception {
                        if (url == null || url.isEmpty()) {
                            throw new IllegalArgumentException("URL cannot be empty");
                        }
                
                        logger.debug("Sending GET request to: {}", url);
                
                        HttpGet request = new HttpGet(url);
                        request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                        request.setHeader(HttpHeaders.ACCEPT, "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
                        request.setHeader(HttpHeaders.ACCEPT_LANGUAGE, "en-US,en;q=0.9,ru;q=0.8");
                        request.setHeader(HttpHeaders.ACCEPT_ENCODING, "gzip, deflate, br");
                        request.setHeader(HttpHeaders.CONNECTION, "keep-alive");
                        request.setHeader("Upgrade-Insecure-Requests", "1");
                
                        // Добавляем куки, если требуется
                        if (useCookies) {
                            String domain = extractDomain(url);
                            try {
                                // Используем динамические куки из CookieService
                                String cookieHeader = CookieService.getCookieHeader(domain);
                                if (cookieHeader != null && !cookieHeader.isEmpty()) {
                                    request.setHeader(HEADER_COOKIE, cookieHeader);
                                    logger.debug("Added dynamic cookies for domain {} ({} chars)",
                                            domain, cookieHeader.length());
                                } else {
                                    logger.warn("No dynamic cookies available for domain: {}", domain);
                                    // Fallback на статические куки
                                    String cookies = CookieConfig.getCookiesForDomain(domain);
                                    if (cookies != null && !cookies.isEmpty()) {
                                        request.setHeader(HEADER_COOKIE, cookies);
                                        logger.debug("Using static cookies for domain: {}", domain);
                                    }
                                }
                            } catch (Exception e) {
                                logger.warn("Failed to get dynamic cookies for {}, falling back to static: {}",
                                        domain, e.getMessage());
                                // Fallback на статические куки
                                String cookies = CookieConfig.getCookiesForDomain(domain);
                                if (cookies != null && !cookies.isEmpty()) {
                                    request.setHeader(HEADER_COOKIE, cookies);
                                    logger.debug("Using static cookies for domain: {}", domain);
                                }
                            }
                        }
                
                        // Добавляем случайные заголовки для имитации браузера
                        addRandomHeaders(request);
                
                        try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                            int statusCode = response.getStatusLine().getStatusCode();
                            logger.debug("Response status: {} for URL: {}", statusCode, url);
                
                            // Обновляем куки из ответа, если требуется
                            if (Config.getCookieAutoUpdate() && useCookies) {
                                updateCookiesFromResponse(url, response);
                            }
                
                            if (statusCode == HttpStatus.SC_OK) {
                                String content = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
                                logger.trace("Response content length: {} chars for URL: {}", content.length(), url);
                                return content;
                            } else if (statusCode == HttpStatus.SC_TOO_MANY_REQUESTS) {
                                logger.warn("Rate limit exceeded for URL: {}", url);
                                throw new Exception("Rate limit exceeded (429)");
                            } else if (statusCode == HttpStatus.SC_FORBIDDEN) {
                                logger.warn("Access forbidden for URL: {}", url);
                                throw new Exception("Access forbidden (403) - May need fresh cookies");
                            } else if (statusCode == HttpStatus.SC_NOT_FOUND) {
                                logger.warn("URL not found: {}", url);
                                throw new Exception("Page not found (404)");
                            } else if (statusCode == HttpStatus.SC_UNAUTHORIZED) {
                                logger.warn("Unauthorized for URL: {}", url);
                                throw new Exception("Unauthorized (401) - Check cookies");
                            } else {
                                logger.warn("HTTP error {} for URL: {}", statusCode, url);
                                throw new Exception("HTTP error: " + statusCode);
                            }
                        } catch (Exception e) {
                            logger.error("Error sending request to {}: {}", url, e.getMessage());
                            throw e;
                        }
                    }
                
                    /**
                     * Отправка POST запроса
                     */
                    public static String sendPostRequest(String url, String jsonBody) throws Exception {
                        return sendPostRequest(url, jsonBody, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * Отправка POST запроса с расширенными параметрами
                     */
                    public static String sendPostRequest(String url, String jsonBody, String userAgent, boolean useCookies) throws Exception {
                        logger.debug("Sending POST request to: {}", url);
                
                        HttpPost request = new HttpPost(url);
                        request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                        request.setHeader(HttpHeaders.CONTENT_TYPE, "application/json");
                        request.setHeader(HttpHeaders.ACCEPT, "application/json");
                        request.setHeader(HttpHeaders.ACCEPT_ENCODING, "gzip, deflate, br");
                
                        if (jsonBody != null && !jsonBody.isEmpty()) {
                            request.setEntity(new StringEntity(jsonBody, StandardCharsets.UTF_8));
                        }
                
                        // Добавляем куки
                        if (useCookies) {
                            String domain = extractDomain(url);
                            String cookieHeader = CookieService.getCookieHeader(domain);
                            if (cookieHeader != null && !cookieHeader.isEmpty()) {
                                request.setHeader(HEADER_COOKIE, cookieHeader);
                            }
                        }
                
                        try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                            int statusCode = response.getStatusLine().getStatusCode();
                            if (statusCode == HttpStatus.SC_OK) {
                                String content = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
                                logger.debug("POST response length: {} chars", content.length());
                                return content;
                            } else {
                                throw new Exception("HTTP POST error: " + statusCode);
                            }
                        }
                    }
                
                    /**
                     * Извлечение домена из URL
                     */
                    public static String extractDomain(String url) {
                        try {
                            URL urlObj = new URL(url);
                            return urlObj.getHost();
                        } catch (Exception e) {
                            logger.warn("Failed to extract domain from URL: {}", url);
                            return "";
                        }
                    }
                
                    /**
                     * Обновление куки из заголовков ответа
                     */
                    private static void updateCookiesFromResponse(String url, CloseableHttpResponse response) {
                        try {
                            String domain = extractDomain(url);
                            org.apache.http.Header[] setCookieHeaders = response.getHeaders(HEADER_SET_COOKIE);
                
                            if (setCookieHeaders.length > 0) {
                                logger.debug("Found {} Set-Cookie headers for domain: {}", setCookieHeaders.length, domain);
                                for (org.apache.http.Header header : setCookieHeaders) {
                                    CookieConfig.parseSetCookieHeader(domain, header.getValue());
                                }
                                CookieConfig.saveCookies();
                            }
                        } catch (Exception e) {
                            logger.warn("Failed to update cookies from response: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение стандартного User-Agent
                     */
                    public static String getDefaultUserAgent() {
                        return Config.getHttpUserAgent();
                    }
                
                    /**
                     * Получение случайного User-Agent
                     */
                    public static String getRandomUserAgent() {
                        String[] userAgents = {
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0",
                                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                                "Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1",
                                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 YaBrowser/25.10.0.0 Safari/537.36"
                        };
                
                        return userAgents[random.nextInt(userAgents.length)];
                    }
                
                    /**
                     * Добавление случайных заголовков для имитации браузера
                     */
                    private static void addRandomHeaders(HttpGet request) {
                        if (random.nextBoolean()) {
                            request.setHeader("Sec-Fetch-Dest", "document");
                            request.setHeader("Sec-Fetch-Mode", "navigate");
                            request.setHeader("Sec-Fetch-Site", "none");
                            request.setHeader("Sec-Fetch-User", "?1");
                        }
                
                        if (random.nextBoolean()) {
                            request.setHeader(HttpHeaders.CACHE_CONTROL, "max-age=0");
                        }
                
                        // Случайный Referer
                        String[] referers = {
                                "https://www.google.com/",
                                "https://www.bing.com/",
                                "https://www.yahoo.com/",
                                "https://www.baidu.com/",
                                "https://h5.m.goofish.com/",
                                "https://www.goofish.com/",
                                ""
                        };
                        String referer = referers[random.nextInt(referers.length)];
                        if (!referer.isEmpty()) {
                            request.setHeader(HttpHeaders.REFERER, referer);
                        }
                    }
                
                    /**
                     * Кодирование URL параметров
                     */
                    public static String encodeUrl(String value) {
                        if (value == null) {
                            return "";
                        }
                        try {
                            return java.net.URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
                        } catch (Exception e) {
                            logger.error("Error encoding URL value: {}", e.getMessage());
                            return value;
                        }
                    }
                
                    /**
                     * Декодирование URL параметров
                     */
                    public static String decodeUrl(String value) {
                        if (value == null) {
                            return "";
                        }
                        try {
                            return java.net.URLDecoder.decode(value, StandardCharsets.UTF_8.toString());
                        } catch (Exception e) {
                            logger.error("Error decoding URL value: {}", e.getMessage());
                            return value;
                        }
                    }
                
                    /**
                     * Создание случайной задержки для имитации человеческого поведения
                     */
                    public static void randomDelay(int minMs, int maxMs) {
                        try {
                            int delay = minMs + random.nextInt(maxMs - minMs);
                            Thread.sleep(delay);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            logger.warn("Delay interrupted");
                        }
                    }
                
                    /**
                     * Проверка доступности URL
                     */
                    public static boolean isUrlAccessible(String url) {
                        return isUrlAccessible(url, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * Проверка доступности URL с указанием использования куки
                     */
                    public static boolean isUrlAccessible(String url, String userAgent, boolean useCookies) {
                        try {
                            HttpGet request = new HttpGet(url);
                            request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                
                            if (useCookies) {
                                String domain = extractDomain(url);
                                String cookies = CookieConfig.getCookiesForDomain(domain);
                                if (cookies != null && !cookies.isEmpty()) {
                                    request.setHeader(HEADER_COOKIE, cookies);
                                }
                            }
                
                            try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                                int statusCode = response.getStatusLine().getStatusCode();
                                return statusCode == HttpStatus.SC_OK;
                            }
                        } catch (Exception e) {
                            logger.debug("URL not accessible {}: {}", url, e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Получение размера содержимого по URL
                     */
                    public static long getContentLength(String url) throws Exception {
                        return getContentLength(url, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * Получение размера содержимого по URL с указанием использования куки
                     */
                    public static long getContentLength(String url, String userAgent, boolean useCookies) throws Exception {
                        try {
                            HttpGet request = new HttpGet(url);
                            request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                
                            if (useCookies) {
                                String domain = extractDomain(url);
                                String cookies = CookieConfig.getCookiesForDomain(domain);
                                if (cookies != null && !cookies.isEmpty()) {
                                    request.setHeader(HEADER_COOKIE, cookies);
                                }
                            }
                
                            try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                                if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                                    org.apache.http.Header[] headers = response.getHeaders(HEADER_CONTENT_LENGTH);
                                    if (headers.length > 0) {
                                        try {
                                            return Long.parseLong(headers[0].getValue());
                                        } catch (NumberFormatException e) {
                                            return -1;
                                        }
                                    }
                                }
                                return -1;
                            }
                        } catch (Exception e) {
                            logger.error("Error getting content length for {}: {}", url, e.getMessage());
                            throw e;
                        }
                    }
                
                    /**
                     * Проверка валидности куки
                     */
                    public static boolean testCookies(String url) {
                        try {
                            logger.info("Testing cookies for URL: {}", url);
                            String response = sendGetRequest(url, getDefaultUserAgent(), true);
                
                            // Проверяем ответ на признаки того, что мы авторизованы
                            if (response.contains("登录") || response.contains("login") ||
                                    response.contains("未登录") || response.contains("未授权") ||
                                    response.contains("请登录") || response.contains("signin")) {
                                logger.warn("Cookies appear to be invalid or expired");
                                return false;
                            }
                
                            logger.info("Cookies test successful for: {}", url);
                            return true;
                        } catch (Exception e) {
                            logger.error("Cookies test failed for {}: {}", url, e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Закрытие HTTP клиента
                     */
                    public static synchronized void closeHttpClient() {
                        if (httpClient != null) {
                            try {
                                httpClient.close();
                                httpClient = null;
                                logger.debug("HTTP client closed");
                            } catch (Exception e) {
                                logger.error("Error closing HTTP client: {}", e.getMessage());
                            }
                        }
                    }
                
                    /**
                     * Создание URL с параметрами
                     */
                    public static String buildUrlWithParams(String baseUrl, Map<String, String> params) {
                        StringBuilder url = new StringBuilder(baseUrl);
                        if (params != null && !params.isEmpty()) {
                            url.append("?");
                            boolean first = true;
                            for (Map.Entry<String, String> entry : params.entrySet()) {
                                if (!first) {
                                    url.append("&");
                                }
                                url.append(encodeUrl(entry.getKey()))
                                        .append("=")
                                        .append(encodeUrl(entry.getValue()));
                                first = false;
                            }
                        }
                        return url.toString();
                    }
                
                    /**
                     * Создание URL с параметрами из массива
                     */
                    public static String buildUrlWithParams(String baseUrl, String[][] params) {
                        Map<String, String> paramMap = new HashMap<>();
                        if (params != null) {
                            for (String[] param : params) {
                                if (param.length >= 2) {
                                    paramMap.put(param[0], param[1]);
                                }
                            }
                        }
                        return buildUrlWithParams(baseUrl, paramMap);
                    }
                
                    /**
                     * Получение HTTP клиента для внешнего использования
                     */
                    public static CloseableHttpClient getHttpClientInstance() {
                        return getHttpClient();
                    }
                }
                ----------------------------------------
            [DIR] config

              [FILE] ParserSettings.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/config/ParserSettings.java
                Размер: 3366 байт
                Дата изменения: 2026-01-19T09:31:29.768131546Z
                Содержимое:
                ----------------------------------------
                package com.parser.config;
                
                /**
                 * Класс с константами для настроек парсера
                 */
                public class ParserSettings {
                    // Минимальные и максимальные значения для валидации
                
                    public static final int MIN_CHECK_INTERVAL = 20; // секунд
                    public static final int MAX_CHECK_INTERVAL = 3600; // секунд
                
                    public static final int MIN_MAX_AGE_MINUTES = 1;
                    public static final int MAX_MAX_AGE_MINUTES = 10080; // 7 дней
                
                    public static final int MIN_MAX_PAGES = 1;
                    public static final int MAX_MAX_PAGES = 50;
                
                    public static final int MIN_ROWS_PER_PAGE = 10;
                    public static final int MAX_ROWS_PER_PAGE = 1000;
                
                    // Коды валют
                    public static final String CURRENCY_YUAN = "yuan";
                    public static final String CURRENCY_RUBLES = "rubles";
                
                    // Поддерживаемые сайты
                    public static final String SITE_GOOFISH = "goofish";
                    public static final String SITE_TAOBAO = "taobao";
                    public static final String SITE_JD = "jd";
                
                    // Статусы парсера
                    public static final String STATUS_RUNNING = "running";
                    public static final String STATUS_STOPPED = "stopped";
                    public static final String STATUS_PAUSED = "paused";
                    public static final String STATUS_ERROR = "error";
                
                    // Типы уведомлений
                    public static final String NOTIFY_TELEGRAM = "telegram";
                    public static final String NOTIFY_EMAIL = "email";
                    public static final String NOTIFY_WEBHOOK = "webhook";
                
                    /**
                     * Валидация интервала проверки
                     */
                    public static boolean isValidCheckInterval(int interval) {
                        return interval >= MIN_CHECK_INTERVAL && interval <= MAX_CHECK_INTERVAL;
                    }
                
                    /**
                     * Валидация максимального возраста товара
                     */
                    public static boolean isValidMaxAge(int maxAge) {
                        return maxAge >= MIN_MAX_AGE_MINUTES && maxAge <= MAX_MAX_AGE_MINUTES;
                    }
                
                    /**
                     * Нормализация интервала проверки
                     */
                    public static int normalizeCheckInterval(int interval) {
                        return Math.max(MIN_CHECK_INTERVAL, Math.min(interval, MAX_CHECK_INTERVAL));
                    }
                
                    /**
                     * Нормализация максимального возраста
                     */
                    public static int normalizeMaxAge(int maxAge) {
                        return Math.max(MIN_MAX_AGE_MINUTES, Math.min(maxAge, MAX_MAX_AGE_MINUTES));
                    }
                
                    /**
                     * Проверка поддержки сайта
                     */
                    public static boolean isSiteSupported(String site) {
                        return SITE_GOOFISH.equalsIgnoreCase(site) ||
                                SITE_TAOBAO.equalsIgnoreCase(site) ||
                                SITE_JD.equalsIgnoreCase(site);
                    }
                
                    /**
                     * Получение курса валюты (обновленный актуальный курс)
                     */
                    public static double getCurrencyRate(String fromCurrency, String toCurrency) {
                        if (CURRENCY_YUAN.equals(fromCurrency) && CURRENCY_RUBLES.equals(toCurrency)) {
                            return 14.0; // Обновленный курс юаня к рублю (январь 2026)
                        } else if (CURRENCY_RUBLES.equals(fromCurrency) && CURRENCY_YUAN.equals(toCurrency)) {
                            return 1.0 / 14.0; // Обратный курс
                        }
                        return 1.0;
                    }
                }
                ----------------------------------------

              [FILE] Config.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/config/Config.java
                Размер: 7139 байт
                Дата изменения: 2026-01-19T22:14:48.902386849Z
                Содержимое:
                ----------------------------------------
                package com.parser.config;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.*;
                import java.util.Properties;
                
                /**
                 * Класс для управления конфигурацией приложения
                 */
                public class Config {
                    private static final Logger logger = LoggerFactory.getLogger(Config.class);
                    private static final Properties properties = new Properties();
                    private static final String CONFIG_FILE = "config.properties";
                    private static volatile boolean isLoaded = false;
                
                    static {
                        synchronized (Config.class) {
                            if (!isLoaded) {
                                loadProperties();
                                isLoaded = true;
                            }
                        }
                    }
                
                    private static void loadProperties() {
                        File externalConfig = new File(CONFIG_FILE);
                        if (externalConfig.exists()) {
                            try (InputStream input = new FileInputStream(externalConfig)) {
                                properties.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded configuration from: {}", CONFIG_FILE);
                                return;
                            } catch (IOException e) {
                                logger.warn("Failed to load external config: {}", e.getMessage());
                            }
                        }
                
                        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(CONFIG_FILE)) {
                            if (input != null) {
                                properties.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded configuration from resources");
                            } else {
                                setDefaults();
                                logger.warn("Config file not found, using defaults");
                            }
                        } catch (IOException e) {
                            setDefaults();
                            logger.error("Error loading config: {}", e.getMessage());
                        }
                    }
                
                    private static void setDefaults() {
                        properties.setProperty("telegram.bot.token", "");
                        properties.setProperty("telegram.bot.username", "");
                        properties.setProperty("telegram.admin.id", "0");
                        properties.setProperty("parser.default.check_interval", "300");
                        properties.setProperty("parser.default.max_age_minutes", "1440");
                        properties.setProperty("parser.default.max_pages", "3");
                        properties.setProperty("parser.default.rows_per_page", "100");
                        properties.setProperty("thread.pool.core.size", "3");
                        properties.setProperty("thread.pool.max.size", "10");
                        properties.setProperty("thread.pool.keepalive.seconds", "60");
                        properties.setProperty("storage.data.dir", "./data");
                        properties.setProperty("storage.backup.enabled", "true");
                        properties.setProperty("http.connect.timeout", "10000");
                        properties.setProperty("http.read.timeout", "15000");
                        properties.setProperty("http.user.agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36");
                        properties.setProperty("cookie.auto.update", "true");
                        properties.setProperty("cookie.update.interval.minutes", "120");
                        properties.setProperty("cookie.dynamic.enabled", "true");
                        properties.setProperty("cookie.cache.ttl.minutes", "30");
                        properties.setProperty("logging.level", "INFO");
                        properties.setProperty("api.goofish.delay.between.requests", "2000");
                    }
                
                    public static int getInt(String key, int defaultValue) {
                        try {
                            return Integer.parseInt(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid integer for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    public static long getLong(String key, long defaultValue) {
                        try {
                            return Long.parseLong(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid long for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    public static String getString(String key, String defaultValue) {
                        String value = properties.getProperty(key, defaultValue);
                        return value != null ? value.trim() : defaultValue;
                    }
                
                    public static boolean getBoolean(String key, boolean defaultValue) {
                        String value = properties.getProperty(key, String.valueOf(defaultValue));
                        return value != null && (value.trim().toLowerCase().matches("true|yes|1"));
                    }
                
                    public static double getDouble(String key, double defaultValue) {
                        try {
                            return Double.parseDouble(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid double for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    public static void setProperty(String key, String value) {
                        properties.setProperty(key, value);
                    }
                
                    public static void saveConfig() {
                        try (OutputStream output = new FileOutputStream(CONFIG_FILE)) {
                            properties.store(output, "Product Parser Configuration");
                            logger.info("Configuration saved");
                        } catch (IOException e) {
                            logger.error("Failed to save configuration: {}", e.getMessage());
                        }
                    }
                
                    public static void reload() {
                        synchronized (Config.class) {
                            properties.clear();
                            loadProperties();
                            logger.info("Configuration reloaded");
                        }
                    }
                
                    // Convenience methods
                    public static String getTelegramBotToken() {
                        return getString("telegram.bot.token", "");
                    }
                
                    public static String getTelegramBotUsername() {
                        return getString("telegram.bot.username", "");
                    }
                
                    public static long getTelegramAdminId() {
                        return getLong("telegram.admin.id", 0);
                    }
                
                    public static int getThreadPoolCoreSize() {
                        return getInt("thread.pool.core.size", 3);
                    }
                
                    public static int getThreadPoolMaxSize() {
                        return getInt("thread.pool.max.size", 10);
                    }
                
                    public static int getHttpConnectTimeout() {
                        return getInt("http.connect.timeout", 10000);
                    }
                
                    public static int getHttpReadTimeout() {
                        return getInt("http.read.timeout", 15000);
                    }
                
                    public static String getHttpUserAgent() {
                        return getString("http.user.agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36");
                    }
                
                    public static boolean isDynamicCookiesEnabled() {
                        return getBoolean("cookie.dynamic.enabled", true);
                    }
                
                    public static boolean getCookieAutoUpdate() {
                        return getBoolean("cookie.auto.update", true);
                    }
                
                    public static int getCookieUpdateInterval() {
                        return getInt("cookie.update.interval.minutes", 120);
                    }
                
                    public static String getStorageDataDir() {
                        return getString("storage.data.dir", "./data");
                    }
                
                    public static int getDefaultCheckInterval() {
                        return getInt("parser.default.check_interval", 300);
                    }
                
                    public static int getDefaultMaxAgeMinutes() {
                        return getInt("parser.default.max_age_minutes", 1440);
                    }
                }
                ----------------------------------------

              [FILE] CookieConfig.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/config/CookieConfig.java
                Размер: 10300 байт
                Дата изменения: 2026-01-19T09:31:29.76763413Z
                Содержимое:
                ----------------------------------------
                package com.parser.config;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.*;
                import java.util.Properties;
                
                /**
                 * Класс для управления куки файлами
                 */
                public class CookieConfig {
                    private static final Logger logger = LoggerFactory.getLogger(CookieConfig.class);
                    private static final Properties cookies = new Properties();
                    private static final String COOKIE_FILE = "cookies.properties";
                    private static volatile boolean isLoaded = false;
                
                    static {
                        synchronized (CookieConfig.class) {
                            if (!isLoaded) {
                                loadCookies();
                                isLoaded = true;
                            }
                        }
                    }
                
                    /**
                     * Загрузка куки из файла
                     */
                    private static void loadCookies() {
                        // Попытка 1: Загрузка из файла в текущей директории
                        File externalFile = new File(COOKIE_FILE);
                        if (externalFile.exists() && externalFile.isFile()) {
                            try (InputStream input = new FileInputStream(externalFile)) {
                                cookies.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded cookies from external file: {}", COOKIE_FILE);
                                return;
                            } catch (IOException e) {
                                logger.warn("Failed to load external cookie file: {}", e.getMessage());
                            }
                        }
                
                        // Попытка 2: Загрузка из ресурсов
                        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(COOKIE_FILE)) {
                            if (input != null) {
                                cookies.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded cookies from resources: {}", COOKIE_FILE);
                            } else {
                                logger.warn("Cookie file not found");
                            }
                        } catch (IOException e) {
                            logger.error("Error loading cookies from resources: {}", e.getMessage(), e);
                        }
                    }
                
                    /**
                     * Получение куки для домена
                     */
                    public static String getCookiesForDomain(String domain) {
                        if (domain == null || domain.trim().isEmpty()) {
                            return "";
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        String cookiesStr = cookies.getProperty(key, "");
                        return cookiesStr != null ? cookiesStr.trim() : "";
                    }
                
                    /**
                     * Установка куки для домена
                     */
                    public static void setCookiesForDomain(String domain, String cookieString) {
                        if (domain == null || domain.trim().isEmpty()) {
                            return;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        cookies.setProperty(key, cookieString != null ? cookieString.trim() : "");
                        saveCookies();
                        logger.info("Cookies updated for domain: {}", domain);
                    }
                
                    /**
                     * Получение конкретного куки по имени для домена
                     */
                    public static String getCookie(String domain, String cookieName) {
                        if (domain == null || domain.trim().isEmpty() || cookieName == null || cookieName.trim().isEmpty()) {
                            return "";
                        }
                
                        String allCookies = getCookiesForDomain(domain);
                        if (allCookies == null || allCookies.isEmpty()) {
                            return "";
                        }
                
                        String[] cookiePairs = allCookies.split("; ");
                        for (String pair : cookiePairs) {
                            String[] parts = pair.split("=", 2);
                            if (parts.length == 2 && parts[0].trim().equals(cookieName.trim())) {
                                return parts[1].trim();
                            }
                        }
                
                        return "";
                    }
                
                    /**
                     * Установка конкретного куки
                     */
                    public static void setCookie(String domain, String cookieName, String cookieValue) {
                        if (domain == null || domain.trim().isEmpty() || cookieName == null || cookieName.trim().isEmpty()) {
                            return;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        String currentCookies = cookies.getProperty(key, "");
                
                        // Создаем новую строку куки
                        StringBuilder newCookies = new StringBuilder();
                        boolean replaced = false;
                
                        if (currentCookies != null && !currentCookies.trim().isEmpty()) {
                            String[] cookiePairs = currentCookies.split("; ");
                            for (String pair : cookiePairs) {
                                String[] parts = pair.split("=", 2);
                                if (parts.length == 2) {
                                    if (parts[0].trim().equals(cookieName.trim())) {
                                        // Заменяем существующий куки
                                        newCookies.append(cookieName.trim()).append("=").append(cookieValue != null ? cookieValue.trim() : "").append("; ");
                                        replaced = true;
                                    } else {
                                        newCookies.append(pair).append("; ");
                                    }
                                }
                            }
                        }
                
                        // Если куки не было, добавляем новый
                        if (!replaced) {
                            newCookies.append(cookieName.trim()).append("=").append(cookieValue != null ? cookieValue.trim() : "").append("; ");
                        }
                
                        // Убираем последнюю точку с запятой
                        String result = newCookies.toString();
                        if (result.endsWith("; ")) {
                            result = result.substring(0, result.length() - 2);
                        }
                
                        cookies.setProperty(key, result);
                        saveCookies();
                        logger.debug("Cookie {} set for domain {}", cookieName, domain);
                    }
                
                    /**
                     * Удаление куки
                     */
                    public static void removeCookie(String domain, String cookieName) {
                        if (domain == null || domain.trim().isEmpty() || cookieName == null || cookieName.trim().isEmpty()) {
                            return;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        String currentCookies = cookies.getProperty(key, "");
                
                        if (currentCookies == null || currentCookies.trim().isEmpty()) {
                            return;
                        }
                
                        StringBuilder newCookies = new StringBuilder();
                        String[] cookiePairs = currentCookies.split("; ");
                
                        for (String pair : cookiePairs) {
                            String[] parts = pair.split("=", 2);
                            if (parts.length == 2 && !parts[0].trim().equals(cookieName.trim())) {
                                if (newCookies.length() > 0) {
                                    newCookies.append("; ");
                                }
                                newCookies.append(pair);
                            }
                        }
                
                        cookies.setProperty(key, newCookies.toString());
                        saveCookies();
                        logger.debug("Cookie {} removed from domain {}", cookieName, domain);
                    }
                
                    /**
                     * Очистка всех куки для домена
                     */
                    public static void clearCookiesForDomain(String domain) {
                        if (domain == null || domain.trim().isEmpty()) {
                            return;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        cookies.remove(key);
                        saveCookies();
                        logger.info("All cookies cleared for domain: {}", domain);
                    }
                
                    /**
                     * Сохранение куки в файл
                     */
                    public static void saveCookies() {
                        File externalFile = new File(COOKIE_FILE);
                        try (OutputStream output = new FileOutputStream(externalFile)) {
                            cookies.store(output, "Cookies for HTTP requests\nAuto-generated file");
                            logger.debug("Cookies saved to: {}", COOKIE_FILE);
                        } catch (IOException e) {
                            logger.error("Failed to save cookies: {}", e.getMessage(), e);
                        }
                    }
                
                    /**
                     * Получение списка всех доменов с куки
                     */
                    public static String[] getCookieDomains() {
                        return cookies.stringPropertyNames().stream()
                                .filter(key -> key != null && key.endsWith(".cookies"))
                                .map(key -> key.substring(0, key.length() - 8))
                                .toArray(String[]::new);
                    }
                
                    /**
                     * Проверка наличия куки для домена
                     */
                    public static boolean hasCookiesForDomain(String domain) {
                        if (domain == null || domain.trim().isEmpty()) {
                            return false;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        String cookieString = cookies.getProperty(key, "");
                        return cookieString != null && !cookieString.trim().isEmpty();
                    }
                
                    /**
                     * Получение всех куки в виде строки для конкретного домена
                     */
                    public static String getAllCookiesAsString(String domain) {
                        return getCookiesForDomain(domain);
                    }
                
                    /**
                     * Парсинг строки куки из заголовка Set-Cookie
                     */
                    public static void parseSetCookieHeader(String domain, String setCookieHeader) {
                        if (domain == null || domain.trim().isEmpty() || setCookieHeader == null || setCookieHeader.trim().isEmpty()) {
                            return;
                        }
                
                        String[] cookiesArray = setCookieHeader.split(";\\s*");
                        for (String cookie : cookiesArray) {
                            String[] parts = cookie.split("=", 2);
                            if (parts.length == 2) {
                                String name = parts[0].trim();
                                String value = parts[1].trim();
                
                                // Пропускаем атрибуты
                                if (name.equalsIgnoreCase("path") ||
                                        name.equalsIgnoreCase("domain") ||
                                        name.equalsIgnoreCase("expires") ||
                                        name.equalsIgnoreCase("max-age") ||
                                        name.equalsIgnoreCase("secure") ||
                                        name.equalsIgnoreCase("httponly") ||
                                        name.equalsIgnoreCase("samesite")) {
                                    continue;
                                }
                
                                setCookie(domain, name, value);
                            }
                        }
                
                        logger.debug("Parsed Set-Cookie header for domain: {}", domain);
                    }
                
                    /**
                     * Релоад куки из файла
                     */
                    public static void reload() {
                        synchronized (CookieConfig.class) {
                            cookies.clear();
                            loadCookies();
                            logger.info("Cookies reloaded");
                        }
                    }
                }
                ----------------------------------------
            [DIR] parser

              [FILE] GoofishParser.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/GoofishParser.java
                Размер: 29321 байт
                Дата изменения: 2026-01-20T09:17:00.259517471Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import com.parser.config.Config;
                import com.parser.model.Product;
                import com.parser.service.CookieService;
                import com.parser.util.HttpUtils;
                import org.apache.http.client.methods.HttpPost;
                import org.apache.http.entity.StringEntity;
                import org.apache.http.util.EntityUtils;
                import org.json.JSONArray;
                import org.json.JSONObject;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.io.ByteArrayInputStream;
                import java.io.ByteArrayOutputStream;
                import java.nio.charset.StandardCharsets;
                import java.security.MessageDigest;
                import java.util.*;
                
                /**
                 * Исправленный парсер для Goofish с правильным POST запросом и обработкой zstd
                 */
                public class GoofishParser extends BaseParser {
                    private static final Logger logger = LoggerFactory.getLogger(GoofishParser.class);
                    private static final String SEARCH_ENDPOINT = "/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/";
                    private static final String APP_KEY = "34839810";
                
                    private static final Random random = new Random();
                    private static long lastRequestTime = 0;
                
                    public GoofishParser() {
                        super("goofish", "https://h5api.m.goofish.com");
                    }
                
                    @Override
                    protected String buildSearchUrl(String query, int page, int rows) {
                        // Для POST запроса URL формируется без параметра data
                        return buildApiUrl(query, page, rows);
                    }
                
                    /**
                     * Формирование URL API
                     */
                    private String buildApiUrl(String query, int page, int rows) {
                        try {
                            long timestamp = System.currentTimeMillis();
                            String token = getTokenFromCookies();
                
                            if (token.isEmpty()) {
                                logger.error("❌ Token is empty! Check cookies");
                                return "";
                            }
                
                            // Формируем data параметр для подписи
                            String dataStr = buildSearchData(query, page, rows);
                            String sign = generateSignature(token, timestamp, dataStr);
                
                            // Строим URL с параметрами как в реальном запросе
                            Map<String, String> params = new LinkedHashMap<>();
                            params.put("jsv", "2.7.2");
                            params.put("appKey", APP_KEY);
                            params.put("t", String.valueOf(timestamp));
                            params.put("sign", sign);
                            params.put("v", "1.0");
                            params.put("type", "originaljson");
                            params.put("accountSite", "xianyu");
                            params.put("dataType", "json");
                            params.put("timeout", "20000");
                            params.put("api", "mtop.taobao.idlemtopsearch.pc.search");
                            params.put("sessionOption", "AutoLoginOnly");
                            params.put("spm_cnt", "a21ybx.search.0.0");
                            params.put("spm_pre", "a21ybx.search.searchInput.0");
                
                            return HttpUtils.buildUrlWithParams(baseUrl + SEARCH_ENDPOINT, params);
                
                        } catch (Exception e) {
                            logger.error("Error building URL: {}", e.getMessage());
                            return "";
                        }
                    }
                
                    /**
                     * Формирование данных для поиска
                     */
                    private String buildSearchData(String query, int page, int rows) {
                        JSONObject data = new JSONObject();
                        data.put("pageNumber", page);
                        data.put("keyword", query);
                        data.put("fromFilter", false);
                        data.put("rowsPerPage", rows);
                        data.put("sortValue", "");
                        data.put("sortField", "");
                        data.put("customDistance", "");
                        data.put("gps", "");
                        data.put("propValueStr", new JSONObject());
                        data.put("customGps", "");
                        data.put("searchReqFromPage", "pcSearch");
                        data.put("extraFilterValue", "{}");
                        data.put("userPositionJson", "{}");
                
                        return data.toString();
                    }
                
                    /**
                     * Переопределяем выполнение запроса для использования POST и обработки zstd
                     */
                    @Override
                    protected String executeSearchRequest(String url, String query, int page, int rows) throws Exception {
                        // Формируем тело запроса
                        String dataStr = buildSearchData(query, page, rows);
                        String formData = "data=" + java.net.URLEncoder.encode(dataStr, "UTF-8");
                
                        logger.info("📤 POST запрос к: {}", url);
                        logger.debug("📝 Тело запроса: {}", formData);
                
                        // Создаем POST запрос
                        HttpPost request = new HttpPost(url);
                
                        // Устанавливаем заголовки как в реальном запросе
                        request.setHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 YaBrowser/25.10.0.0 Safari/537.36");
                        request.setHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
                        request.setHeader("Accept", "application/json");
                        request.setHeader("Accept-Encoding", "gzip, deflate, br, zstd");
                        request.setHeader("Accept-Language", "ru,en;q=0.9");
                        request.setHeader("Origin", "https://www.goofish.com");
                        request.setHeader("Referer", "https://www.goofish.com/");
                        request.setHeader("Sec-Fetch-Dest", "empty");
                        request.setHeader("Sec-Fetch-Mode", "cors");
                        request.setHeader("Sec-Fetch-Site", "same-site");
                        request.setHeader("sec-ch-ua", "\"Chromium\";v=\"140\", \"Not=A?Brand\";v=\"24\", \"YaBrowser\";v=\"25.10\", \"Yowser\";v=\"2.5\", \"YaBrowserCorp\";v=\"140\"");
                        request.setHeader("sec-ch-ua-mobile", "?0");
                        request.setHeader("sec-ch-ua-platform", "\"macOS\"");
                        request.setHeader("x-accept-terminal", "pc");
                
                        // Добавляем куки
                        String domain = "h5api.m.goofish.com";
                        String cookieHeader = CookieService.getCookieHeader(domain);
                        if (cookieHeader != null && !cookieHeader.isEmpty()) {
                            request.setHeader("Cookie", cookieHeader);
                            logger.debug("✅ Добавлены куки: {} символов", cookieHeader.length());
                        } else {
                            logger.warn("⚠️ Куки пустые!");
                        }
                
                        // Устанавливаем тело запроса
                        request.setEntity(new StringEntity(formData, StandardCharsets.UTF_8));
                
                        // Выполняем запрос
                        try (var response = HttpUtils.getHttpClientInstance().execute(request)) {
                            int statusCode = response.getStatusLine().getStatusCode();
                            String contentType = response.getFirstHeader("Content-Type") != null ?
                                    response.getFirstHeader("Content-Type").getValue() : "unknown";
                            String contentEncoding = response.getFirstHeader("Content-Encoding") != null ?
                                    response.getFirstHeader("Content-Encoding").getValue() : "unknown";
                
                            logger.info("📥 Ответ: статус={}, content-type={}, content-encoding={}",
                                    statusCode, contentType, contentEncoding);
                
                            // Получаем сырые байты ответа
                            byte[] responseBytes = EntityUtils.toByteArray(response.getEntity());
                            String responseBody;
                
                            // Обрабатываем сжатие
                            if ("zstd".equalsIgnoreCase(contentEncoding)) {
                                logger.info("🔄 Распаковываем zstd сжатие...");
                                responseBody = decompressZstd(responseBytes);
                            } else if ("gzip".equalsIgnoreCase(contentEncoding) || "deflate".equalsIgnoreCase(contentEncoding)) {
                                // HttpClient обычно автоматически обрабатывает gzip/deflate
                                responseBody = new String(responseBytes, StandardCharsets.UTF_8);
                            } else {
                                // Без сжатия
                                responseBody = new String(responseBytes, StandardCharsets.UTF_8);
                            }
                
                            // Логируем заголовки для отладки
                            org.apache.http.Header[] headers = response.getAllHeaders();
                            logger.debug("📋 Заголовки ответа:");
                            for (org.apache.http.Header header : headers) {
                                if (header.getName().equalsIgnoreCase("Set-Cookie") ||
                                        header.getName().equalsIgnoreCase("Content-Type") ||
                                        header.getName().equalsIgnoreCase("Content-Encoding") ||
                                        header.getName().equalsIgnoreCase("X-EagleEye-Id")) {
                                    logger.debug("   {}: {}", header.getName(), header.getValue());
                                }
                            }
                
                            logger.debug("📄 Тело ответа (первые 500 символов): {}",
                                    responseBody.length() > 500 ? responseBody.substring(0, 500) + "..." : responseBody);
                
                            if (statusCode == 200) {
                                // Проверяем, это JSON или что-то другое
                                if (responseBody.trim().startsWith("{") || responseBody.trim().startsWith("[")) {
                                    logger.info("✅ Получен JSON ответ, длина: {} символов", responseBody.length());
                                    return responseBody;
                                } else {
                                    logger.error("❌ Ответ не JSON. Первые 200 символов: {}",
                                            responseBody.length() > 200 ? responseBody.substring(0, 200) : responseBody);
                
                                    // Проверяем, не получили ли мы HTML страницу с ошибкой
                                    if (responseBody.contains("<html") || responseBody.contains("<!DOCTYPE")) {
                                        logger.error("⚠️ Получена HTML страница вместо JSON. Возможно, куки недействительны.");
                                    } else if (responseBody.contains("被挤爆啦") || responseBody.contains("FAIL_SYS_ILLEGAL_ACCESS")) {
                                        logger.error("⚠️ API вернуло ошибку: {}",
                                                responseBody.length() > 100 ? responseBody.substring(0, 100) : responseBody);
                                    }
                                    throw new Exception("Ответ не в формате JSON: " + contentType);
                                }
                            } else {
                                logger.error("❌ HTTP ошибка {}: {}", statusCode,
                                        responseBody.length() > 200 ? responseBody.substring(0, 200) + "..." : responseBody);
                                throw new Exception("HTTP error: " + statusCode);
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка выполнения запроса: {}", e.getMessage());
                            throw e;
                        }
                    }
                
                    /**
                     * Распаковка zstd сжатых данных
                     */
                    private String decompressZstd(byte[] compressedData) {
                        try {
                            logger.debug("📦 Размер сжатых данных: {} байт", compressedData.length);
                
                            // Используем zstd-jni для распаковки
                            byte[] decompressed = com.github.luben.zstd.Zstd.decompress(compressedData, 10 * 1024 * 1024); // Макс 10MB
                
                            String result = new String(decompressed, StandardCharsets.UTF_8);
                            logger.debug("✅ Zstd успешно распакован");
                            logger.debug("📄 Размер распакованных данных: {} символов", result.length());
                            return result;
                
                        } catch (Exception e) {
                            logger.error("❌ Ошибка распаковки zstd: {}", e.getMessage());
                
                            // Пробуем прочитать как обычную строку
                            try {
                                String fallback = new String(compressedData, StandardCharsets.UTF_8);
                                logger.warn("⚠️ Используем fallback чтение как UTF-8");
                                return fallback;
                            } catch (Exception e2) {
                                return "Ошибка при обработке ответа: " + e.getMessage();
                            }
                        }
                    }
                
                    // Остальные методы остаются без изменений
                    @Override
                    protected List<Product> parseResponse(String response, String query) {
                        List<Product> products = new ArrayList<>();
                
                        if (response == null || response.isEmpty()) {
                            logger.warn("Empty response");
                            return products;
                        }
                
                        try {
                            JSONObject json = new JSONObject(response);
                
                            // Проверка наличия ошибок
                            if (json.has("ret")) {
                                String ret = json.optString("ret", "");
                                if (ret.contains("被挤爆啦") || ret.contains("RGV587_ERROR") ||
                                        ret.contains("FAIL_SYS_ILLEGAL_ACCESS")) {
                                    logger.error("API error: {}", ret);
                                    return products;
                                }
                            }
                
                            // Получаем данные
                            JSONObject data = json.optJSONObject("data");
                            if (data == null) {
                                logger.warn("No data in response");
                                return products;
                            }
                
                            // Извлекаем список товаров
                            JSONArray resultList = data.optJSONArray("resultList");
                            if (resultList == null || resultList.length() == 0) {
                                logger.debug("No items found in response");
                                return products;
                            }
                
                            logger.info("Found {} items", resultList.length());
                
                            for (int i = 0; i < resultList.length(); i++) {
                                try {
                                    JSONObject item = resultList.getJSONObject(i);
                                    Product product = parseProductItem(item, query);
                                    if (product != null && isValidProduct(product)) {
                                        products.add(product);
                                    }
                                } catch (Exception e) {
                                    logger.debug("Error parsing item {}: {}", i, e.getMessage());
                                }
                            }
                
                            logger.info("Successfully parsed {} products", products.size());
                
                        } catch (Exception e) {
                            logger.error("Error parsing response: {}", e.getMessage());
                            logger.debug("Response content (first 500 chars): {}",
                                    response.length() > 500 ? response.substring(0, 500) + "..." : response);
                        }
                
                        return products;
                    }
                
                    private Product parseProductItem(JSONObject item, String query) {
                        try {
                            JSONObject data = item.optJSONObject("data");
                            if (data == null) return null;
                
                            JSONObject itemObj = data.optJSONObject("item");
                            if (itemObj == null) return null;
                
                            JSONObject mainObj = itemObj.optJSONObject("main");
                            if (mainObj == null) return null;
                
                            JSONObject itemData = data.optJSONObject("itemData");
                            JSONObject exContent = mainObj.optJSONObject("exContent");
                
                            // Извлечение ID товара
                            String itemId = null;
                            if (itemData != null) itemId = itemData.optString("itemId", "");
                            if ((itemId == null || itemId.isEmpty()) && exContent != null) {
                                itemId = exContent.optString("itemId", "");
                            }
                
                            if (itemId == null || itemId.isEmpty()) return null;
                
                            Product product = new Product();
                            product.setId(itemId);
                            product.setSite("goofish");
                            product.setQuery(query);
                
                            // Название
                            String title = itemData != null ? itemData.optString("title", "") : "";
                            product.setTitle(title.isEmpty() ? "No title" : title);
                
                            // Цена
                            double price = extractPrice(itemData, exContent);
                            product.setPrice(price);
                
                            // Возраст товара
                            long publishTime = extractPublishTime(mainObj, itemData, exContent);
                            int ageMinutes = calculateAge(publishTime);
                            product.setAgeMinutes(ageMinutes);
                
                            // Локация
                            String location = itemData != null ? itemData.optString("area", "") : "";
                            product.setLocation(location.isEmpty() ? "Unknown" : location);
                
                            // URL
                            product.setUrl("https://www.goofish.com/item?id=" + itemId);
                
                            // Изображения
                            List<String> images = extractImages(mainObj, itemObj, data);
                            product.setImages(images);
                
                            logger.debug("Parsed: {} ({}¥, {}min, {} images)",
                                    product.getShortTitle(), price, ageMinutes, images.size());
                
                            return product;
                
                        } catch (Exception e) {
                            logger.error("Error parsing product item: {}", e.getMessage());
                            return null;
                        }
                    }
                
                    private double extractPrice(JSONObject itemData, JSONObject exContent) {
                        if (itemData != null) {
                            Object priceObj = itemData.opt("price");
                            if (priceObj != null) return parsePrice(priceObj);
                        }
                        if (exContent != null) {
                            Object priceObj = exContent.opt("price");
                            if (priceObj != null) return parsePrice(priceObj);
                        }
                        return 0.0;
                    }
                
                    private double parsePrice(Object priceObj) {
                        if (priceObj instanceof String) {
                            return extractPrice((String) priceObj);
                        }
                        if (priceObj instanceof Number) {
                            return ((Number) priceObj).doubleValue();
                        }
                        if (priceObj instanceof JSONArray) {
                            JSONArray arr = (JSONArray) priceObj;
                            StringBuilder sb = new StringBuilder();
                            for (int i = 0; i < arr.length(); i++) {
                                JSONObject part = arr.optJSONObject(i);
                                if (part != null && "integer".equals(part.optString("type"))) {
                                    sb.append(part.optString("text"));
                                }
                            }
                            return extractPrice(sb.toString());
                        }
                        return 0.0;
                    }
                
                    public double extractPrice(String priceStr) {
                        if (priceStr == null || priceStr.isEmpty()) return 0.0;
                        try {
                            String clean = priceStr.replaceAll("[^\\d.,]", "").replace(',', '.');
                            return Double.parseDouble(clean);
                        } catch (NumberFormatException e) {
                            return 0.0;
                        }
                    }
                
                    private long extractPublishTime(JSONObject main, JSONObject itemData, JSONObject exContent) {
                        // Путь 1: args.publishTime
                        if (main != null) {
                            JSONObject clickParam = main.optJSONObject("clickParam");
                            if (clickParam != null) {
                                JSONObject args = clickParam.optJSONObject("args");
                                if (args != null && args.has("publishTime")) {
                                    Object time = args.opt("publishTime");
                                    if (time instanceof String) return Long.parseLong((String) time);
                                    if (time instanceof Number) return ((Number) time).longValue();
                                }
                            }
                        }
                
                        // Путь 2: itemData.publishTime
                        if (itemData != null && itemData.has("publishTime")) {
                            Object time = itemData.opt("publishTime");
                            if (time instanceof String) return Long.parseLong((String) time);
                            if (time instanceof Number) return ((Number) time).longValue();
                        }
                
                        return 0;
                    }
                
                    private int calculateAge(long publishTime) {
                        if (publishTime <= 0) return 0;
                
                        // Определяем формат времени (секунды или миллисекунды)
                        if (publishTime < 10000000000L) {
                            publishTime = publishTime * 1000;
                        }
                
                        long ageMs = System.currentTimeMillis() - publishTime;
                        int ageMinutes = (int) (ageMs / (1000 * 60));
                
                        return Math.max(1, Math.min(ageMinutes, 10080)); // 1 до 7 дней
                    }
                
                    private List<String> extractImages(JSONObject main, JSONObject itemObj, JSONObject data) {
                        List<String> images = new ArrayList<>();
                
                        // Путь 1: data.picUrl (главное фото)
                        if (data != null && data.has("picUrl")) {
                            String picUrl = data.optString("picUrl", "");
                            if (isValidImageUrl(picUrl)) {
                                images.add(picUrl);
                                logger.debug("✅ Найдено фото в data.picUrl");
                            }
                        }
                
                        // Путь 2: data.pics (массив фото)
                        if (data != null && data.has("pics")) {
                            JSONArray pics = data.optJSONArray("pics");
                            if (pics != null) {
                                for (int i = 0; i < Math.min(5, pics.length()); i++) {
                                    try {
                                        JSONObject pic = pics.optJSONObject(i);
                                        if (pic != null) {
                                            // Пробуем разные поля
                                            String url = pic.optString("picUrl", "");
                                            if (url.isEmpty()) {
                                                url = pic.optString("pic_url", "");
                                            }
                                            if (url.isEmpty()) {
                                                url = pic.optString("url", "");
                                            }
                
                                            if (isValidImageUrl(url) && !images.contains(url)) {
                                                images.add(url);
                                                logger.debug("✅ Найдено фото в data.pics[{}]", i);
                                            }
                                        }
                                    } catch (Exception e) {
                                        logger.debug("Error parsing pic at index {}: {}", i, e.getMessage());
                                    }
                                }
                            }
                        }
                
                        // Путь 3: itemObj.extra.picUrl (дополнительное фото)
                        if (itemObj != null) {
                            JSONObject extra = itemObj.optJSONObject("extra");
                            if (extra != null) {
                                String picUrl = extra.optString("picUrl", "");
                                if (picUrl.isEmpty()) {
                                    picUrl = extra.optString("pic_url", "");
                                }
                                if (isValidImageUrl(picUrl) && !images.contains(picUrl)) {
                                    images.add(picUrl);
                                    logger.debug("✅ Найдено фото в itemObj.extra.picUrl");
                                }
                            }
                        }
                
                        // Путь 4: main.exContent.picUrl (исходное фото)
                        if (main != null) {
                            JSONObject exContent = main.optJSONObject("exContent");
                            if (exContent != null) {
                                String picUrl = exContent.optString("picUrl", "");
                                if (picUrl.isEmpty()) {
                                    picUrl = exContent.optString("pic_url", "");
                                }
                                if (isValidImageUrl(picUrl) && !images.contains(picUrl)) {
                                    images.add(picUrl);
                                    logger.debug("✅ Найдено фото в main.exContent.picUrl");
                                }
                            }
                        }
                
                        // Путь 5: Прямые поля объекта (на случай если структура упрощена)
                        if (data != null) {
                            // Проверяем прямые поля в data
                            String directPic = data.optString("image", "");
                            if (directPic.isEmpty()) {
                                directPic = data.optString("img", "");
                            }
                            if (isValidImageUrl(directPic) && !images.contains(directPic)) {
                                images.add(directPic);
                                logger.debug("✅ Найдено фото в data.image");
                            }
                        }
                
                        if (images.isEmpty()) {
                            logger.debug("⚠️ Фотографии не найдены для товара");
                        } else {
                            logger.debug("📷 Найдено фотографий: {}", images.size());
                        }
                
                        return images;
                    }
                
                    private boolean isValidImageUrl(String url) {
                        if (url == null || url.isEmpty()) {
                            return false;
                        }
                
                        // Должно быть HTTPS или HTTP
                        if (!url.startsWith("http://") && !url.startsWith("https://")) {
                            return false;
                        }
                
                        // Проверяем расширение файла
                        String lowerUrl = url.toLowerCase();
                        String[] validExtensions = {".jpg", ".jpeg", ".png", ".gif", ".webp", ".heic"};
                
                        boolean hasValidExtension = false;
                        for (String ext : validExtensions) {
                            if (lowerUrl.contains(ext)) {
                                hasValidExtension = true;
                                break;
                            }
                        }
                
                        // Если нет расширения - может быть OK (CDN с query parameters)
                        if (!hasValidExtension && (lowerUrl.contains("alicdn") || lowerUrl.contains("taobaocdn"))) {
                            return true;
                        }
                
                        return hasValidExtension;
                    }
                
                    private boolean isValidProduct(Product product) {
                        return product.getId() != null && !product.getId().isEmpty() &&
                                product.getTitle() != null && !product.getTitle().isEmpty() &&
                                product.getUrl() != null && !product.getUrl().isEmpty();
                    }
                
                    private String getTokenFromCookies() {
                        try {
                            String cookies = CookieService.getCookieHeader("h5api.m.goofish.com");
                            if (cookies == null || cookies.isEmpty()) return "";
                
                            String[] pairs = cookies.split("; ");
                            for (String pair : pairs) {
                                if (pair.startsWith("_m_h5_tk=")) {
                                    String mh5tk = pair.substring(9);
                                    if (mh5tk.contains("_")) {
                                        return mh5tk.split("_")[0];
                                    }
                                }
                            }
                        } catch (Exception e) {
                            logger.warn("Error getting token: {}", e.getMessage());
                        }
                        return "";
                    }
                
                    private String generateSignature(String token, long timestamp, String data) {
                        try {
                            String signString = token + "&" + timestamp + "&" + APP_KEY + "&" + data;
                            MessageDigest md = MessageDigest.getInstance("MD5");
                            byte[] hash = md.digest(signString.getBytes(StandardCharsets.UTF_8));
                            StringBuilder hex = new StringBuilder();
                            for (byte b : hash) {
                                String h = Integer.toHexString(0xff & b);
                                if (h.length() == 1) hex.append('0');
                                hex.append(h);
                            }
                            return hex.toString();
                        } catch (Exception e) {
                            logger.error("Error generating signature: {}", e.getMessage());
                            return "";
                        }
                    }
                
                    /**
                     * Переопределяем метод search для использования POST запросов
                     */
                    @Override
                    public List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes) {
                        List<Product> allProducts = new ArrayList<>();
                
                        logger.info("Starting search: site={}, query='{}', pages={}, rows={}, maxAge={}min",
                                siteName, query, maxPages, rowsPerPage, maxAgeMinutes);
                
                        for (int page = 1; page <= maxPages; page++) {
                            if (Thread.currentThread().isInterrupted()) break;
                
                            try {
                                // Формируем URL для API
                                String url = buildSearchUrl(query, page, rowsPerPage);
                                if (url.isEmpty()) {
                                    logger.error("Failed to build URL for page {}", page);
                                    break;
                                }
                
                                // Выполняем POST запрос
                                String response = executeSearchRequest(url, query, page, rowsPerPage);
                                totalRequests++;
                
                                // Парсим ответ
                                List<Product> products = parseResponse(response, query);
                
                                if (products.isEmpty()) {
                                    logger.debug("No products on page {}", page);
                                    break;
                                }
                
                                // Фильтруем по возрасту
                                List<Product> filtered = new ArrayList<>();
                                for (Product p : products) {
                                    if (p.getAgeMinutes() <= maxAgeMinutes) {
                                        filtered.add(p);
                                    }
                                }
                
                                allProducts.addAll(filtered);
                                logger.info("Page {}: found {} products ({} after age filter)",
                                        page, products.size(), filtered.size());
                
                                if (filtered.size() < rowsPerPage) break;
                
                                // Задержка между запросами
                                int delay = getRequestDelay();
                                if (delay > 0 && page < maxPages) {
                                    Thread.sleep(delay);
                                }
                
                            } catch (Exception e) {
                                failedRequests++;
                                logger.error("Error on page {}: {}", page, e.getMessage());
                
                                if (shouldStopOnError(e)) break;
                
                                try {
                                    Thread.sleep(3000);
                                } catch (InterruptedException ie) {
                                    Thread.currentThread().interrupt();
                                    break;
                                }
                            }
                        }
                
                        logger.info("Search completed: found {} products in {} requests",
                                allProducts.size(), totalRequests);
                        return allProducts;
                    }
                }
                ----------------------------------------

              [FILE] ParserFactory.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/ParserFactory.java
                Размер: 2244 байт
                Дата изменения: 2026-01-19T22:14:58.626726844Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.HashMap;
                import java.util.Map;
                
                /**
                 * Фабрика для создания парсеров различных сайтов
                 * Упрощена для легкого добавления новых сайтов
                 */
                public class ParserFactory {
                    private static final Logger logger = LoggerFactory.getLogger(ParserFactory.class);
                    private static final Map<String, Class<? extends SiteParser>> parsers = new HashMap<>();
                    private static final Map<String, SiteParser> instances = new HashMap<>();
                
                    static {
                        // Регистрируем доступные парсеры
                        registerParser("goofish", GoofishParser.class);
                        // Здесь легко добавить новые парсеры:
                        // registerParser("taobao", TaobaoParser.class);
                        // registerParser("jd", JdParser.class);
                    }
                
                    public static void registerParser(String siteName, Class<? extends SiteParser> parserClass) {
                        String key = siteName.toLowerCase();
                        parsers.put(key, parserClass);
                        logger.info("Registered parser for: {}", siteName);
                    }
                
                    public static SiteParser createParser(String siteName) {
                        String key = siteName.toLowerCase();
                
                        if (!parsers.containsKey(key)) {
                            throw new IllegalArgumentException("Unsupported site: " + siteName);
                        }
                
                        if (!instances.containsKey(key)) {
                            try {
                                SiteParser parser = parsers.get(key).getDeclaredConstructor().newInstance();
                                instances.put(key, parser);
                                logger.debug("Created parser instance for: {}", siteName);
                            } catch (Exception e) {
                                throw new RuntimeException("Failed to create parser for: " + siteName, e);
                            }
                        }
                
                        return instances.get(key);
                    }
                
                    public static boolean hasParser(String siteName) {
                        return parsers.containsKey(siteName.toLowerCase());
                    }
                
                    public static String[] getSupportedSites() {
                        return parsers.keySet().toArray(new String[0]);
                    }
                
                    public static void clearCache() {
                        instances.clear();
                        logger.info("Parser cache cleared");
                    }
                }
                ----------------------------------------

              [FILE] BaseParser.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/BaseParser.java
                Размер: 5947 байт
                Дата изменения: 2026-01-19T23:44:07.572926724Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import com.parser.config.Config;
                import com.parser.model.Product;
                import com.parser.util.HttpUtils;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.ArrayList;
                import java.util.List;
                
                /**
                 * Абстрактный базовый класс для всех парсеров
                 */
                public abstract class BaseParser implements SiteParser {
                    protected static final Logger logger = LoggerFactory.getLogger(BaseParser.class);
                
                    protected String siteName;
                    protected String baseUrl;
                    protected String userAgent;
                
                    protected int totalRequests = 0;
                    protected int failedRequests = 0;
                    protected long totalParseTime = 0;
                
                    public BaseParser(String siteName, String baseUrl) {
                        this.siteName = siteName;
                        this.baseUrl = baseUrl;
                        this.userAgent = HttpUtils.getDefaultUserAgent();
                    }
                
                    @Override
                    public String getSiteName() {
                        return siteName;
                    }
                
                    protected abstract List<Product> parseResponse(String response, String query);
                    protected abstract String buildSearchUrl(String query, int page, int rows);
                
                    @Override
                    public List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes) {
                        List<Product> allProducts = new ArrayList<>();
                
                        logger.info("Starting search: site={}, query='{}', pages={}, rows={}, maxAge={}min",
                                siteName, query, maxPages, rowsPerPage, maxAgeMinutes);
                
                        for (int page = 1; page <= maxPages; page++) {
                            if (Thread.currentThread().isInterrupted()) break;
                
                            try {
                                String url = buildSearchUrl(query, page, rowsPerPage);
                                long requestStart = System.currentTimeMillis();
                                String response = HttpUtils.sendGetRequest(url, userAgent);
                                totalRequests++;
                
                                long parseStart = System.currentTimeMillis();
                                List<Product> products = parseResponse(response, query);
                                totalParseTime += System.currentTimeMillis() - parseStart;
                
                                if (products.isEmpty()) {
                                    logger.debug("No products on page {}", page);
                                    break;
                                }
                
                                // Фильтруем по возрасту
                                List<Product> filtered = new ArrayList<>();
                                for (Product p : products) {
                                    if (p.getAgeMinutes() <= maxAgeMinutes) {
                                        filtered.add(p);
                                    }
                                }
                
                                allProducts.addAll(filtered);
                                logger.info("Page {}: found {} products ({} after age filter)", page, products.size(), filtered.size());
                
                                if (filtered.size() < rowsPerPage) break;
                
                                int delay = getRequestDelay();
                                if (delay > 0 && page < maxPages) {
                                    Thread.sleep(delay);
                                }
                
                            } catch (Exception e) {
                                failedRequests++;
                                logger.error("Error on page {}: {}", page, e.getMessage());
                
                                if (shouldStopOnError(e)) break;
                
                                try {
                                    Thread.sleep(3000);
                                } catch (InterruptedException ie) {
                                    Thread.currentThread().interrupt();
                                    break;
                                }
                            }
                        }
                
                        logger.info("Search completed: found {} products in {} requests", allProducts.size(), totalRequests);
                        return allProducts;
                    }
                
                    @Override
                    public List<Product> search(String query) {
                        return search(query, 3, 100, 1440);
                    }
                
                    /**
                     * Метод для выполнения запроса (может быть переопределен для POST)
                     */
                    protected String executeSearchRequest(String url, String query, int page, int rows) throws Exception {
                        return HttpUtils.sendGetRequest(url, userAgent);
                    }
                
                    protected int getRequestDelay() {
                        return Config.getInt("api.goofish.delay.between.requests", 2000);
                    }
                
                    protected boolean shouldStopOnError(Exception e) {
                        String msg = e.getMessage();
                        return msg != null && (msg.contains("403") || msg.contains("429") || msg.contains("blocked") ||
                                msg.contains("被挤爆啦") || msg.contains("FAIL_SYS_ILLEGAL_ACCESS"));
                    }
                
                    protected String cleanString(String str) {
                        if (str == null) return "";
                        return str.trim().replaceAll("\\s+", " ").replaceAll("[\\p{C}]", "");
                    }
                
                    protected double extractPrice(String priceStr) {
                        if (priceStr == null || priceStr.isEmpty()) return 0.0;
                        try {
                            String clean = priceStr.replaceAll("[^\\d.,]", "").replace(',', '.');
                            return Double.parseDouble(clean);
                        } catch (NumberFormatException e) {
                            return 0.0;
                        }
                    }
                
                    public ParserStats getStats() {
                        return new ParserStats(siteName, totalRequests, failedRequests,
                                totalRequests > 0 ? (double) (totalRequests - failedRequests) / totalRequests * 100 : 0,
                                totalRequests > 0 ? totalParseTime / totalRequests : 0);
                    }
                
                    public static class ParserStats {
                        public String siteName;
                        public int totalRequests;
                        public int failedRequests;
                        public double successRate;
                        public long avgParseTime;
                
                        public ParserStats(String siteName, int totalRequests, int failedRequests, double successRate, long avgParseTime) {
                            this.siteName = siteName;
                            this.totalRequests = totalRequests;
                            this.failedRequests = failedRequests;
                            this.successRate = successRate;
                            this.avgParseTime = avgParseTime;
                        }
                
                        @Override
                        public String toString() {
                            return String.format("ParserStats{site=%s, req=%d, failed=%d, success=%.1f%%, avgTime=%dms}",
                                    siteName, totalRequests, failedRequests, successRate, avgParseTime);
                        }
                    }
                }
                ----------------------------------------

              [FILE] SiteParser.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/SiteParser.java
                Размер: 1482 байт
                Дата изменения: 2026-01-19T09:31:29.771270378Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import com.parser.model.Product;
                import java.util.List;
                
                /**
                 * Интерфейс для всех парсеров сайтов
                 */
                public interface SiteParser {
                
                    /**
                     * Получение названия сайта
                     */
                    String getSiteName();
                
                    /**
                     * Поиск товаров по запросу
                     *
                     * @param query поисковый запрос
                     * @param maxPages максимальное количество страниц для парсинга
                     * @param rowsPerPage количество товаров на странице
                     * @param maxAgeMinutes максимальный возраст товаров в минутах
                     * @return список найденных товаров
                     */
                    List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes);
                
                    /**
                     * Поиск товаров с использованием настроек по умолчанию
                     */
                    default List<Product> search(String query) {
                        return search(query, 3, 100, 1440);
                    }
                
                    /**
                     * Проверка доступности сайта
                     */
                    default boolean isSiteAvailable() {
                        return true; // Базовая реализация, можно переопределить
                    }
                
                    /**
                     * Получение информации о парсере
                     */
                    default String getParserInfo() {
                        return "SiteParser for " + getSiteName();
                    }
                }
                ----------------------------------------
            [DIR] storage

              [FILE] WhitelistManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/WhitelistManager.java
                Размер: 4462 байт
                Дата изменения: 2026-01-20T08:36:42.572540553Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                
                /**
                 * Менеджер белого списка пользователей - ОПТИМИЗИРОВАННЫЙ
                 */
                public class WhitelistManager {
                    private static final Logger logger = LoggerFactory.getLogger(WhitelistManager.class);
                    private static final String WHITELIST_FILE = "data/whitelist.txt";
                    private static final Set<Long> whitelist = Collections.synchronizedSet(new HashSet<>());
                    private static volatile boolean isInitialized = false;
                
                    static {
                        synchronized (WhitelistManager.class) {
                            if (!isInitialized) {
                                loadWhitelist();
                                isInitialized = true;
                            }
                        }
                    }
                
                    /**
                     * Загрузка белого списка из файла
                     */
                    private static void loadWhitelist() {
                        List<String> lines = FileStorage.readLines(WHITELIST_FILE);
                        logger.info("Loading whitelist. Found {} lines", lines.size());
                
                        for (String line : lines) {
                            try {
                                line = line.trim();
                                if (line.isEmpty() || line.startsWith("#")) {
                                    continue;
                                }
                
                                long userId = Long.parseLong(line);
                                if (userId > 0) {
                                    whitelist.add(userId);
                                } else {
                                    logger.warn("Invalid user ID in whitelist (must be > 0): {}", userId);
                                }
                            } catch (NumberFormatException e) {
                                logger.warn("Invalid user ID format in whitelist: '{}'. Error: {}", line, e.getMessage());
                            }
                        }
                
                        logger.info("✅ Loaded {} users from whitelist", whitelist.size());
                    }
                
                    /**
                     * Сохранение белого списка в файл
                     */
                    private static void saveWhitelist() {
                        List<String> lines = new ArrayList<>();
                        lines.add("# Whitelist - authorized users");
                        lines.add("# Format: one user ID per line");
                        lines.add("# Created: " + new Date());
                        lines.add("");
                
                        List<Long> sortedUsers = new ArrayList<>(whitelist);
                        Collections.sort(sortedUsers);
                
                        for (Long userId : sortedUsers) {
                            lines.add(String.valueOf(userId));
                        }
                
                        try {
                            FileStorage.writeLines(WHITELIST_FILE, lines);
                            logger.info("✅ Whitelist saved: {} users", whitelist.size());
                        } catch (Exception e) {
                            logger.error("❌ Failed to save whitelist: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Проверка авторизации пользователя
                     */
                    public static boolean isUserAllowed(long userId) {
                        boolean allowed = whitelist.contains(userId);
                        if (!allowed) {
                            logger.warn("Unauthorized access attempt from user {}", userId);
                        }
                        return allowed;
                    }
                
                    /**
                     * Добавление пользователя
                     */
                    public static boolean addUser(long userId) {
                        if (userId <= 0) {
                            logger.warn("Invalid user ID: {}", userId);
                            return false;
                        }
                
                        if (whitelist.add(userId)) {
                            saveWhitelist();
                            logger.info("✅ User {} added to whitelist", userId);
                            return true;
                        }
                
                        return false;
                    }
                
                    /**
                     * Удаление пользователя
                     */
                    public static boolean removeUser(long userId) {
                        if (whitelist.remove(userId)) {
                            saveWhitelist();
                            logger.info("✅ User {} removed from whitelist", userId);
                            return true;
                        }
                        return false;
                    }
                
                    /**
                     * Получение всех пользователей
                     */
                    public static List<Long> getAllUsers() {
                        return new ArrayList<>(whitelist);
                    }
                
                    /**
                     * Количество пользователей
                     */
                    public static long getUserCount() {
                        return whitelist.size();
                    }
                
                    /**
                     * Проверка существования пользователя
                     */
                    public static boolean userExists(long userId) {
                        return whitelist.contains(userId);
                    }
                
                    /**
                     * Переинициализация (для тестов)
                     */
                    public static void reload() {
                        whitelist.clear();
                        loadWhitelist();
                        logger.info("Whitelist reloaded");
                    }
                }
                ----------------------------------------

              [FILE] ProductDuplicateFilter.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/ProductDuplicateFilter.java
                Размер: 3295 байт
                Дата изменения: 2026-01-20T08:37:12.13191348Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import com.parser.model.Product;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                
                /**
                 * Фильтр для предотвращения отправки дубликатов товаров
                 */
                public class ProductDuplicateFilter {
                    private static final Logger logger = LoggerFactory.getLogger(ProductDuplicateFilter.class);
                
                    // Кэш: userId -> Set<productId> (найденные товары)
                    private static final Map<Long, Set<String>> userFoundProducts = new ConcurrentHashMap<>();
                
                    /**
                     * Загрузить найденные товары пользователя
                     */
                    private static Set<String> loadUserProducts(long userId) {
                        List<Product> products = UserDataManager.getUserProducts(userId);
                        Set<String> ids = new HashSet<>();
                
                        for (Product p : products) {
                            ids.add(p.getId());
                        }
                
                        userFoundProducts.put(userId, ids);
                        logger.debug("Loaded {} products for user {}", ids.size(), userId);
                        return ids;
                    }
                
                    /**
                     * Получить новые товары (не отправленные ранее)
                     */
                    public static List<Product> filterNew(long userId, List<Product> products) {
                        if (products == null || products.isEmpty()) {
                            return new ArrayList<>();
                        }
                
                        Set<String> found = userFoundProducts.computeIfAbsent(userId,
                                k -> loadUserProducts(userId));
                
                        List<Product> newProducts = new ArrayList<>();
                
                        for (Product p : products) {
                            if (!found.contains(p.getId())) {
                                newProducts.add(p);
                                found.add(p.getId()); // Добавляем сразу, чтобы не отправить дважды
                            }
                        }
                
                        logger.info("Filter: {} total, {} new for user {}",
                                products.size(), newProducts.size(), userId);
                
                        return newProducts;
                    }
                
                    /**
                     * Добавить товары в кэш пользователя
                     */
                    public static void addProductsToCache(long userId, List<Product> products) {
                        Set<String> found = userFoundProducts.computeIfAbsent(userId,
                                k -> loadUserProducts(userId));
                
                        for (Product p : products) {
                            found.add(p.getId());
                        }
                
                        logger.debug("Added {} products to cache for user {}", products.size(), userId);
                    }
                
                    /**
                     * Очистить кэш пользователя (например, при удалении его товаров)
                     */
                    public static void clearUserCache(long userId) {
                        userFoundProducts.remove(userId);
                        logger.info("Cache cleared for user {}", userId);
                    }
                
                    /**
                     * Очистить весь кэш
                     */
                    public static void clearAllCache() {
                        userFoundProducts.clear();
                        logger.info("All cache cleared");
                    }
                
                    /**
                     * Проверить, был ли товар отправлен пользователю
                     */
                    public static boolean isProductSent(long userId, String productId) {
                        Set<String> found = userFoundProducts.computeIfAbsent(userId,
                                k -> loadUserProducts(userId));
                        return found.contains(productId);
                    }
                }
                ----------------------------------------

              [FILE] UserDataManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/UserDataManager.java
                Размер: 12980 байт
                Дата изменения: 2026-01-19T09:31:29.775386168Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import com.parser.model.Product;
                import com.parser.model.UserSettings;
                import com.fasterxml.jackson.databind.ObjectMapper;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.*;
                
                /**
                 * Менеджер для работы с данными пользователей
                 */
                public class UserDataManager {
                    private static final Logger logger = LoggerFactory.getLogger(UserDataManager.class);
                    private static final ObjectMapper objectMapper = new ObjectMapper();
                
                    /**
                     * Получение поисковых запросов пользователя
                     */
                    public static List<String> getUserQueries(long userId) {
                        String filename = "user_" + userId + "_queries.txt";
                        return FileStorage.readLines(filename);
                    }
                
                    /**
                     * Сохранение поисковых запросов пользователя
                     */
                    public static void saveUserQueries(long userId, List<String> queries) {
                        String filename = "user_" + userId + "_queries.txt";
                        FileStorage.writeLines(filename, queries);
                        logger.debug("Saved {} queries for user {}", queries.size(), userId);
                    }
                
                    /**
                     * Добавление поискового запроса
                     */
                    public static boolean addUserQuery(long userId, String query) {
                        if (query == null || query.trim().isEmpty()) {
                            logger.warn("Attempted to add empty query for user {}", userId);
                            return false;
                        }
                
                        String trimmedQuery = query.trim();
                        List<String> queries = getUserQueries(userId);
                
                        // Проверка на дубликаты
                        for (String existingQuery : queries) {
                            if (existingQuery.equalsIgnoreCase(trimmedQuery)) {
                                logger.debug("Query already exists for user {}: {}", userId, trimmedQuery);
                                return false;
                            }
                        }
                
                        // Ограничение на количество запросов
                        if (queries.size() >= 50) {
                            logger.warn("User {} reached query limit (50)", userId);
                            return false;
                        }
                
                        queries.add(trimmedQuery);
                        saveUserQueries(userId, queries);
                        logger.info("Query added for user {}: {}", userId, trimmedQuery);
                        return true;
                    }
                
                    /**
                     * Удаление поискового запроса
                     */
                    public static boolean removeUserQuery(long userId, String query) {
                        List<String> queries = getUserQueries(userId);
                        boolean removed = queries.remove(query);
                
                        if (removed) {
                            saveUserQueries(userId, queries);
                            logger.info("Query removed for user {}: {}", userId, query);
                        } else {
                            logger.debug("Query not found for user {}: {}", userId, query);
                        }
                
                        return removed;
                    }
                
                    /**
                     * Очистка всех поисковых запросов пользователя
                     */
                    public static void clearUserQueries(long userId) {
                        saveUserQueries(userId, new ArrayList<>());
                        logger.info("All queries cleared for user {}", userId);
                    }
                
                    /**
                     * Получение настроек пользователя
                     */
                    public static UserSettings getUserSettings(long userId) {
                        String filename = "user_settings/" + userId + ".json";
                        String json = FileStorage.readJson(filename);
                
                        try {
                            if (json == null || json.isEmpty() || json.equals("{}")) {
                                // Возвращаем настройки по умолчанию
                                UserSettings defaultSettings = new UserSettings();
                                saveUserSettings(userId, defaultSettings);
                                return defaultSettings;
                            }
                
                            return objectMapper.readValue(json, UserSettings.class);
                
                        } catch (Exception e) {
                            logger.error("Error parsing settings for user {}: {}", userId, e.getMessage());
                            return new UserSettings(); // Настройки по умолчанию при ошибке
                        }
                    }
                
                    /**
                     * Сохранение настроек пользователя
                     */
                    public static void saveUserSettings(long userId, UserSettings settings) {
                        String filename = "user_settings/" + userId + ".json";
                
                        try {
                            String json = objectMapper.writeValueAsString(settings);
                            FileStorage.writeJson(filename, json);
                            logger.debug("Settings saved for user {}", userId);
                
                        } catch (Exception e) {
                            logger.error("Error saving settings for user {}: {}", userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Получение сохраненных товаров пользователя
                     */
                    public static List<Product> getUserProducts(long userId) {
                        String filename = "user_products/" + userId + ".json";
                        String json = FileStorage.readJson(filename);
                
                        if (json == null || json.isEmpty() || json.equals("{}")) {
                            return new ArrayList<>();
                        }
                
                        try {
                            Product[] products = objectMapper.readValue(json, Product[].class);
                            return new ArrayList<>(Arrays.asList(products));
                
                        } catch (Exception e) {
                            logger.error("Error parsing products for user {}: {}", userId, e.getMessage());
                            return new ArrayList<>();
                        }
                    }
                
                    /**
                     * Сохранение товаров пользователя
                     */
                    public static void saveUserProducts(long userId, List<Product> products) {
                        String filename = "user_products/" + userId + ".json";
                
                        try {
                            String json = objectMapper.writeValueAsString(products);
                            FileStorage.writeJson(filename, json);
                            logger.debug("Saved {} products for user {}", products.size(), userId);
                
                        } catch (Exception e) {
                            logger.error("Error saving products for user {}: {}", userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Добавление товаров к существующим
                     */
                    public static void addUserProducts(long userId, List<Product> newProducts) {
                        if (newProducts == null || newProducts.isEmpty()) {
                            return;
                        }
                
                        List<Product> existingProducts = getUserProducts(userId);
                        Set<String> existingIds = new HashSet<>();
                
                        // Собираем ID существующих товаров
                        for (Product product : existingProducts) {
                            existingIds.add(product.getId());
                        }
                
                        // Добавляем только новые товары
                        for (Product product : newProducts) {
                            if (!existingIds.contains(product.getId())) {
                                existingProducts.add(product);
                                existingIds.add(product.getId());
                            }
                        }
                
                        // Ограничиваем количество хранимых товаров
                        if (existingProducts.size() > 1000) {
                            existingProducts = existingProducts.subList(
                                    existingProducts.size() - 1000, existingProducts.size());
                        }
                
                        saveUserProducts(userId, existingProducts);
                    }
                
                    /**
                     * Очистка товаров пользователя
                     */
                    public static void clearUserProducts(long userId) {
                        String filename = "user_products/" + userId + ".json";
                        FileStorage.writeJson(filename, "[]");
                        logger.info("Products cleared for user {}", userId);
                    }
                
                    /**
                     * Фильтрация новых товаров
                     */
                    public static List<Product> filterNewProducts(long userId, List<Product> products) {
                        if (products == null || products.isEmpty()) {
                            return new ArrayList<>();
                        }
                
                        List<Product> existingProducts = getUserProducts(userId);
                        Set<String> existingIds = new HashSet<>();
                
                        for (Product product : existingProducts) {
                            existingIds.add(product.getId());
                        }
                
                        List<Product> newProducts = new ArrayList<>();
                        for (Product product : products) {
                            if (!existingIds.contains(product.getId())) {
                                newProducts.add(product);
                            }
                        }
                
                        return newProducts;
                    }
                
                
                    /**
                     * Получение статистики пользователя
                     */
                    public static Map<String, Object> getUserStats(long userId) {
                        Map<String, Object> stats = new HashMap<>();
                
                        // Количество запросов
                        List<String> queries = getUserQueries(userId);
                        stats.put("queryCount", queries.size());
                
                        // Количество товаров
                        List<Product> products = getUserProducts(userId);
                        stats.put("productCount", products.size());
                
                        // Настройки
                        UserSettings settings = getUserSettings(userId);
                        stats.put("settings", settings.getSummary());
                
                        // Дата последнего изменения
                        String queriesFile = "user_" + userId + "_queries.txt";
                        String productsFile = "user_products/" + userId + ".json";
                        String settingsFile = "user_settings/" + userId + ".json";
                
                        stats.put("queriesLastModified", FileStorage.getLastModified(queriesFile));
                        stats.put("productsLastModified", FileStorage.getLastModified(productsFile));
                        stats.put("settingsLastModified", FileStorage.getLastModified(settingsFile));
                
                        return stats;
                    }
                
                    /**
                     * Удаление всех данных пользователя
                     */
                    public static boolean deleteUserData(long userId) {
                        try {
                            String queriesFile = "user_" + userId + "_queries.txt";
                            String productsFile = "user_products/" + userId + ".json";
                            String settingsFile = "user_settings/" + userId + ".json";
                
                            boolean deleted = true;
                            deleted &= FileStorage.deleteFile(queriesFile);
                            deleted &= FileStorage.deleteFile(productsFile);
                            deleted &= FileStorage.deleteFile(settingsFile);
                
                            if (deleted) {
                                logger.info("All data deleted for user {}", userId);
                            } else {
                                logger.warn("Some files could not be deleted for user {}", userId);
                            }
                
                            return deleted;
                
                        } catch (Exception e) {
                            logger.error("Error deleting data for user {}: {}", userId, e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Экспорт данных пользователя
                     */
                    public static boolean exportUserData(long userId, String exportFilename) {
                        try {
                            Map<String, Object> exportData = new HashMap<>();
                
                            exportData.put("userId", userId);
                            exportData.put("exportDate", new Date());
                
                            // Запросы
                            exportData.put("queries", getUserQueries(userId));
                
                            // Настройки
                            UserSettings settings = getUserSettings(userId);
                            exportData.put("settings", objectMapper.convertValue(settings, Map.class));
                
                            // Товары (только последние 100)
                            List<Product> products = getUserProducts(userId);
                            int startIndex = Math.max(0, products.size() - 100);
                            exportData.put("recentProducts", products.subList(startIndex, products.size()));
                
                            // Запись в файл
                            String json = objectMapper.writeValueAsString(exportData);
                            FileStorage.writeJson(exportFilename, json);
                
                            logger.info("Data exported for user {} to {}", userId, exportFilename);
                            return true;
                
                        } catch (Exception e) {
                            logger.error("Error exporting data for user {}: {}", userId, e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Поиск товаров пользователя по критериям
                     */
                    public static List<Product> searchUserProducts(long userId, String searchTerm,
                                                                   double minPrice, double maxPrice) {
                        List<Product> allProducts = getUserProducts(userId);
                        List<Product> results = new ArrayList<>();
                
                        String searchLower = searchTerm.toLowerCase();
                
                        for (Product product : allProducts) {
                            boolean matches = true;
                
                            // Поиск по тексту
                            if (searchTerm != null && !searchTerm.isEmpty()) {
                                String title = product.getTitle().toLowerCase();
                                String query = product.getQuery().toLowerCase();
                                matches = title.contains(searchLower) || query.contains(searchLower);
                            }
                
                            // Фильтр по цене
                            if (matches && minPrice > 0) {
                                matches = product.getPrice() >= minPrice;
                            }
                
                            if (matches && maxPrice > 0) {
                                matches = product.getPrice() <= maxPrice;
                            }
                
                            if (matches) {
                                results.add(product);
                            }
                        }
                
                        return results;
                    }
                }
                ----------------------------------------

              [FILE] FileStorage.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/FileStorage.java
                Размер: 17737 байт
                Дата изменения: 2026-01-20T09:16:42.421725912Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import com.parser.config.Config;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.*;
                import java.nio.charset.StandardCharsets;
                import java.nio.file.*;
                import java.util.*;
                import java.util.concurrent.locks.ReentrantLock;
                import java.util.zip.GZIPOutputStream;
                
                /**
                 * Утилита для работы с файловым хранилищем
                 */
                public class FileStorage {
                    private static final Logger logger = LoggerFactory.getLogger(FileStorage.class);
                
                    // Блокировки для предотвращения конкурентного доступа
                    private static final Map<String, ReentrantLock> fileLocks = new HashMap<>();
                
                    /**
                     * Получение блокировки для файла
                     */
                    private static synchronized ReentrantLock getFileLock(String filename) {
                        return fileLocks.computeIfAbsent(filename, k -> new ReentrantLock());
                    }
                
                    /**
                     * Создание директории для данных, если она не существует
                     */
                    public static void ensureDataDir() {
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        File dir = new File(dataDir);
                
                        if (!dir.exists()) {
                            logger.info("Создание директории данных: {}", dataDir);
                            if (dir.mkdirs()) {
                                logger.info("✅ Директория данных создана: {}", dataDir);
                
                                // Создание поддиректорий
                                createSubdirectory(dataDir, "user_settings");
                                createSubdirectory(dataDir, "user_products");
                                createSubdirectory(dataDir, "backups");
                                createSubdirectory(dataDir, "logs");
                
                            } else {
                                logger.error("❌ Не удалось создать директорию данных: {}", dataDir);
                                throw new RuntimeException("Failed to create data directory: " + dataDir);
                            }
                        } else {
                            logger.debug("Директория данных уже существует: {}", dataDir);
                        }
                    }
                
                    /**
                     * Создание поддиректории
                     */
                    private static void createSubdirectory(String parentDir, String subdirName) {
                        File subdir = new File(parentDir + "/" + subdirName);
                        if (!subdir.exists()) {
                            if (subdir.mkdirs()) {
                                logger.debug("✅ Создана поддиректория: {}", subdir.getAbsolutePath());
                            } else {
                                logger.warn("⚠️ Не удалось создать поддиректорию: {}", subdir.getAbsolutePath());
                            }
                        }
                    }
                
                    /**
                     * Получение пути к файлу
                     */
                    public static String getFilePath(String filename) {
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        return dataDir + "/" + filename;
                    }
                
                    /**
                     * Чтение строк из файла
                     */
                    public static List<String> readLines(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            if (!file.exists()) {
                                logger.debug("Файл не существует: {}", filename);
                                return new ArrayList<>();
                            }
                
                            List<String> lines = new ArrayList<>();
                            try (BufferedReader reader = new BufferedReader(
                                    new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {
                
                                String line;
                                int lineNumber = 0;
                                while ((line = reader.readLine()) != null) {
                                    lineNumber++;
                                    line = line.trim();
                                    if (!line.isEmpty()) {
                                        lines.add(line);
                                    }
                                }
                
                                logger.debug("Прочитано {} строк из {}", lines.size(), filename);
                                return lines;
                
                            } catch (IOException e) {
                                logger.error("Ошибка чтения файла {}: {}", filename, e.getMessage());
                                return new ArrayList<>();
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Запись строк в файл
                     */
                    public static void writeLines(String filename, List<String> lines) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            ensureDataDir();
                            File file = new File(getFilePath(filename));
                
                            logger.info("📝 Запись в файл: {} (абсолютный путь: {})",
                                    filename, file.getAbsolutePath());
                            logger.info("   Файл существует перед записью: {}", file.exists());
                            logger.info("   Родительская директория: {}", file.getParent());
                            logger.info("   Количество строк для записи: {}", lines.size());
                
                            // Проверяем родительскую директорию
                            File parentDir = file.getParentFile();
                            if (parentDir != null && !parentDir.exists()) {
                                logger.info("   Создание родительской директории: {}", parentDir.getAbsolutePath());
                                if (!parentDir.mkdirs()) {
                                    logger.error("❌ Не удалось создать родительскую директорию");
                                    throw new RuntimeException("Cannot create parent directory: " + parentDir.getAbsolutePath());
                                }
                            }
                
                            // Проверяем права на запись
                            if (file.exists() && !file.canWrite()) {
                                logger.error("❌ Нет прав на запись в файл: {}", file.getAbsolutePath());
                                throw new RuntimeException("No write permission for file: " + file.getAbsolutePath());
                            }
                
                            // Создание резервной копии, если файл существует
                            if (file.exists()) {
                                logger.debug("   Создание резервной копии...");
                                createBackup(filename);
                            }
                
                            try (BufferedWriter writer = new BufferedWriter(
                                    new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))) {
                
                                for (String line : lines) {
                                    writer.write(line);
                                    writer.newLine();
                                }
                
                                writer.flush();
                
                                logger.info("✅ Успешно записано {} строк в {}", lines.size(), filename);
                                logger.info("   Файл существует после записи: {}", file.exists());
                                logger.info("   Размер файла после записи: {} байт", file.length());
                
                            } catch (IOException e) {
                                logger.error("❌ Ошибка записи файла {}: {}", filename, e.getMessage(), e);
                                throw new RuntimeException("Failed to write file: " + filename, e);
                            }
                
                        } catch (Exception e) {
                            logger.error("❌ Критическая ошибка в writeLines для {}: {}", filename, e.getMessage(), e);
                            // Пробрасываем исключение дальше
                            if (e instanceof RuntimeException) {
                                throw (RuntimeException) e;
                            } else {
                                throw new RuntimeException("Error in writeLines for " + filename, e);
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Добавление строки в конец файла
                     */
                    public static void appendLine(String filename, String line) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            ensureDataDir();
                            File file = new File(getFilePath(filename));
                
                            try (BufferedWriter writer = new BufferedWriter(
                                    new OutputStreamWriter(new FileOutputStream(file, true), StandardCharsets.UTF_8))) {
                
                                writer.write(line);
                                writer.newLine();
                
                                logger.debug("Appended line to {}", filename);
                
                            } catch (IOException e) {
                                logger.error("Error appending to file {}: {}", filename, e.getMessage());
                                throw new RuntimeException("Failed to append to file: " + filename, e);
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Чтение JSON объекта из файла
                     */
                    public static String readJson(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            if (!file.exists()) {
                                return "{}";
                            }
                
                            StringBuilder content = new StringBuilder();
                            try (BufferedReader reader = new BufferedReader(
                                    new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {
                
                                String line;
                                while ((line = reader.readLine()) != null) {
                                    content.append(line);
                                }
                
                                return content.toString();
                
                            } catch (IOException e) {
                                logger.error("Error reading JSON file {}: {}", filename, e.getMessage());
                                return "{}";
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Запись JSON объекта в файл
                     */
                    public static void writeJson(String filename, String json) {
                        writeLines(filename, List.of(json));
                    }
                
                    /**
                     * Проверка существования файла
                     */
                    public static boolean fileExists(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists();
                    }
                
                    /**
                     * Удаление файла
                     */
                    public static boolean deleteFile(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            boolean deleted = file.delete();
                
                            if (deleted) {
                                logger.debug("Deleted file: {}", filename);
                            } else {
                                logger.warn("Failed to delete file: {}", filename);
                            }
                
                            return deleted;
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Копирование файла
                     */
                    public static boolean copyFile(String sourceFilename, String destFilename) {
                        ReentrantLock sourceLock = getFileLock(sourceFilename);
                        ReentrantLock destLock = getFileLock(destFilename);
                
                        sourceLock.lock();
                        destLock.lock();
                
                        try {
                            Path source = Paths.get(getFilePath(sourceFilename));
                            Path destination = Paths.get(getFilePath(destFilename));
                
                            Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);
                            logger.debug("Copied {} to {}", sourceFilename, destFilename);
                            return true;
                
                        } catch (IOException e) {
                            logger.error("Error copying file {} to {}: {}",
                                    sourceFilename, destFilename, e.getMessage());
                            return false;
                        } finally {
                            destLock.unlock();
                            sourceLock.unlock();
                        }
                    }
                
                    /**
                     * Создание резервной копии файла
                     */
                    public static void createBackup(String filename) {
                        if (!Config.getBoolean("storage.backup.enabled", true)) {
                            return;
                        }
                
                        try {
                            String backupDir = "backups";
                            String timestamp = new java.text.SimpleDateFormat("yyyyMMdd_HHmmss")
                                    .format(new java.util.Date());
                
                            String backupFilename = String.format("%s/%s_%s.backup",
                                    backupDir, filename.replace("/", "_"), timestamp);
                
                            copyFile(filename, backupFilename);
                
                            // Сжатие резервной копии
                            compressFile(backupFilename);
                
                            // Очистка старых резервных копий
                            cleanupOldBackups(filename);
                
                        } catch (Exception e) {
                            logger.error("Error creating backup for {}: {}", filename, e.getMessage());
                        }
                    }
                
                    /**
                     * Сжатие файла с использованием GZIP
                     */
                    private static void compressFile(String filename) {
                        try {
                            File inputFile = new File(getFilePath(filename));
                            File outputFile = new File(getFilePath(filename + ".gz"));
                
                            try (FileInputStream fis = new FileInputStream(inputFile);
                                 FileOutputStream fos = new FileOutputStream(outputFile);
                                 GZIPOutputStream gzipOS = new GZIPOutputStream(fos)) {
                
                                byte[] buffer = new byte[1024];
                                int len;
                                while ((len = fis.read(buffer)) != -1) {
                                    gzipOS.write(buffer, 0, len);
                                }
                            }
                
                            // Удаление несжатого файла
                            inputFile.delete();
                            logger.debug("Compressed backup file: {}", outputFile.getName());
                
                        } catch (IOException e) {
                            logger.error("Error compressing file {}: {}", filename, e.getMessage());
                        }
                    }
                
                    /**
                     * Очистка старых резервных копий
                     */
                    private static void cleanupOldBackups(String originalFilename) {
                        try {
                            String backupDir = getFilePath("backups");
                            File dir = new File(backupDir);
                
                            if (!dir.exists()) {
                                return;
                            }
                
                            String baseName = originalFilename.replace("/", "_");
                            File[] backupFiles = dir.listFiles((d, name) ->
                                    name.startsWith(baseName + "_") && name.endsWith(".backup.gz"));
                
                            if (backupFiles == null || backupFiles.length <= 10) {
                                return; // Сохраняем последние 10 копий
                            }
                
                            // Сортировка по времени изменения (старые первыми)
                            Arrays.sort(backupFiles, Comparator.comparingLong(File::lastModified));
                
                            // Удаление старых копий
                            for (int i = 0; i < backupFiles.length - 10; i++) {
                                backupFiles[i].delete();
                                logger.debug("Deleted old backup: {}", backupFiles[i].getName());
                            }
                
                        } catch (Exception e) {
                            logger.error("Error cleaning up old backups: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение списка файлов в директории
                     */
                    public static List<String> listFiles(String directory) {
                        String dirPath = getFilePath(directory);
                        File dir = new File(dirPath);
                
                        if (!dir.exists() || !dir.isDirectory()) {
                            return new ArrayList<>();
                        }
                
                        File[] files = dir.listFiles();
                        if (files == null) {
                            return new ArrayList<>();
                        }
                
                        List<String> fileList = new ArrayList<>();
                        for (File file : files) {
                            if (file.isFile()) {
                                fileList.add(file.getName());
                            }
                        }
                
                        return fileList;
                    }
                
                    /**
                     * Получение размера файла в байтах
                     */
                    public static long getFileSize(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists() ? file.length() : 0;
                    }
                
                    /**
                     * Получение времени последнего изменения файла
                     */
                    public static long getLastModified(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists() ? file.lastModified() : 0;
                    }
                
                    /**
                     * Проверка, является ли файл пустым
                     */
                    public static boolean isEmpty(String filename) {
                        File file = new File(getFilePath(filename));
                        return !file.exists() || file.length() == 0;
                    }
                
                    /**
                     * Создание директории
                     */
                    public static boolean createDirectory(String directory) {
                        String dirPath = getFilePath(directory);
                        File dir = new File(dirPath);
                        return dir.mkdirs();
                    }
                
                    /**
                     * Получение статистики файлового хранилища
                     */
                    public static Map<String, Object> getStorageStats() {
                        Map<String, Object> stats = new HashMap<>();
                
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        File dir = new File(dataDir);
                
                        if (!dir.exists()) {
                            stats.put("status", "directory_not_exists");
                            return stats;
                        }
                
                        stats.put("directory", dataDir);
                        stats.put("exists", true);
                        stats.put("totalSpace", dir.getTotalSpace());
                        stats.put("freeSpace", dir.getFreeSpace());
                        stats.put("usableSpace", dir.getUsableSpace());
                
                        // Подсчет файлов
                        File[] files = dir.listFiles();
                        if (files != null) {
                            stats.put("totalFiles", files.length);
                
                            long totalSize = 0;
                            for (File file : files) {
                                totalSize += file.length();
                            }
                            stats.put("totalSizeBytes", totalSize);
                            stats.put("totalSizeMB", totalSize / (1024 * 1024));
                        }
                
                        return stats;
                    }
                }
                ----------------------------------------
            [DIR] telegram

              [FILE] TelegramNotificationService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/telegram/TelegramNotificationService.java
                Размер: 9465 байт
                Дата изменения: 2026-01-17T14:49:12.908926501Z
                Содержимое:
                ----------------------------------------
                package com.parser.telegram;
                
                import com.parser.config.Config;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
                import org.telegram.telegrambots.meta.api.methods.send.SendPhoto;
                import org.telegram.telegrambots.meta.api.objects.InputFile;
                import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
                
                import java.net.URL;
                import java.util.Date;
                
                /**
                 * Сервис для отправки уведомлений через Telegram
                 */
                public class TelegramNotificationService {
                    private static final Logger logger = LoggerFactory.getLogger(TelegramNotificationService.class);
                
                    private static TelegramBotService botInstance;
                
                    /**
                     * Установка экземпляра бота для отправки уведомлений
                     */
                    public static void setBotInstance(TelegramBotService bot) {
                        botInstance = bot;
                        logger.info("TelegramNotificationService initialized with bot instance");
                    }
                
                    /**
                     * Отправка простого текстового сообщения
                     */
                    public static boolean sendMessage(long userId, String text) {
                        return sendMessage(userId, text, false);
                    }
                
                    /**
                     * Отправка текстового сообщения с HTML форматированием
                     */
                    public static boolean sendHtmlMessage(long userId, String htmlText) {
                        return sendMessage(userId, htmlText, true);
                    }
                
                    /**
                     * Основной метод отправки сообщения
                     */
                    private static boolean sendMessage(long userId, String text, boolean useHtml) {
                        if (botInstance == null) {
                            logger.error("Bot instance not set for TelegramNotificationService");
                            return false;
                        }
                
                        if (text == null || text.trim().isEmpty()) {
                            logger.warn("Attempted to send empty message to user {}", userId);
                            return false;
                        }
                
                        try {
                            SendMessage message = new SendMessage();
                            message.setChatId(String.valueOf(userId));
                
                            if (useHtml) {
                                message.setText(text);
                                message.setParseMode("HTML");
                                message.disableWebPagePreview();
                            } else {
                                message.setText(text);
                            }
                
                            botInstance.execute(message);
                            logger.debug("Message sent to user {}", userId);
                            return true;
                
                        } catch (TelegramApiException e) {
                            logger.error("Error sending message to user {}: {}", userId, e.getMessage());
                
                            if (useHtml) {
                                logger.info("Retrying without HTML formatting...");
                                String plainText = stripHtml(text);
                                return sendMessage(userId, plainText, false);
                            }
                            return false;
                        }
                    }
                
                    /**
                     * Отправка фото с подписью (HTML форматирование)
                     */
                    public static boolean sendPhotoWithHtmlCaption(long userId, String photoUrl, String htmlCaption) {
                        if (botInstance == null) {
                            logger.error("Bot instance not set for TelegramNotificationService");
                            return false;
                        }
                
                        if (photoUrl == null || photoUrl.isEmpty()) {
                            logger.warn("Empty photo URL for user {}", userId);
                            return false;
                        }
                
                        try {
                            // Проверяем, является ли URL валидным
                            if (!isValidUrl(photoUrl)) {
                                logger.warn("Invalid photo URL: {}", photoUrl);
                                return sendHtmlMessage(userId, htmlCaption);
                            }
                
                            SendPhoto photo = new SendPhoto();
                            photo.setChatId(String.valueOf(userId));
                
                            // Используем URL напрямую
                            photo.setPhoto(new InputFile(photoUrl));
                
                            if (htmlCaption != null && !htmlCaption.isEmpty()) {
                                // Обрезаем подпись если она слишком длинная (макс 1024 символа для Telegram)
                                if (htmlCaption.length() > 1024) {
                                    htmlCaption = htmlCaption.substring(0, 1020) + "...";
                                }
                                photo.setCaption(htmlCaption);
                                photo.setParseMode("HTML");
                            }
                
                            botInstance.execute(photo);
                            logger.debug("Photo with caption sent to user {}", userId);
                            return true;
                
                        } catch (TelegramApiException e) {
                            logger.error("Error sending photo to user {}: {}", userId, e.getMessage());
                
                            // Если не удалось отправить фото, отправляем текстовое сообщение
                            if (htmlCaption != null && !htmlCaption.isEmpty()) {
                                String textMessage = "📸 " + stripHtml(htmlCaption);
                                return sendMessage(userId, textMessage);
                            }
                            return false;
                        } catch (Exception e) {
                            logger.error("Unexpected error sending photo to user {}: {}", userId, e.getMessage());
                            return sendHtmlMessage(userId, htmlCaption);
                        }
                    }
                
                    /**
                     * Проверка валидности URL
                     */
                    private static boolean isValidUrl(String url) {
                        try {
                            new URL(url).toURI();
                            return true;
                        } catch (Exception e) {
                            return false;
                        }
                    }
                
                    /**
                     * Удаление HTML тегов из текста
                     */
                    private static String stripHtml(String html) {
                        if (html == null) return "";
                        return html.replaceAll("<[^>]*>", "")
                                .replace("&amp;", "&")
                                .replace("&lt;", "<")
                                .replace("&gt;", ">")
                                .replace("&quot;", "\"")
                                .replace("&#39;", "'");
                    }
                
                    /**
                     * Экранирование для HTML
                     */
                    public static String escapeHtml(String text) {
                        if (text == null) return "";
                
                        return text.replace("&", "&amp;")
                                .replace("<", "&lt;")
                                .replace(">", "&gt;")
                                .replace("\"", "&quot;")
                                .replace("'", "&#39;");
                    }
                
                    /**
                     * Отправка тестового уведомления
                     */
                    public static boolean sendTestNotification(long userId) {
                        logger.info("Sending test notification to user {}", userId);
                
                        String message = "<b>✅ Test notification</b>\n\n" +
                                "Parser is working correctly!\n" +
                                "This is a test message to confirm that the notification system is functioning.\n\n" +
                                "<i>Time: " + new Date() + "</i>";
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления о найденных товарах
                     */
                    public static boolean sendProductsNotification(long userId, int count, String query) {
                        String message = String.format("<b>🛍️ Found products!</b>\n\n" +
                                "Query: %s\n" +
                                "Products found: %d\n\n" +
                                "<i>Sending details...</i>", escapeHtml(query), count);
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления об ошибке
                     */
                    public static boolean sendErrorNotification(long userId, String errorMessage) {
                        String message = String.format("<b>❌ Parser error</b>\n\n" +
                                        "An error occurred:\n" +
                                        "<code>%s</code>\n\n" +
                                        "<i>The parser will be restarted automatically.</i>",
                                escapeHtml(errorMessage));
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления о состоянии парсера
                     */
                    public static boolean sendStatusNotification(long userId, String status, String details) {
                        String emoji = "🟢";
                        if (status.contains("stopped")) emoji = "🔴";
                        if (status.contains("paused")) emoji = "⏸️";
                        if (status.contains("error")) emoji = "❌";
                
                        String message = String.format("%s <b>Parser status changed</b>\n\n" +
                                "New status: %s\n\n" +
                                "%s", emoji, status, escapeHtml(details));
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления администратору
                     */
                    public static boolean sendAdminNotification(String message) {
                        long adminId = Config.getTelegramAdminId();
                        if (adminId == 0) {
                            logger.warn("Admin ID not configured");
                            return false;
                        }
                
                        String adminMessage = String.format("<b>👑 Admin notification</b>\n\n" +
                                        "%s\n\n" +
                                        "<i>Time: %s</i>",
                                escapeHtml(message),
                                new Date());
                
                        return sendHtmlMessage(adminId, adminMessage);
                    }
                
                    /**
                     * Проверка доступности бота
                     */
                    public static boolean isBotAvailable() {
                        return botInstance != null;
                    }
                
                    /**
                     * Отправка фото с подписью (удобный метод для использования из других классов)
                     */
                    public static boolean sendPhotoWithCaption(long userId, String photoUrl, String caption) {
                        return sendPhotoWithHtmlCaption(userId, photoUrl, caption);
                    }
                }
                ----------------------------------------

              [FILE] TelegramBotService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/telegram/TelegramBotService.java
                Размер: 16482 байт
                Дата изменения: 2026-01-20T08:40:14.817745303Z
                Содержимое:
                ----------------------------------------
                package com.parser.telegram;
                
                import com.parser.config.Config;
                import com.parser.core.ThreadManager;
                import com.parser.model.UserSettings;
                import com.parser.service.CookieService;
                import com.parser.storage.WhitelistManager;
                import com.parser.storage.UserDataManager;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import org.telegram.telegrambots.bots.TelegramLongPollingBot;
                import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
                import org.telegram.telegrambots.meta.api.objects.Update;
                import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
                
                import java.util.*;
                
                /**
                 * Telegram бот сервис - рефакторированный и оптимизированный
                 */
                public class TelegramBotService extends TelegramLongPollingBot {
                    private static final Logger logger = LoggerFactory.getLogger(TelegramBotService.class);
                
                    private final ThreadManager threadManager;
                    private final long adminId;
                    private final Map<Long, String> userStates = new java.util.concurrent.ConcurrentHashMap<>();
                    private final Map<Long, Map<String, String>> userData = new java.util.concurrent.ConcurrentHashMap<>();
                
                    public TelegramBotService(String token, ThreadManager threadManager) {
                        super(token);
                        this.threadManager = threadManager;
                        this.adminId = Config.getTelegramAdminId();
                        logger.info("TelegramBotService initialized");
                    }
                
                    @Override
                    public void onUpdateReceived(Update update) {
                        try {
                            if (update.hasMessage() && update.getMessage().hasText()) {
                                handleMessage(update.getMessage());
                            } else if (update.hasCallbackQuery()) {
                                handleCallback(update.getCallbackQuery());
                            }
                        } catch (Exception e) {
                            logger.error("Error processing update: {}", e.getMessage());
                        }
                    }
                
                    private void handleMessage(org.telegram.telegrambots.meta.api.objects.Message msg) {
                        long userId = msg.getChatId();
                        String text = msg.getText();
                
                        logger.debug("Message from {}: {}", userId, text);
                
                        if (text.startsWith("/")) {
                            handleCommand(userId, text);
                        } else {
                            handleTextResponse(userId, text);
                        }
                    }
                
                    private void handleCommand(long userId, String command) {
                        String[] parts = command.split(" ", 2);
                        String cmd = parts[0].toLowerCase();
                        String args = parts.length > 1 ? parts[1] : "";
                
                        switch (cmd) {
                            case "/start":
                                handleStart(userId);
                                break;
                            case "/help":
                                sendHelpMessage(userId);
                                break;
                            case "/status":
                                sendStatus(userId);
                                break;
                            case "/addquery":
                                handleAddQuery(userId, args);
                                break;
                            case "/listqueries":
                                handleListQueries(userId);
                                break;
                            case "/removequery":
                                handleRemoveQuery(userId, args);
                                break;
                            case "/settings":
                                sendSettingsMenu(userId);
                                break;
                            case "/start_parser":
                                threadManager.startUserParser(userId);
                                break;
                            case "/stop_parser":
                                threadManager.stopUserParser(userId);
                                break;
                            case "/stats":
                                sendStats(userId);
                                break;
                            case "/cookies":
                                handleCookiesCommand(userId, args);
                                break;
                            case "/admin":
                                handleAdminCommand(userId, args);
                                break;
                            case "/getid":
                                sendMessage(userId, "🆔 Your ID: `" + userId + "`");
                                break;
                            default:
                                sendMessage(userId, "❓ Unknown command. Use /help");
                        }
                    }
                
                    private void handleTextResponse(long userId, String text) {
                        String state = userStates.get(userId);
                        if (state == null) {
                            sendMessage(userId, "Use commands. /help - command list");
                            return;
                        }
                
                        switch (state) {
                            case "AWAITING_QUERY":
                                if (UserDataManager.addUserQuery(userId, text.trim())) {
                                    sendMessage(userId, "✅ Query added: " + text);
                                } else {
                                    sendMessage(userId, "⚠️ Query already exists");
                                }
                                userStates.remove(userId);
                                break;
                            case "AWAITING_SETTING_VALUE":
                                handleSettingUpdate(userId, text);
                                break;
                        }
                    }
                
                    private void handleCallback(org.telegram.telegrambots.meta.api.objects.CallbackQuery callback) {
                        long userId = callback.getMessage().getChatId();
                        String data = callback.getData();
                
                        logger.debug("Callback from {}: {}", userId, data);
                
                        try {
                            execute(new org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery(callback.getId()));
                        } catch (TelegramApiException e) {
                            logger.warn("Failed to answer callback: {}", e.getMessage());
                        }
                    }
                
                    private void handleStart(long userId) {
                        // 🔴 ДОБАВЛЯЕМ В WHITELIST
                        boolean isNew = WhitelistManager.addUser(userId);
                
                        String msg;
                        if (isNew) {
                            msg = "🎉 Welcome! Your ID: " + userId + "\n\n" +
                                    "Bot features:\n" +
                                    "• Add search queries with /addquery\n" +
                                    "• Start parser with /start_parser\n" +
                                    "• View results with /stats\n\n" +
                                    "Use /help for all commands";
                        } else {
                            msg = "👋 Welcome back!\n\nUse /help for commands";
                        }
                
                        sendMessage(userId, msg);
                    }
                
                    private void handleAddQuery(long userId, String query) {
                        // 🔴 ПРОВЕРКА WHITELIST
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            sendMessage(userId, "❌ You are not authorized");
                            return;
                        }
                
                        if (query.trim().isEmpty()) {
                            userStates.put(userId, "AWAITING_QUERY");
                            sendMessage(userId, "Enter search query:");
                            return;
                        }
                
                        if (UserDataManager.addUserQuery(userId, query.trim())) {
                            sendMessage(userId, "✅ Query added: " + query);
                        } else {
                            sendMessage(userId, "⚠️ Query already exists or limit reached");
                        }
                    }
                
                    private void handleListQueries(long userId) {
                        // 🔴 ПРОВЕРКА WHITELIST
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            sendMessage(userId, "❌ You are not authorized");
                            return;
                        }
                
                        List<String> queries = UserDataManager.getUserQueries(userId);
                        if (queries.isEmpty()) {
                            sendMessage(userId, "📭 No queries. Use /addquery");
                            return;
                        }
                
                        StringBuilder sb = new StringBuilder("📋 Your queries:\n\n");
                        for (int i = 0; i < queries.size(); i++) {
                            sb.append(String.format("%d. %s\n", i + 1, queries.get(i)));
                        }
                
                        sendMessage(userId, sb.toString());
                    }
                
                    private void handleRemoveQuery(long userId, String arg) {
                        // 🔴 ПРОВЕРКА WHITELIST
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            sendMessage(userId, "❌ You are not authorized");
                            return;
                        }
                
                        try {
                            if (arg.trim().isEmpty()) {
                                sendMessage(userId, "Use: /removequery [number]");
                                return;
                            }
                
                            int idx = Integer.parseInt(arg.trim()) - 1;
                            List<String> queries = UserDataManager.getUserQueries(userId);
                
                            if (idx < 0 || idx >= queries.size()) {
                                sendMessage(userId, "❌ Invalid number");
                                return;
                            }
                
                            UserDataManager.removeUserQuery(userId, queries.get(idx));
                            sendMessage(userId, "✅ Query removed");
                        } catch (NumberFormatException e) {
                            sendMessage(userId, "❌ Invalid format. Use: /removequery [number]");
                        }
                    }
                
                
                    private void handleSettingUpdate(long userId, String value) {
                        try {
                            int intVal = Integer.parseInt(value.trim());
                            UserSettings settings = UserDataManager.getUserSettings(userId);
                            Map<String, String> data = userData.get(userId);
                
                            if (data != null && data.containsKey("setting_key")) {
                                String key = data.get("setting_key");
                                switch (key) {
                                    case "check_interval":
                                        settings.setCheckInterval(intVal);
                                        break;
                                    case "max_age":
                                        settings.setMaxAgeMinutes(intVal);
                                        break;
                                    case "max_pages":
                                        settings.setMaxPages(intVal);
                                        break;
                                    case "rows_per_page":
                                        settings.setRowsPerPage(intVal);
                                        break;
                                }
                                UserDataManager.saveUserSettings(userId, settings);
                                sendMessage(userId, "✅ Setting saved");
                            }
                        } catch (NumberFormatException e) {
                            sendMessage(userId, "❌ Invalid number");
                        } finally {
                            userStates.remove(userId);
                            userData.remove(userId);
                        }
                    }
                
                    private void sendHelpMessage(long userId) {
                        String help = """
                                📚 Commands:
                                
                                🎯 Queries:
                                /addquery [text] - add query
                                /listqueries - list queries
                                /removequery [number] - remove query
                                
                                ⚙️ Settings:
                                /settings - parser settings
                                /stats - statistics
                                
                                ▶️ Control:
                                /start_parser - start
                                /stop_parser - stop
                                /status - check status
                                
                                🍪 Admin:
                                /cookies - manage cookies
                                /admin - admin menu
                                
                                ℹ️ Info:
                                /getid - your ID
                                /help - this message
                                """;
                        sendMessage(userId, help);
                    }
                
                    private void sendSettingsMenu(long userId) {
                        UserSettings s = UserDataManager.getUserSettings(userId);
                        String msg = String.format("""
                                ⚙️ Settings:
                                • Interval: %d sec
                                • Max age: %d min
                                • Pages: %d
                                • Rows/page: %d
                                • Currency: %s
                                
                                Edit with: /settings [param] [value]
                                """, s.getCheckInterval(), s.getMaxAgeMinutes(), s.getMaxPages(),
                                s.getRowsPerPage(), s.getPriceCurrency());
                        sendMessage(userId, msg);
                    }
                
                    private void sendStatus(long userId) {
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            sendMessage(userId, "❌ You are not authorized");
                            return;
                        }
                
                        Map<String, Object> status = threadManager.getUserStatus(userId);
                        if (status == null) {
                            sendMessage(userId, "🔴 Parser is not running");
                            return;
                        }
                
                        String msg = String.format(
                                "📊 Parser Status:\n\n" +
                                        "Status: %s\n" +
                                        "Products found: %d\n" +
                                        "Requests made: %d\n" +
                                        "Errors: %d\n" +
                                        "Uptime: %s",
                                status.get("status"),
                                status.get("totalProductsFound"),
                                status.get("requestsMade"),
                                status.get("errorsCount"),
                                status.getOrDefault("uptime", "N/A")
                        );
                
                        sendMessage(userId, msg);
                    }
                
                    private void sendStats(long userId) {
                        Map<String, Object> global = threadManager.getGlobalStatistics();
                        Map<String, Object> user = threadManager.getUserStatus(userId);
                
                        String msg = String.format("""
                                📊 Statistics:
                                
                                Global:
                                • Users: %d
                                • Products: %d
                                • Requests: %d
                                • Threads: %d
                                
                                Your parser: %s
                                """, global.get("totalUsers"), global.get("totalProductsFound"),
                                global.get("totalRequestsMade"), global.get("activeThreads"),
                                user == null ? "Not running" : "Running");
                        sendMessage(userId, msg);
                    }
                
                    private void handleCookiesCommand(long userId, String args) {
                        if (userId != adminId) {
                            sendMessage(userId, "❌ Admin only");
                            return;
                        }
                
                        if (args.isEmpty()) {
                            String msg = """
                                    🍪 Cookie Management:
                                    /cookies refresh - update cookies
                                    /cookies status - cookie status
                                    /cookies dynamic - toggle dynamic cookies
                                    """;
                            sendMessage(userId, msg);
                            return;
                        }
                
                        if (args.equals("refresh")) {
                            sendMessage(userId, "🔄 Updating cookies...");
                            try {
                                CookieService.refreshCookies("h5api.m.goofish.com");
                                sendMessage(userId, "✅ Cookies updated");
                            } catch (Exception e) {
                                sendMessage(userId, "❌ Error: " + e.getMessage());
                            }
                        } else if (args.equals("status")) {
                            Map<String, Object> stats = CookieService.getCacheStats();
                            sendMessage(userId, "🍪 Dynamic: " + Config.isDynamicCookiesEnabled());
                        } else if (args.equals("dynamic")) {
                            boolean current = Config.isDynamicCookiesEnabled();
                            Config.setProperty("cookie.dynamic.enabled", String.valueOf(!current));
                            Config.saveConfig();
                            sendMessage(userId, "✅ Dynamic cookies: " + (!current ? "ON" : "OFF"));
                        }
                    }
                
                    private void handleAdminCommand(long userId, String args) {
                        if (userId != adminId) {
                            sendMessage(userId, "❌ Admin only");
                            return;
                        }
                
                        if (args.isEmpty()) {
                            String menu = """
                                    👑 Admin:
                                    /admin stats - statistics
                                    /admin users - user list
                                    /admin adduser [id] - add user
                                    /admin removeuser [id] - remove user
                                    """;
                            sendMessage(userId, menu);
                            return;
                        }
                
                        String[] parts = args.split(" ", 2);
                        switch (parts[0]) {
                            case "stats":
                                sendStats(userId);
                                break;
                            case "users":
                                List<Long> users = WhitelistManager.getAllUsers();
                                sendMessage(userId, "👥 Users: " + users.size() + "\n" + users);
                                break;
                            case "adduser":
                                if (parts.length > 1) {
                                    try {
                                        long uid = Long.parseLong(parts[1]);
                                        WhitelistManager.addUser(uid);
                                        sendMessage(userId, "✅ User added");
                                    } catch (NumberFormatException e) {
                                        sendMessage(userId, "❌ Invalid ID");
                                    }
                                }
                                break;
                            case "removeuser":
                                if (parts.length > 1) {
                                    try {
                                        long uid = Long.parseLong(parts[1]);
                                        WhitelistManager.removeUser(uid);
                                        threadManager.stopUserParser(uid);
                                        sendMessage(userId, "✅ User removed");
                                    } catch (NumberFormatException e) {
                                        sendMessage(userId, "❌ Invalid ID");
                                    }
                                }
                                break;
                        }
                    }
                
                    protected void sendMessage(long userId, String text) {
                        SendMessage msg = new SendMessage(String.valueOf(userId), text);
                        msg.enableMarkdown(true);
                        try {
                            execute(msg);
                        } catch (TelegramApiException e) {
                            logger.error("Failed to send message: {}", e.getMessage());
                        }
                    }
                
                    @Override
                    public String getBotUsername() {
                        return Config.getTelegramBotUsername();
                    }
                }
                ----------------------------------------

            [FILE] Main.java
              Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/Main.java
              Размер: 5910 байт
              Дата изменения: 2026-01-19T22:48:19.944205971Z
              Содержимое:
              ----------------------------------------
              package com.parser;
              
              import com.parser.config.Config;
              import com.parser.core.ThreadManager;
              import com.parser.service.CookieService;
              import com.parser.storage.FileStorage;
              import com.parser.storage.WhitelistManager;
              import com.parser.telegram.TelegramBotService;
              import com.parser.telegram.TelegramNotificationService;
              import org.slf4j.Logger;
              import org.slf4j.LoggerFactory;
              import org.telegram.telegrambots.meta.TelegramBotsApi;
              import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
              import org.telegram.telegrambots.updatesreceivers.DefaultBotSession;
              
              /**
               * Главный класс приложения - точка входа
               */
              public class Main {
                  private static final Logger logger = LoggerFactory.getLogger(Main.class);
                  private static ThreadManager threadManager;
                  private static TelegramBotService botService;
              
                  public static void main(String[] args) {
                      try {
                          logger.info("=".repeat(60));
                          logger.info("Product Parser with Real-Time Cookies");
                          logger.info("=".repeat(60));
              
                          // Проверка конфигурации
                          String botToken = Config.getTelegramBotToken();
                          String botUsername = Config.getTelegramBotUsername();
              
                          if (botToken.isEmpty() || botToken.equals("ВАШ_ТОКЕН_БОТА")) {
                              logger.error("❌ Bot token not configured!");
                              System.exit(1);
                          }
              
                          logger.info("✅ Configuration:");
                          logger.info("   Token: {}...", botToken.substring(0, 10));
                          logger.info("   Username: @{}", botUsername);
                          logger.info("   Admin ID: {}", Config.getTelegramAdminId());
              
                          // Инициализация хранилища
                          FileStorage.ensureDataDir();
                          logger.info("✅ Data directory ready");
              
                          // Инициализация системы cookies
                          logger.info("🍪 Инициализация системы cookies...");
                          CookieService.initialize();
              
                          // Тестирование cookies
                          logger.info("🧪 Тестирование cookies...");
                          if (!CookieService.testCookies()) {
                              logger.warn("⚠️ Предупреждение: cookies могут быть недействительны");
                          } else {
                              logger.info("✅ Cookies работают корректно");
                          }
              
                          // Инициализация менеджера потоков
                          threadManager = new ThreadManager();
                          logger.info("✅ ThreadManager initialized");
              
                          // Инициализация Telegram бота
                          initializeTelegramBot(botToken);
              
                          logger.info("=".repeat(60));
                          logger.info("✅ Application started successfully!");
                          logger.info("👑 Admin ID: {}", Config.getTelegramAdminId());
                          logger.info("🍪 Dynamic cookies: {}", Config.isDynamicCookiesEnabled());
                          logger.info("📋 Users: {}", WhitelistManager.getUserCount());
                          logger.info("=".repeat(60));
              
                          // Добавляем shutdown hook
                          Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                              logger.info("🛑 Получен сигнал завершения...");
                              shutdown();
                          }));
              
                          keepApplicationRunning();
              
                      } catch (Exception e) {
                          logger.error("❌ Startup error: {}", e.getMessage(), e);
                          shutdown();
                          System.exit(1);
                      }
                  }
              
                  private static void initializeTelegramBot(String botToken) throws TelegramApiException {
                      logger.info("🤖 Initializing Telegram bot...");
              
                      botService = new TelegramBotService(botToken, threadManager);
                      TelegramNotificationService.setBotInstance(botService);
              
                      TelegramBotsApi botsApi = new TelegramBotsApi(DefaultBotSession.class);
                      botsApi.registerBot(botService);
              
                      logger.info("✅ Telegram bot registered and running");
                  }
              
                  private static void keepApplicationRunning() {
                      try {
                          logger.info("⏳ Application is running...");
              
                          long lastStatusLog = System.currentTimeMillis();
                          long lastCookieCheck = System.currentTimeMillis();
              
                          while (true) {
                              Thread.sleep(30000); // Проверка каждые 30 секунд
              
                              long now = System.currentTimeMillis();
              
                              // Логирование статуса каждые 5 минут
                              if (now - lastStatusLog > 5 * 60 * 1000) {
                                  if (threadManager.getActiveUsers().size() > 0) {
                                      logger.info("📊 Active users: {}", threadManager.getActiveUsers().size());
                                  }
                                  lastStatusLog = now;
                              }
              
                              // Проверка cookies каждые 30 минут
                              if (now - lastCookieCheck > 30 * 60 * 1000) {
                                  logger.info("🔄 Проверка состояния cookies...");
                                  if (!CookieService.hasValidCookies()) {
                                      logger.warn("⚠️ Cookies недействительны, обновление...");
                                      CookieService.refreshCookies("www.goofish.com");
                                  }
                                  lastCookieCheck = now;
                              }
                          }
                      } catch (InterruptedException e) {
                          Thread.currentThread().interrupt();
                          logger.info("Application interrupted");
                      }
                  }
              
                  private static void shutdown() {
                      logger.info("🛑 Shutting down...");
              
                      if (threadManager != null) {
                          threadManager.shutdown();
                      }
              
                      // Останавливаем CookieService
                      CookieService.shutdown();
              
                      logger.info("✅ Shutdown complete");
                  }
              }
              ----------------------------------------
            [DIR] model

              [FILE] Product.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/model/Product.java
                Размер: 7226 байт
                Дата изменения: 2026-01-19T09:31:29.769232796Z
                Содержимое:
                ----------------------------------------
                package com.parser.model;
                
                import com.fasterxml.jackson.annotation.JsonIgnore;
                import com.fasterxml.jackson.annotation.JsonProperty;
                import com.parser.config.ParserSettings;
                import java.util.ArrayList;
                import java.util.List;
                
                /**
                 * Класс, представляющий товар
                 */
                public class Product {
                    private String id;
                    private String title;
                    private double price;
                    private String url;
                    private String site;
                    private String location;
                    private int ageMinutes;
                    private String query;
                    private List<String> images;
                    private String seller;
                    private String sellerRating;
                    private String category;
                    private boolean isNew;
                    private long foundTimestamp;
                
                    public Product() {
                        this.images = new ArrayList<>();
                        this.isNew = true;
                        this.foundTimestamp = System.currentTimeMillis();
                    }
                
                    public Product(String id, String title, double price, String url, String site,
                                   String location, int ageMinutes, String query) {
                        this();
                        this.id = id;
                        this.title = title;
                        this.price = price;
                        this.url = url;
                        this.site = site;
                        this.location = location;
                        this.ageMinutes = ageMinutes;
                        this.query = query;
                    }
                
                    // Геттеры и сеттеры
                
                    @JsonProperty("id")
                    public String getId() {
                        return id;
                    }
                
                    public void setId(String id) {
                        this.id = id;
                    }
                
                    @JsonProperty("title")
                    public String getTitle() {
                        return title;
                    }
                
                    public void setTitle(String title) {
                        if (title == null) {
                            this.title = "Без названия";
                        } else if (title.length() > 200) {
                            this.title = title.substring(0, 197) + "...";
                        } else {
                            this.title = title.trim();
                        }
                    }
                
                    @JsonProperty("price")
                    public double getPrice() {
                        return price;
                    }
                
                    public void setPrice(double price) {
                        this.price = Math.max(0, price);
                    }
                
                    @JsonProperty("url")
                    public String getUrl() {
                        return url;
                    }
                
                    public void setUrl(String url) {
                        this.url = url;
                    }
                
                    @JsonProperty("site")
                    public String getSite() {
                        return site;
                    }
                
                    public void setSite(String site) {
                        this.site = site;
                    }
                
                    @JsonProperty("location")
                    public String getLocation() {
                        return location;
                    }
                
                    public void setLocation(String location) {
                        this.location = location;
                    }
                
                    @JsonProperty("ageMinutes")
                    public int getAgeMinutes() {
                        return ageMinutes;
                    }
                
                    public void setAgeMinutes(int ageMinutes) {
                        this.ageMinutes = Math.max(0, ageMinutes);
                    }
                
                    @JsonProperty("query")
                    public String getQuery() {
                        return query;
                    }
                
                    public void setQuery(String query) {
                        this.query = query;
                    }
                
                    @JsonProperty("images")
                    public List<String> getImages() {
                        return new ArrayList<>(images);
                    }
                
                    public void setImages(List<String> images) {
                        this.images = new ArrayList<>(images);
                    }
                
                    public void addImage(String image) {
                        if (image != null && !image.trim().isEmpty()) {
                            this.images.add(image.trim());
                        }
                    }
                
                    @JsonProperty("seller")
                    public String getSeller() {
                        return seller;
                    }
                
                    public void setSeller(String seller) {
                        this.seller = seller;
                    }
                
                    @JsonProperty("sellerRating")
                    public String getSellerRating() {
                        return sellerRating;
                    }
                
                    public void setSellerRating(String sellerRating) {
                        this.sellerRating = sellerRating;
                    }
                
                    @JsonProperty("category")
                    public String getCategory() {
                        return category;
                    }
                
                    public void setCategory(String category) {
                        this.category = category;
                    }
                
                    @JsonProperty("isNew")
                    public boolean isNew() {
                        return isNew;
                    }
                
                    public void setNew(boolean isNew) {
                        this.isNew = isNew;
                    }
                
                    @JsonProperty("foundTimestamp")
                    public long getFoundTimestamp() {
                        return foundTimestamp;
                    }
                
                    public void setFoundTimestamp(long foundTimestamp) {
                        this.foundTimestamp = foundTimestamp;
                    }
                
                    // Методы для конвертации цены
                
                    @JsonIgnore
                    public double getPriceRubles() {
                        return Math.round(price * ParserSettings.getCurrencyRate(
                                ParserSettings.CURRENCY_YUAN, ParserSettings.CURRENCY_RUBLES) * 100.0) / 100.0;
                    }
                
                    @JsonIgnore
                    public String getPriceDisplay() {
                        return String.format("%.2f ¥", price);
                    }
                
                    @JsonIgnore
                    public String getPriceDisplayRub() {
                        return String.format("%.2f руб.", getPriceRubles());
                    }
                
                    @JsonIgnore
                    public String getFormattedPrice(String currency) {
                        if (ParserSettings.CURRENCY_RUBLES.equals(currency)) {
                            return getPriceDisplayRub();
                        } else {
                            return getPriceDisplay();
                        }
                    }
                
                    // Методы для удобства
                
                    @JsonIgnore
                    public String getShortTitle() {
                        if (title.length() <= 50) {
                            return title;
                        }
                        return title.substring(0, 47) + "...";
                    }
                
                    @JsonIgnore
                    public String getAgeDisplay() {
                        if (ageMinutes < 60) {
                            return ageMinutes + " мин";
                        } else if (ageMinutes < 1440) {
                            return (ageMinutes / 60) + " ч";
                        } else {
                            return (ageMinutes / 1440) + " дн";
                        }
                    }
                
                    @JsonIgnore
                    public boolean hasImages() {
                        return !images.isEmpty();
                    }
                
                    @JsonIgnore
                    public String getMainImage() {
                        return images.isEmpty() ? null : images.get(0);
                    }
                
                    // НОВЫЙ МЕТОД: Получение URL обложки (первого изображения)
                    @JsonIgnore
                    public String getCoverImageUrl() {
                        if (images != null && !images.isEmpty()) {
                            return images.get(0);
                        }
                        return null;
                    }
                
                    // НОВЫЙ МЕТОД: Проверка наличия обложки
                    @JsonIgnore
                    public boolean hasCoverImage() {
                        return getCoverImageUrl() != null;
                    }
                
                    // Методы для сериализации
                
                    @JsonIgnore
                    public String toJsonString() {
                        return String.format(
                                "{\"id\":\"%s\",\"title\":\"%s\",\"price\":%.2f,\"url\":\"%s\",\"age\":%d}",
                                id, title.replace("\"", "\\\""), price, url, ageMinutes
                        );
                    }
                
                    @JsonIgnore
                    public String toCsvString() {
                        return String.format("%s,\"%s\",%.2f,%s,%s,%d",
                                id, title.replace("\"", "\"\""), price, url, location, ageMinutes);
                    }
                
                    @Override
                    public String toString() {
                        return String.format("Product{id='%s', title='%s', price=%.2f¥, age=%dmin, location=%s}",
                                id, getShortTitle(), price, ageMinutes, location);
                    }
                
                    @Override
                    public boolean equals(Object obj) {
                        if (this == obj) return true;
                        if (obj == null || getClass() != obj.getClass()) return false;
                        Product product = (Product) obj;
                        return id != null && id.equals(product.id);
                    }
                
                    @Override
                    public int hashCode() {
                        return id != null ? id.hashCode() : 0;
                    }
                }
                ----------------------------------------

              [FILE] UserSettings.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/model/UserSettings.java
                Размер: 8532 байт
                Дата изменения: 2026-01-19T09:31:29.769761421Z
                Содержимое:
                ----------------------------------------
                package com.parser.model;
                
                import com.fasterxml.jackson.annotation.JsonIgnore;
                import com.fasterxml.jackson.annotation.JsonProperty;
                import com.parser.config.ParserSettings;
                import java.io.Serializable;
                
                /**
                 * Класс настроек пользователя для парсера
                 */
                public class UserSettings implements Serializable {
                    private static final long serialVersionUID = 1L;
                
                    // Основные настройки
                    private int checkInterval = 300; // секунды
                    private int maxAgeMinutes = 1440; // 24 часа
                    private int maxPages = 3;
                    private int rowsPerPage = 100;
                
                    // Валютные настройки
                    private String priceCurrency = ParserSettings.CURRENCY_RUBLES;
                
                    // Настройки уведомлений
                    private boolean notifyNewOnly = true;
                    private boolean notifyTelegram = true;
                    private boolean notifyEmail = false;
                    private boolean notifySound = true;
                
                    // Настройки фильтрации
                    private double minPrice = 0;
                    private double maxPrice = 0; // 0 = без ограничения
                    private String[] locations = {};
                    private String[] excludedKeywords = {};
                
                    // Расширенные настройки
                    private boolean enableProxy = false;
                    private String proxyAddress = "";
                    private int proxyPort = 0;
                    private int requestDelay = 2000; // мс
                    private int maxRetries = 3;
                
                    public UserSettings() {
                        // Конструктор по умолчанию
                    }
                
                    // Геттеры и сеттеры с валидацией
                
                    @JsonProperty("checkInterval")
                    public int getCheckInterval() {
                        return checkInterval;
                    }
                
                    public void setCheckInterval(int checkInterval) {
                        this.checkInterval = ParserSettings.normalizeCheckInterval(checkInterval);
                    }
                
                    @JsonProperty("maxAgeMinutes")
                    public int getMaxAgeMinutes() {
                        return maxAgeMinutes;
                    }
                
                    public void setMaxAgeMinutes(int maxAgeMinutes) {
                        this.maxAgeMinutes = ParserSettings.normalizeMaxAge(maxAgeMinutes);
                    }
                
                    @JsonProperty("maxPages")
                    public int getMaxPages() {
                        return maxPages;
                    }
                
                    public void setMaxPages(int maxPages) {
                        this.maxPages = Math.max(ParserSettings.MIN_MAX_PAGES,
                                Math.min(maxPages, ParserSettings.MAX_MAX_PAGES));
                    }
                
                    @JsonProperty("rowsPerPage")
                    public int getRowsPerPage() {
                        return rowsPerPage;
                    }
                
                    public void setRowsPerPage(int rowsPerPage) {
                        this.rowsPerPage = Math.max(ParserSettings.MIN_ROWS_PER_PAGE,
                                Math.min(rowsPerPage, ParserSettings.MAX_ROWS_PER_PAGE));
                    }
                
                    @JsonProperty("priceCurrency")
                    public String getPriceCurrency() {
                        return priceCurrency;
                    }
                
                    public void setPriceCurrency(String priceCurrency) {
                        if (ParserSettings.CURRENCY_YUAN.equals(priceCurrency) ||
                                ParserSettings.CURRENCY_RUBLES.equals(priceCurrency)) {
                            this.priceCurrency = priceCurrency;
                        }
                    }
                
                    @JsonProperty("notifyNewOnly")
                    public boolean isNotifyNewOnly() {
                        return notifyNewOnly;
                    }
                
                    public void setNotifyNewOnly(boolean notifyNewOnly) {
                        this.notifyNewOnly = notifyNewOnly;
                    }
                
                    @JsonProperty("notifyTelegram")
                    public boolean isNotifyTelegram() {
                        return notifyTelegram;
                    }
                
                    public void setNotifyTelegram(boolean notifyTelegram) {
                        this.notifyTelegram = notifyTelegram;
                    }
                
                    @JsonProperty("notifyEmail")
                    public boolean isNotifyEmail() {
                        return notifyEmail;
                    }
                
                    public void setNotifyEmail(boolean notifyEmail) {
                        this.notifyEmail = notifyEmail;
                    }
                
                    @JsonProperty("notifySound")
                    public boolean isNotifySound() {
                        return notifySound;
                    }
                
                    public void setNotifySound(boolean notifySound) {
                        this.notifySound = notifySound;
                    }
                
                    @JsonProperty("minPrice")
                    public double getMinPrice() {
                        return minPrice;
                    }
                
                    public void setMinPrice(double minPrice) {
                        this.minPrice = Math.max(0, minPrice);
                    }
                
                    @JsonProperty("maxPrice")
                    public double getMaxPrice() {
                        return maxPrice;
                    }
                
                    public void setMaxPrice(double maxPrice) {
                        this.maxPrice = maxPrice < 0 ? 0 : maxPrice;
                    }
                
                    @JsonProperty("locations")
                    public String[] getLocations() {
                        return locations != null ? locations.clone() : new String[0];
                    }
                
                    public void setLocations(String[] locations) {
                        this.locations = locations != null ? locations.clone() : new String[0];
                    }
                
                    @JsonProperty("excludedKeywords")
                    public String[] getExcludedKeywords() {
                        return excludedKeywords != null ? excludedKeywords.clone() : new String[0];
                    }
                
                    public void setExcludedKeywords(String[] excludedKeywords) {
                        this.excludedKeywords = excludedKeywords != null ? excludedKeywords.clone() : new String[0];
                    }
                
                    @JsonProperty("enableProxy")
                    public boolean isEnableProxy() {
                        return enableProxy;
                    }
                
                    public void setEnableProxy(boolean enableProxy) {
                        this.enableProxy = enableProxy;
                    }
                
                    @JsonProperty("proxyAddress")
                    public String getProxyAddress() {
                        return proxyAddress;
                    }
                
                    public void setProxyAddress(String proxyAddress) {
                        this.proxyAddress = proxyAddress != null ? proxyAddress.trim() : "";
                    }
                
                    @JsonProperty("proxyPort")
                    public int getProxyPort() {
                        return proxyPort;
                    }
                
                    public void setProxyPort(int proxyPort) {
                        this.proxyPort = Math.max(0, Math.min(proxyPort, 65535));
                    }
                
                    @JsonProperty("requestDelay")
                    public int getRequestDelay() {
                        return requestDelay;
                    }
                
                    public void setRequestDelay(int requestDelay) {
                        this.requestDelay = Math.max(500, Math.min(requestDelay, 10000));
                    }
                
                    @JsonProperty("maxRetries")
                    public int getMaxRetries() {
                        return maxRetries;
                    }
                
                    public void setMaxRetries(int maxRetries) {
                        this.maxRetries = Math.max(0, Math.min(maxRetries, 10));
                    }
                
                    // Методы для удобства
                
                    @JsonIgnore
                    public boolean hasPriceFilter() {
                        return maxPrice > 0 && maxPrice > minPrice;
                    }
                
                    @JsonIgnore
                    public boolean hasLocationFilter() {
                        return locations != null && locations.length > 0;
                    }
                
                    @JsonIgnore
                    public boolean hasKeywordFilter() {
                        return excludedKeywords != null && excludedKeywords.length > 0;
                    }
                
                    @JsonIgnore
                    public boolean isPriceInRange(double price) {
                        if (minPrice > 0 && price < minPrice) {
                            return false;
                        }
                        if (maxPrice > 0 && price > maxPrice) {
                            return false;
                        }
                        return true;
                    }
                
                    @JsonIgnore
                    public boolean isLocationAllowed(String location) {
                        if (!hasLocationFilter()) {
                            return true;
                        }
                
                        if (location == null || location.trim().isEmpty()) {
                            return false;
                        }
                
                        String locationLower = location.toLowerCase();
                        for (String allowedLocation : locations) {
                            if (locationLower.contains(allowedLocation.toLowerCase())) {
                                return true;
                            }
                        }
                
                        return false;
                    }
                
                    @JsonIgnore
                    public boolean isKeywordAllowed(String text) {
                        if (!hasKeywordFilter() || text == null) {
                            return true;
                        }
                
                        String textLower = text.toLowerCase();
                        for (String keyword : excludedKeywords) {
                            if (keyword != null && !keyword.trim().isEmpty() &&
                                    textLower.contains(keyword.toLowerCase())) {
                                return false;
                            }
                        }
                
                        return true;
                    }
                
                    @JsonIgnore
                    public boolean isValid() {
                        return ParserSettings.isValidCheckInterval(checkInterval) &&
                                ParserSettings.isValidMaxAge(maxAgeMinutes) &&
                                maxPages >= ParserSettings.MIN_MAX_PAGES &&
                                rowsPerPage >= ParserSettings.MIN_ROWS_PER_PAGE;
                    }
                
                    @JsonIgnore
                    public String getSummary() {
                        return String.format(
                                "Интервал: %d сек, Возраст: %d мин, Страниц: %d, Товаров на странице: %d",
                                checkInterval, maxAgeMinutes, maxPages, rowsPerPage
                        );
                    }
                
                    @Override
                    public String toString() {
                        return String.format(
                                "UserSettings{checkInterval=%d, maxAge=%d, maxPages=%d, rowsPerPage=%d}",
                                checkInterval, maxAgeMinutes, maxPages, rowsPerPage
                        );
                    }
                }
                ----------------------------------------
            [DIR] service

              [FILE] CookieService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/CookieService.java
                Размер: 16673 байт
                Дата изменения: 2026-01-19T22:46:43.647336526Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import com.parser.config.Config;
                import com.parser.config.CookieConfig;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.io.FileOutputStream;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                import java.util.concurrent.Executors;
                import java.util.concurrent.ScheduledExecutorService;
                import java.util.concurrent.TimeUnit;
                
                /**
                 * Сервис для работы с cookies через Selenium
                 */
                public class CookieService {
                    private static final Logger logger = LoggerFactory.getLogger(CookieService.class);
                
                    // Кэш cookies для доменов
                    private static final Map<String, Map<String, String>> cookieCache = new ConcurrentHashMap<>();
                    private static final Map<String, Long> cacheTimestamp = new ConcurrentHashMap<>();
                    private static final long CACHE_TTL = 30 * 60 * 1000; // 30 минут
                
                    private static long lastRefreshTime = 0;
                    private static final long REFRESH_INTERVAL = 120 * 60 * 1000; // 2 часа
                
                    private static ScheduledExecutorService scheduler;
                
                    // Основные домены для Goofish
                    private static final String PRIMARY_DOMAIN = "www.goofish.com";
                    private static final String API_DOMAIN = "h5api.m.goofish.com";
                    private static final String M_DOMAIN = "m.goofish.com";
                
                    /**
                     * Инициализация сервиса
                     */
                    public static synchronized void initialize() {
                        if (scheduler != null && !scheduler.isShutdown()) {
                            return;
                        }
                
                        logger.info("🍪 Инициализация CookieService...");
                
                        // Создаем планировщик для автообновления
                        scheduler = Executors.newScheduledThreadPool(1);
                
                        // Автообновление cookies каждые 2 часа
                        if (Config.getBoolean("cookie.auto.update", true)) {
                            int interval = Config.getInt("cookie.update.interval.minutes", 120);
                            scheduler.scheduleAtFixedRate(() -> {
                                try {
                                    logger.info("🔄 Автообновление cookies...");
                                    if (refreshCookies(PRIMARY_DOMAIN)) {
                                        logger.info("✅ Cookies успешно обновлены");
                                    } else {
                                        logger.warn("⚠️ Автообновление cookies не удалось");
                                    }
                                } catch (Exception e) {
                                    logger.error("❌ Ошибка при автообновлении cookies: {}", e.getMessage());
                                }
                            }, interval, interval, TimeUnit.MINUTES);
                
                            logger.info("✅ Автообновление настроено: каждые {} минут", interval);
                        }
                
                        // Предварительная загрузка cookies
                        try {
                            logger.info("🔄 Предварительная загрузка cookies...");
                            getFreshCookies(PRIMARY_DOMAIN);
                        } catch (Exception e) {
                            logger.error("❌ Ошибка предварительной загрузки cookies: {}", e.getMessage());
                        }
                
                        logger.info("✅ CookieService инициализирован");
                    }
                
                    /**
                     * Получение свежих cookies для домена
                     */
                    public static Map<String, String> getFreshCookies(String domain) {
                        if (!Config.isDynamicCookiesEnabled()) {
                            logger.debug("🍪 Динамические cookies отключены, используем статические");
                            return getCookiesFromConfig(domain);
                        }
                
                        // Проверяем кэш
                        if (cookieCache.containsKey(domain) && cacheTimestamp.containsKey(domain)) {
                            long cacheAge = System.currentTimeMillis() - cacheTimestamp.get(domain);
                            if (cacheAge < CACHE_TTL) {
                                logger.debug("🍪 Используем кэшированные cookies для {} (возраст: {} мин)",
                                        domain, cacheAge / (60 * 1000));
                                return new HashMap<>(cookieCache.get(domain));
                            } else {
                                logger.debug("🍪 Кэш cookies для {} устарел (возраст: {} мин)",
                                        domain, cacheAge / (60 * 1000));
                            }
                        }
                
                        logger.info("🔄 Получение свежих cookies для {}", domain);
                
                        // Получаем куки из конфига как fallback
                        Map<String, String> configCookies = getCookiesFromConfig(domain);
                
                        try {
                            // Получаем свежие cookies через Selenium
                            Map<String, String> freshCookies = SeleniumCookieFetcher.getFreshCookies();
                
                            if (SeleniumCookieFetcher.validateCookies(freshCookies)) {
                                // Сохраняем для всех доменов Goofish
                                updateCookieConfigForAllDomains(freshCookies);
                
                                // Обновляем кэш
                                cookieCache.put(PRIMARY_DOMAIN, new HashMap<>(freshCookies));
                                cookieCache.put(API_DOMAIN, new HashMap<>(freshCookies));
                                cookieCache.put(M_DOMAIN, new HashMap<>(freshCookies));
                
                                cacheTimestamp.put(PRIMARY_DOMAIN, System.currentTimeMillis());
                                cacheTimestamp.put(API_DOMAIN, System.currentTimeMillis());
                                cacheTimestamp.put(M_DOMAIN, System.currentTimeMillis());
                
                                lastRefreshTime = System.currentTimeMillis();
                
                                logger.info("✅ Получены свежие cookies, {} элементов", freshCookies.size());
                                return freshCookies;
                            } else {
                                logger.warn("⚠️ Валидация свежих cookies не пройдена, используем кэшированные");
                                if (!configCookies.isEmpty()) {
                                    return configCookies;
                                }
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка получения свежих cookies: {}", e.getMessage());
                            if (!configCookies.isEmpty()) {
                                logger.info("🍪 Используем cookies из конфига");
                                return configCookies;
                            }
                        }
                
                        logger.warn("⚠️ Не удалось получить cookies, возвращаем пустые");
                        return new HashMap<>();
                    }
                
                    /**
                     * Принудительное обновление cookies
                     */
                    public static boolean refreshCookies(String domain) {
                        logger.info("🔄 Принудительное обновление cookies для: {}", domain);
                
                        try {
                            Map<String, String> freshCookies = SeleniumCookieFetcher.getFreshCookies();
                
                            if (SeleniumCookieFetcher.validateCookies(freshCookies)) {
                                updateCookieConfigForAllDomains(freshCookies);
                
                                // Обновляем кэш
                                cookieCache.put(PRIMARY_DOMAIN, new HashMap<>(freshCookies));
                                cookieCache.put(API_DOMAIN, new HashMap<>(freshCookies));
                                cookieCache.put(M_DOMAIN, new HashMap<>(freshCookies));
                
                                cacheTimestamp.put(PRIMARY_DOMAIN, System.currentTimeMillis());
                                cacheTimestamp.put(API_DOMAIN, System.currentTimeMillis());
                                cacheTimestamp.put(M_DOMAIN, System.currentTimeMillis());
                
                                lastRefreshTime = System.currentTimeMillis();
                
                                logger.info("✅ Cookies успешно обновлены, {} элементов", freshCookies.size());
                                return true;
                            } else {
                                logger.error("❌ Валидация cookies не пройдена");
                                return false;
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка обновления cookies: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Обновление cookies через GUI (для отладки)
                     */
                    public static boolean refreshCookiesWithGUI(String domain) {
                        logger.info("🔄 Обновление cookies через GUI для: {}", domain);
                
                        try {
                            Map<String, String> freshCookies = SeleniumCookieFetcher.getFreshCookiesWithGUI();
                
                            if (SeleniumCookieFetcher.validateCookies(freshCookies)) {
                                updateCookieConfigForAllDomains(freshCookies);
                                lastRefreshTime = System.currentTimeMillis();
                                logger.info("✅ Cookies обновлены через GUI");
                                return true;
                            } else {
                                logger.error("❌ Валидация не пройдена");
                                return false;
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка обновления cookies через GUI: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Получение строки cookies для HTTP заголовка
                     */
                    public static String getCookieHeader(String domain) {
                        Map<String, String> cookies = getFreshCookies(domain);
                        return cookiesToHeaderString(cookies);
                    }
                
                    /**
                     * Очистка кэша
                     */
                    public static void clearCache() {
                        cookieCache.clear();
                        cacheTimestamp.clear();
                        lastRefreshTime = 0;
                        logger.info("🧹 Кэш cookies очищен");
                    }
                
                    /**
                     * Получение статистики
                     */
                    public static Map<String, Object> getCacheStats() {
                        Map<String, Object> stats = new HashMap<>();
                        stats.put("lastRefreshTime", new Date(lastRefreshTime));
                        stats.put("refreshIntervalMinutes", REFRESH_INTERVAL / 60000);
                        stats.put("cacheTTLMinutes", CACHE_TTL / 60000);
                        stats.put("cachedDomains", cookieCache.size());
                        stats.put("dynamicCookiesEnabled", Config.isDynamicCookiesEnabled());
                
                        List<String> cachedDomains = new ArrayList<>();
                        for (Map.Entry<String, Long> entry : cacheTimestamp.entrySet()) {
                            long age = System.currentTimeMillis() - entry.getValue();
                            cachedDomains.add(String.format("%s (возраст: %d мин)",
                                    entry.getKey(), age / (60 * 1000)));
                        }
                        stats.put("cachedDomainsInfo", cachedDomains);
                
                        return stats;
                    }
                
                    /**
                     * Тестирование cookies
                     */
                    public static boolean testCookies() {
                        try {
                            String cookieHeader = getCookieHeader(PRIMARY_DOMAIN);
                
                            if (cookieHeader == null || cookieHeader.isEmpty()) {
                                logger.error("❌ Cookies пусты");
                                return false;
                            }
                
                            logger.info("✅ Cookies доступны, длина: {} символов", cookieHeader.length());
                
                            Map<String, String> cookies = getFreshCookies(PRIMARY_DOMAIN);
                            logger.info("📊 Ключевые cookies:");
                
                            // Проверяем ключевые cookies
                            String[] keyNames = {"_m_h5_tk", "_tb_token_", "cna", "cookie2", "t"};
                            for (String key : keyNames) {
                                if (cookies.containsKey(key)) {
                                    String value = cookies.get(key);
                                    logger.info("   {}: {}", key,
                                            value.length() > 30 ? value.substring(0, 27) + "..." : value);
                                } else {
                                    logger.warn("   ❌ Отсутствует: {}", key);
                                }
                            }
                
                            // Проверяем _m_h5_tk
                            if (cookies.containsKey("_m_h5_tk")) {
                                String mh5tk = cookies.get("_m_h5_tk");
                                if (mh5tk.contains("_")) {
                                    String[] parts = mh5tk.split("_", 2);
                                    logger.info("📊 Анализ _m_h5_tk:");
                                    logger.info("   Токен: {}",
                                            parts[0].length() > 20 ? parts[0].substring(0, 17) + "..." : parts[0]);
                                    logger.info("   Время: {}", parts[1]);
                                }
                            }
                
                            return true;
                        } catch (Exception e) {
                            logger.error("❌ Ошибка тестирования cookies: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Завершение работы сервиса
                     */
                    public static void shutdown() {
                        if (scheduler != null) {
                            scheduler.shutdown();
                            try {
                                if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                                    scheduler.shutdownNow();
                                }
                            } catch (InterruptedException e) {
                                scheduler.shutdownNow();
                                Thread.currentThread().interrupt();
                            }
                            logger.info("🛑 CookieService остановлен");
                        }
                    }
                
                    /**
                     * Обновление конфигурации для всех доменов Goofish
                     */
                    private static void updateCookieConfigForAllDomains(Map<String, String> cookies) {
                        String cookieString = cookiesToHeaderString(cookies);
                
                        // Обновляем для всех доменов
                        CookieConfig.setCookiesForDomain(PRIMARY_DOMAIN, cookieString);
                        CookieConfig.setCookiesForDomain(API_DOMAIN, cookieString);
                        CookieConfig.setCookiesForDomain(M_DOMAIN, cookieString);
                
                        saveCookiesToProperties(cookies);
                        logger.debug("Обновлены cookies для всех доменов Goofish");
                    }
                
                    /**
                     * Сохранение cookies в файл properties
                     */
                    private static void saveCookiesToProperties(Map<String, String> cookies) {
                        try {
                            Properties props = new Properties();
                
                            String cookieString = cookiesToHeaderString(cookies);
                
                            // Сохраняем для всех доменов
                            props.setProperty("www.goofish.com.cookies", cookieString);
                            props.setProperty("h5api.m.goofish.com.cookies", cookieString);
                            props.setProperty("m.goofish.com.cookies", cookieString);
                
                            try (FileOutputStream fos = new FileOutputStream("cookies.properties")) {
                                props.store(fos, "Cookies for HTTP requests\nAuto-generated file");
                                logger.info("💾 Cookies сохранены в: cookies.properties");
                            }
                
                        } catch (Exception e) {
                            logger.error("❌ Ошибка сохранения cookies: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение cookies из конфига
                     */
                    private static Map<String, String> getCookiesFromConfig(String domain) {
                        // Пробуем основной домен, если не найдены
                        String cookieString = CookieConfig.getCookiesForDomain(domain);
                        if (cookieString == null || cookieString.isEmpty()) {
                            cookieString = CookieConfig.getCookiesForDomain(PRIMARY_DOMAIN);
                        }
                
                        Map<String, String> cookies = new HashMap<>();
                
                        if (cookieString != null && !cookieString.trim().isEmpty()) {
                            String[] cookiePairs = cookieString.split("; ");
                            for (String pair : cookiePairs) {
                                String[] parts = pair.split("=", 2);
                                if (parts.length == 2) {
                                    cookies.put(parts[0].trim(), parts[1].trim());
                                }
                            }
                        }
                
                        return cookies;
                    }
                
                    /**
                     * Преобразование Map cookies в строку для заголовка
                     */
                    private static String cookiesToHeaderString(Map<String, String> cookies) {
                        if (cookies == null || cookies.isEmpty()) {
                            return "";
                        }
                
                        StringBuilder header = new StringBuilder();
                        for (Map.Entry<String, String> entry : cookies.entrySet()) {
                            if (header.length() > 0) {
                                header.append("; ");
                            }
                            header.append(entry.getKey()).append("=").append(entry.getValue());
                        }
                        return header.toString();
                    }
                
                    /**
                     * Получение конкретного cookie
                     */
                    public static String getCookie(String domain, String cookieName) {
                        Map<String, String> cookies = getFreshCookies(domain);
                        return cookies.getOrDefault(cookieName, "");
                    }
                
                    /**
                     * Проверка, доступны ли cookies
                     */
                    public static boolean hasValidCookies() {
                        try {
                            String cookieHeader = getCookieHeader(PRIMARY_DOMAIN);
                            return cookieHeader != null && !cookieHeader.isEmpty();
                        } catch (Exception e) {
                            return false;
                        }
                    }
                }
                ----------------------------------------

              [FILE] RealTimeCookieService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/RealTimeCookieService.java
                Размер: 6976 байт
                Дата изменения: 2026-01-19T22:42:45.81948993Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import com.parser.config.Config;
                import com.parser.config.CookieConfig;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.io.FileOutputStream;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                
                /**
                 * Сервис для управления cookies в реальном времени
                 */
                public class RealTimeCookieService {
                    private static final Logger logger = LoggerFactory.getLogger(RealTimeCookieService.class);
                
                    private static final Map<String, String> currentCookies = new ConcurrentHashMap<>();
                    private static long lastUpdateTime = 0;
                    private static final long UPDATE_INTERVAL = 60 * 60 * 1000; // 1 час
                
                    // Основные домены
                    private static final String[] GOOFISH_DOMAINS = {
                            "www.goofish.com",
                            "h5api.m.goofish.com",
                            "m.goofish.com"
                    };
                
                    /**
                     * Инициализация cookies
                     */
                    public static synchronized void initialize() {
                        if (currentCookies.isEmpty() || isExpired()) {
                            refreshCookies();
                        }
                    }
                
                    /**
                     * Проверка истечения срока cookies
                     */
                    private static boolean isExpired() {
                        long now = System.currentTimeMillis();
                        return (now - lastUpdateTime) > UPDATE_INTERVAL;
                    }
                
                    /**
                     * Обновление cookies
                     */
                    public static synchronized boolean refreshCookies() {
                        logger.info("🔄 Обновление cookies через Selenium...");
                
                        try {
                            Map<String, String> freshCookies = SeleniumCookieFetcher.getFreshCookies();
                
                            if (SeleniumCookieFetcher.validateCookies(freshCookies)) {
                                currentCookies.clear();
                                currentCookies.putAll(freshCookies);
                                lastUpdateTime = System.currentTimeMillis();
                
                                // Сохраняем в конфиг
                                updateAllDomains();
                
                                // Сохраняем в файл для отладки
                                saveToJsonFile();
                
                                logger.info("✅ Cookies успешно обновлены");
                                return true;
                            } else {
                                logger.error("❌ Валидация cookies не пройдена");
                                return false;
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка обновления cookies: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Обновление конфигурации для всех доменов
                     */
                    private static void updateAllDomains() {
                        String cookieString = mapToString(currentCookies);
                
                        for (String domain : GOOFISH_DOMAINS) {
                            CookieConfig.setCookiesForDomain(domain, cookieString);
                            logger.debug("Обновлены cookies для домена: {}", domain);
                        }
                
                        // Также сохраняем в cookies.properties
                        saveToPropertiesFile();
                    }
                
                    /**
                     * Получение строки cookies для заголовка
                     */
                    public static String getCookieHeader(String domain) {
                        if (currentCookies.isEmpty() || isExpired()) {
                            refreshCookies();
                        }
                        return mapToString(currentCookies);
                    }
                
                    /**
                     * Получение конкретного cookie
                     */
                    public static String getCookie(String name) {
                        if (currentCookies.isEmpty() || isExpired()) {
                            refreshCookies();
                        }
                        return currentCookies.getOrDefault(name, "");
                    }
                
                    /**
                     * Преобразование Map в строку cookies
                     */
                    private static String mapToString(Map<String, String> cookies) {
                        if (cookies == null || cookies.isEmpty()) {
                            return "";
                        }
                
                        StringBuilder sb = new StringBuilder();
                        for (Map.Entry<String, String> entry : cookies.entrySet()) {
                            if (sb.length() > 0) {
                                sb.append("; ");
                            }
                            sb.append(entry.getKey()).append("=").append(entry.getValue());
                        }
                
                        return sb.toString();
                    }
                
                    /**
                     * Сохранение cookies в properties файл
                     */
                    private static void saveToPropertiesFile() {
                        try {
                            Properties props = new Properties();
                
                            String cookieString = mapToString(currentCookies);
                
                            // Сохраняем для всех доменов
                            for (String domain : GOOFISH_DOMAINS) {
                                props.setProperty(domain + ".cookies", cookieString);
                            }
                
                            try (FileOutputStream fos = new FileOutputStream("cookies.properties")) {
                                props.store(fos, "Auto-generated cookies for Goofish\n" + new Date());
                                logger.info("💾 Cookies сохранены в cookies.properties");
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка сохранения cookies: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Сохранение cookies в JSON файл
                     */
                    private static void saveToJsonFile() {
                        try {
                            Map<String, Object> data = new HashMap<>();
                            data.put("last_updated", new Date().toString());
                            data.put("source", "real_fetch");
                            data.put("cookies", currentCookies);
                            data.put("timestamp", System.currentTimeMillis());
                
                            String json = new com.fasterxml.jackson.databind.ObjectMapper()
                                    .writerWithDefaultPrettyPrinter()
                                    .writeValueAsString(data);
                
                            try (java.io.FileWriter fw = new java.io.FileWriter("real_cookies.json")) {
                                fw.write(json);
                                logger.info("💾 Cookies сохранены в real_cookies.json");
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка сохранения JSON cookies: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение информации о cookies
                     */
                    public static Map<String, Object> getCookieInfo() {
                        Map<String, Object> info = new HashMap<>();
                        info.put("last_update", new Date(lastUpdateTime));
                        info.put("cookie_count", currentCookies.size());
                        info.put("key_cookies", getKeyCookiesInfo());
                        info.put("domains", Arrays.asList(GOOFISH_DOMAINS));
                
                        return info;
                    }
                
                    /**
                     * Получение информации о ключевых cookies
                     */
                    private static Map<String, String> getKeyCookiesInfo() {
                        Map<String, String> keyCookies = new HashMap<>();
                
                        String[] keys = {"_m_h5_tk", "_tb_token_", "cna", "cookie2", "t"};
                        for (String key : keys) {
                            if (currentCookies.containsKey(key)) {
                                String value = currentCookies.get(key);
                                keyCookies.put(key, value.length() > 50 ? value.substring(0, 47) + "..." : value);
                            }
                        }
                
                        return keyCookies;
                    }
                }
                ----------------------------------------

              [FILE] SeleniumCookieFetcher.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/SeleniumCookieFetcher.java
                Размер: 11801 байт
                Дата изменения: 2026-01-19T22:48:05.53887146Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import io.github.bonigarcia.wdm.WebDriverManager;
                import org.openqa.selenium.*;
                import org.openqa.selenium.chrome.ChromeDriver;
                import org.openqa.selenium.chrome.ChromeOptions;
                import org.openqa.selenium.support.ui.WebDriverWait;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.time.Duration;
                import java.util.*;
                
                /**
                 * Сервис для получения cookies через Selenium
                 */
                public class SeleniumCookieFetcher {
                    private static final Logger logger = LoggerFactory.getLogger(SeleniumCookieFetcher.class);
                
                    /**
                     * Основной метод получения cookies для Goofish
                     */
                    public static Map<String, String> fetchGoofishCookies(boolean headless) {
                        logger.info("🔄 Запуск Selenium для получения cookies Goofish");
                        System.out.println("=".repeat(60));
                        System.out.println("🔄 АВТОМАТИЧЕСКОЕ ПОЛУЧЕНИЕ COOKIES GOOFISH");
                        System.out.println("=".repeat(60));
                
                        WebDriver driver = null;
                        try {
                            // 1. Настройка WebDriver
                            WebDriverManager.chromedriver().setup();
                            logger.info("✅ ChromeDriver настроен");
                
                            // 2. Конфигурация Chrome
                            ChromeOptions options = new ChromeOptions();
                
                            // Headless режим
                            if (headless) {
                                options.addArguments("--headless=new");
                                logger.info("🌐 Режим: Headless");
                            } else {
                                logger.info("🌐 Режим: С GUI (для отладки)");
                            }
                
                            // Опции для обхода защиты
                            options.addArguments("--no-sandbox");
                            options.addArguments("--disable-dev-shm-usage");
                            options.addArguments("--disable-blink-features=AutomationControlled");
                            options.addArguments("--disable-gpu");
                            options.addArguments("--window-size=1920,1080");
                            options.addArguments("--disable-features=VizDisplayCompositor");
                            options.addArguments("--disable-software-rasterizer");
                            options.addArguments("--disable-extensions");
                            options.addArguments("--disable-logging");
                            options.addArguments("--log-level=3");
                
                            // Китайский User-Agent из примера запроса
                            String userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 YaBrowser/25.10.0.0 Safari/537.36";
                            options.addArguments("--user-agent=" + userAgent);
                
                            // Убираем признаки автоматизации
                            options.setExperimentalOption("excludeSwitches", new String[]{"enable-automation"});
                            options.setExperimentalOption("useAutomationExtension", false);
                
                            // 3. Запуск браузера
                            driver = new ChromeDriver(options);
                            logger.info("✅ Браузер запущен");
                
                            // Настройка таймаутов
                            driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(30));
                            driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));
                
                            // 4. Переход на главную страницу Goofish
                            String url = "https://www.goofish.com";
                            logger.info("🌐 Переход на: {}", url);
                            driver.get(url);
                
                            // 5. Ожидание загрузки
                            logger.info("⏳ Ожидание загрузки страницы...");
                            try {
                                new WebDriverWait(driver, Duration.ofSeconds(15))
                                        .until(d -> ((JavascriptExecutor) d)
                                                .executeScript("return document.readyState").equals("complete"));
                
                                // Дополнительное ожидание для инициализации куки
                                Thread.sleep(5000);
                
                                // 6. Прокрутка для активации JavaScript
                                ((JavascriptExecutor) driver).executeScript(
                                        "window.scrollTo(0, document.body.scrollHeight * 0.3);"
                                );
                                Thread.sleep(2000);
                
                                ((JavascriptExecutor) driver).executeScript(
                                        "window.scrollTo(0, document.body.scrollHeight * 0.6);"
                                );
                                Thread.sleep(2000);
                
                                // 7. Переход на страницу поиска для получения полных куки
                                String searchUrl = "https://www.goofish.com/search?q=test&spm=a21ybx.search.searchInput.0";
                                logger.info("🔍 Переход на страницу поиска: {}", searchUrl);
                                driver.get(searchUrl);
                
                                Thread.sleep(5000);
                
                                // 8. Получение всех cookies
                                logger.info("🍪 Получение cookies...");
                                Set<Cookie> allCookies = driver.manage().getCookies();
                
                                // 9. Фильтрация и сбор важных cookies
                                Map<String, String> goofishCookies = new LinkedHashMap<>();
                
                                // Ключевые cookies из примера запроса
                                String[] importantKeys = {
                                        "_m_h5_tk", "_m_h5_tk_enc", "_samesite_flag_", "_tb_token_",
                                        "cna", "cookie2", "mtop_partitioned_detect", "t",
                                        "tfstk", "xlly_s", "x5secdata", "isg", "unb", "lgc"
                                };
                
                                for (Cookie cookie : allCookies) {
                                    String name = cookie.getName();
                                    String value = cookie.getValue();
                
                                    // Сохраняем все куки, но выделяем важные
                                    goofishCookies.put(name, value);
                
                                    // Логируем важные куки
                                    if (Arrays.asList(importantKeys).contains(name)) {
                                        logger.debug("✅ Важный cookie: {} = {}", name,
                                                value.length() > 50 ? value.substring(0, 47) + "..." : value);
                                    }
                                }
                
                                // 10. Вывод результатов
                                logger.info("📊 Результаты:");
                                logger.info("📦 Всего cookies: {}", allCookies.size());
                                logger.info("🔑 Важных cookies: {}", goofishCookies.size());
                
                                if (!goofishCookies.isEmpty()) {
                                    logger.info("🎯 Ключевые cookies:");
                                    for (String key : importantKeys) {
                                        if (goofishCookies.containsKey(key)) {
                                            String val = goofishCookies.get(key);
                                            logger.info("   {}: {}",
                                                    String.format("%-20s", key),
                                                    val.length() > 50 ? val.substring(0, 47) + "..." : val);
                                        }
                                    }
                                }
                
                                return goofishCookies;
                
                            } catch (TimeoutException e) {
                                logger.error("❌ Таймаут при загрузке страницы: {}", e.getMessage());
                                return Collections.emptyMap();
                            }
                
                        } catch (Exception e) {
                            logger.error("❌ Ошибка при получении cookies через Selenium: {}", e.getMessage());
                            e.printStackTrace();
                            return Collections.emptyMap();
                        } finally {
                            // Закрытие браузера
                            if (driver != null) {
                                try {
                                    driver.quit();
                                    logger.info("✅ Браузер закрыт");
                                } catch (Exception e) {
                                    logger.error("⚠️ Ошибка при закрытии браузера: {}", e.getMessage());
                                }
                            }
                        }
                    }
                
                    /**
                     * Получение свежих cookies (публичный метод)
                     */
                    public static Map<String, String> getFreshCookies() {
                        return fetchGoofishCookies(true);
                    }
                
                    /**
                     * Получение cookies с GUI для отладки
                     */
                    public static Map<String, String> getFreshCookiesWithGUI() {
                        return fetchGoofishCookies(false);
                    }
                
                    /**
                     * Валидация полученных cookies
                     */
                    public static boolean validateCookies(Map<String, String> cookies) {
                        if (cookies == null || cookies.isEmpty()) {
                            logger.error("❌ Cookies пусты или null");
                            return false;
                        }
                
                        // Проверяем наличие ключевых cookies
                        String[] requiredKeys = {"_m_h5_tk", "_tb_token_", "cna", "cookie2", "t"};
                        int foundCount = 0;
                
                        for (String key : requiredKeys) {
                            if (cookies.containsKey(key)) {
                                foundCount++;
                                String value = cookies.get(key);
                                logger.debug("✅ Найден {}: {}", key,
                                        value.length() > 30 ? value.substring(0, 27) + "..." : value);
                            } else {
                                logger.warn("⚠️ Отсутствует ключевой cookie: {}", key);
                            }
                        }
                
                        // Проверяем _m_h5_tk на наличие timestamp
                        if (cookies.containsKey("_m_h5_tk")) {
                            String mh5tk = cookies.get("_m_h5_tk");
                            if (mh5tk.contains("_")) {
                                String[] parts = mh5tk.split("_", 2);
                                logger.info("📊 Анализ _m_h5_tk:");
                                logger.info("   Токен: {}",
                                        parts[0].length() > 20 ? parts[0].substring(0, 17) + "..." : parts[0]);
                                logger.info("   Время: {}", parts[1]);
                            } else {
                                logger.warn("⚠️ _m_h5_tk не содержит timestamp");
                            }
                        }
                
                        boolean isValid = foundCount >= 3; // Минимум 3 ключевых cookie
                        logger.info("📊 Валидация cookies: {} (найдено {}/{} ключевых)",
                                isValid ? "✅ УСПЕХ" : "❌ ОШИБКА", foundCount, requiredKeys.length);
                
                        return isValid;
                    }
                
                    /**
                     * Тестовый метод для запуска из командной строки
                     */
                    public static void main(String[] args) {
                        System.out.println("Тестирование SeleniumCookieFetcher...");
                
                        // Тест с GUI (для отладки)
                        System.out.println("\n1. Тест с GUI:");
                        Map<String, String> guiCookies = getFreshCookiesWithGUI();
                        System.out.println("Получено cookies с GUI: " + guiCookies.size());
                
                        // Тест в headless режиме
                        System.out.println("\n2. Тест в headless режиме:");
                        Map<String, String> headlessCookies = getFreshCookies();
                        System.out.println("Получено cookies в headless: " + headlessCookies.size());
                
                        // Валидация
                        System.out.println("\n3. Валидация:");
                        boolean isValid = validateCookies(headlessCookies);
                        System.out.println("Cookies валидны: " + isValid);
                
                        if (!headlessCookies.isEmpty()) {
                            System.out.println("\n4. Пример cookies:");
                            headlessCookies.forEach((key, value) -> {
                                if (key.startsWith("_") || key.equals("cna") || key.equals("cookie2") || key.equals("t")) {
                                    System.out.println(String.format("%-20s: %s",
                                            key, value.length() > 50 ? value.substring(0, 47) + "..." : value));
                                }
                            });
                        }
                    }
                }
                ----------------------------------------

              [FILE] NotificationService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/NotificationService.java
                Размер: 6359 байт
                Дата изменения: 2026-01-19T09:31:29.773206169Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import com.parser.model.Product;
                import com.parser.telegram.TelegramNotificationService;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.List;
                import java.util.Map;
                
                /**
                 * Сервис для отправки уведомлений различными способами
                 */
                public class NotificationService {
                    private static final Logger logger = LoggerFactory.getLogger(NotificationService.class);
                
                    /**
                     * Отправка уведомления о найденных товарах
                     */
                    public static void sendProductNotification(int userId, List<Product> products, String query) {
                        if (products == null || products.isEmpty()) {
                            logger.debug("No products to notify for user {}", userId);
                            return;
                        }
                
                        logger.info("Sending product notification for user {}, query: {}, products: {}",
                                userId, query, products.size());
                
                        // Отправка через Telegram
                        sendTelegramProductNotification(userId, products, query);
                
                        // Здесь можно добавить другие способы отправки:
                        // - Email
                        // - Webhook
                        // - Discord/Slack
                        // - SMS
                    }
                
                    /**
                     * Отправка уведомления через Telegram
                     */
                    private static void sendTelegramProductNotification(int userId, List<Product> products, String query) {
                        if (products.isEmpty()) {
                            return;
                        }
                
                        try {
                            // Отправляем основное уведомление
                            TelegramNotificationService.sendProductsNotification(userId, products.size(), query);
                
                            // Отправляем детали по товарам (первые 5)
                            StringBuilder message = new StringBuilder();
                            message.append("🛍️ **Детали найденных товаров**\n\n");
                            message.append("Запрос: ").append(query).append("\n\n");
                
                            for (int i = 0; i < Math.min(products.size(), 5); i++) {
                                Product p = products.get(i);
                                message.append(i + 1).append(". ").append(p.getTitle()).append("\n");
                                message.append("   💰 ").append(p.getPriceDisplay()).append("\n");
                                message.append("   📍 ").append(p.getLocation()).append("\n");
                                message.append("   ⏳ ").append(p.getAgeMinutes()).append(" мин\n");
                                message.append("   🔗 ").append(p.getUrl()).append("\n\n");
                            }
                
                            if (products.size() > 5) {
                                message.append("... и еще ").append(products.size() - 5).append(" товаров\n");
                            }
                
                            TelegramNotificationService.sendMessage(userId, message.toString());
                
                            // Отправляем изображения первых 3 товаров
                            for (int i = 0; i < Math.min(products.size(), 3); i++) {
                                Product p = products.get(i);
                                if (p.getImages() != null && !p.getImages().isEmpty()) {
                                    // Используем метод sendPhotoWithCaption вместо sendPhoto
                                    TelegramNotificationService.sendPhotoWithCaption(userId,
                                            p.getImages().get(0),
                                            "📸 " + p.getTitle());
                                }
                            }
                
                        } catch (Exception e) {
                            logger.error("Error sending Telegram notification for user {}: {}",
                                    userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Отправка уведомления об ошибке
                     */
                    public static void sendErrorNotification(int userId, String errorMessage) {
                        logger.error("Sending error notification to user {}: {}", userId, errorMessage);
                
                        // Отправка через Telegram
                        TelegramNotificationService.sendErrorNotification(userId, errorMessage);
                
                        // Здесь можно добавить логирование ошибки в файл или систему мониторинга
                        logErrorToFile(userId, errorMessage);
                    }
                
                    /**
                     * Отправка уведомления о состоянии системы
                     */
                    public static void sendStatusNotification(int userId, String status, String details) {
                        logger.info("Sending status notification to user {}: {}", userId, status);
                
                        TelegramNotificationService.sendStatusNotification(userId, status, details);
                    }
                
                    /**
                     * Отправка административного уведомления
                     */
                    public static void sendAdminNotification(String message) {
                        logger.info("Sending admin notification: {}", message);
                
                        TelegramNotificationService.sendAdminNotification(message);
                    }
                
                    /**
                     * Отправка тестового уведомления
                     */
                    public static boolean sendTestNotification(int userId) {
                        logger.info("Sending test notification to user {}", userId);
                
                        return TelegramNotificationService.sendTestNotification(userId);
                    }
                
                    /**
                     * Логирование ошибки в файл
                     */
                    private static void logErrorToFile(int userId, String errorMessage) {
                        // В реальном проекте здесь будет запись в лог-файл
                        String logEntry = String.format("[%s] User %d: %s",
                                new java.util.Date(), userId, errorMessage);
                
                        // Пример записи в лог
                        logger.error("User error: {}", logEntry);
                    }
                
                    /**
                     * Проверка доступности служб уведомлений
                     */
                    public static Map<String, Boolean> checkNotificationServices() {
                        Map<String, Boolean> status = new java.util.HashMap<>();
                
                        status.put("telegram", TelegramNotificationService.isBotAvailable());
                        // Здесь можно добавить проверку других сервисов
                
                        return status;
                    }
                
                    /**
                     * Получение статистики уведомлений
                     */
                    public static String getNotificationStats() {
                        // В реальном проекте здесь можно вести статистику отправленных уведомлений
                        return "Notification service is operational";
                    }
                }
                ----------------------------------------

            [FILE] ProjectStructureExporter.java
              Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/ProjectStructureExporter.java
              Размер: 5639 байт
              Дата изменения: 2026-01-18T19:50:03.384565602Z
              Содержимое:
              ----------------------------------------
              package com.parser;
              
              import java.io.*;
              import java.nio.file.*;
              import java.nio.file.attribute.BasicFileAttributes;
              
              public class ProjectStructureExporter {
                  private static final String OUTPUT_FILE = "project_structure.txt";
                  private static final String[] IGNORED_DIRS = {".git", ".idea", "target", "build", "node_modules", "out", "bin"};
                  private static final int MAX_FILE_SIZE = 1024 * 1024 * 1024; // 1MB - максимальный размер файла для чтения
              
                  public static void main(String[] args) throws IOException {
                      Path currentDir = Paths.get(".").toAbsolutePath().normalize();
                      System.out.println("Сканирую директорию: " + currentDir);
              
                      try (PrintWriter writer = new PrintWriter(new FileWriter(OUTPUT_FILE))) {
                          writer.println("СТРУКТУРА ПРОЕКТА");
                          writer.println("=================");
                          writer.println("Директория: " + currentDir);
                          writer.println("Дата создания отчета: " + java.time.LocalDateTime.now());
                          writer.println("\n" + "=".repeat(80) + "\n");
              
                          Files.walkFileTree(currentDir, new SimpleFileVisitor<Path>() {
                              private int depth = 0;
              
                              @Override
                              public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                                  // Пропускаем игнорируемые директории
                                  for (String ignored : IGNORED_DIRS) {
                                      if (dir.toString().contains(File.separator + ignored)) {
                                          return FileVisitResult.SKIP_SUBTREE;
                                      }
                                  }
              
                                  // Печатаем структуру директорий
                                  String indent = "  ".repeat(depth);
                                  writer.println(indent + "[DIR] " + dir.getFileName());
                                  depth++;
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                                  String indent = "  ".repeat(depth);
                                  String fileName = file.getFileName().toString();
              
                                  // Пропускаем сам файл отчета
                                  if (fileName.equals(OUTPUT_FILE)) {
                                      return FileVisitResult.CONTINUE;
                                  }
              
                                  writer.println("\n" + indent + "[FILE] " + fileName);
                                  writer.println(indent + "  Путь: " + file);
                                  writer.println(indent + "  Размер: " + attrs.size() + " байт");
                                  writer.println(indent + "  Дата изменения: " + attrs.lastModifiedTime());
              
                                  // Читаем содержимое текстовых файлов
                                  if (isTextFile(fileName) && attrs.size() <= MAX_FILE_SIZE) {
                                      writer.println(indent + "  Содержимое:");
                                      writer.println(indent + "  " + "-".repeat(40));
                                      try {
                                          String content = Files.readString(file);
                                          String[] lines = content.split("\n");
                                          for (int i = 0; i < Math.min(lines.length, 10000); i++) { // Ограничиваем 100 строками
                                              writer.println(indent + "  " + lines[i]);
                                          }
                                          if (lines.length > 10000) {
                                              writer.println(indent + "  ... (файл усечен, показано 100 из " + lines.length + " строк)");
                                          }
                                      } catch (IOException e) {
                                          writer.println(indent + "  Невозможно прочитать файл (возможно, бинарный)");
                                      }
                                      writer.println(indent + "  " + "-".repeat(40));
                                  } else {
                                      writer.println(indent + "  [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]");
                                  }
              
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
                                  depth--;
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult visitFileFailed(Path file, IOException exc) {
                                  writer.println("\nОшибка при доступе к файлу: " + file);
                                  return FileVisitResult.CONTINUE;
                              }
                          });
              
                          writer.println("\n" + "=".repeat(80));
                          writer.println("Отчет успешно создан!");
                      }
              
                      System.out.println("Отчет сохранен в файл: " + OUTPUT_FILE);
                  }
              
                  private static boolean isTextFile(String fileName) {
                      String[] textExtensions = {
                              ".java", ".txt", ".xml", ".html", ".htm", ".css", ".js", ".json",
                              ".properties", ".yml", ".yaml", ".md", ".gradle", ".kt", ".py",
                              ".cpp", ".c", ".h", ".hpp", ".sql", ".sh", ".bat", ".cfg", ".ini"
                      };
              
                      String lowerName = fileName.toLowerCase();
                      for (String ext : textExtensions) {
                          if (lowerName.endsWith(ext)) {
                              return true;
                          }
                      }
                      return false;
                  }
              }
              ----------------------------------------

================================================================================
Отчет успешно создан!
