СТРУКТУРА ПРОЕКТА
=================
Директория: /Users/yanmore/IdeaProjects/multiParser
Дата создания отчета: 2026-02-03T17:35:29.404280

================================================================================

[DIR] multiParser

  [FILE] cookies_backup.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_backup.json
    Размер: 234 байт
    Дата изменения: 2026-01-15T21:52:33.371178586Z
    Содержимое:
    ----------------------------------------
    {"cookie2":"5a79ddd35987b6f0","t":"1768513953364","cna":"494076cb8fea546e6cf5b1ce","_m_h5_tk_enc":"dd9f12d7ed319f2cd4f8f1ff2f0e9078","isg":"BO559b452585b8aa255d6fc31daab814","_m_h5_tk":"e9da8ac727806d44dbb99febdd72dbd9_1768513953364"}
    ----------------------------------------

  [FILE] cookies.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies.properties
    Размер: 2150 байт
    Дата изменения: 2026-02-03T07:47:32.50794749Z
    Содержимое:
    ----------------------------------------
    #Cookies for HTTP requests
    #Auto-generated file
    #Tue Feb 03 10:47:32 MSK 2026
    h5api.m.goofish.com.cookies=t\=99ab8258d2319d751803cd49ba4e02e5; cna\=BJYIIlibxg4CAbA7Aqlv+h/Y; _m_h5_tk_enc\=29070a0996475242dc8a2964c39c1759; _samesite_flag_\=true; tfstk\=g3Ctf8Nu0y3O89PQ2f23opQaijz3rJbavG7SinxihMIduihisIAMhEtd4hxguOxjkHI2jdA1SSBAj9RDj1XGH9INPdjAuP8XcisvmO23ZN7wgIZlD7Vl7iEy2Wf9GmbB_EAUCBbLZN7wgGbKjcPuMIrw3ntfcd9IREtIfnsXf2aplEmshfsfRyKeujGsCjTIOF8r5IOfcwapuHT6GdsfRyL2An_wHjKjChlApM5YQZMkSjGf9FpTNNtIGe5pWdK55ZcjG489B3_6AlKsj29AXdC3608OdaK54n1lwjsrq3LmByUK3xJ68Dk_yqE_WB92J34E4xk2Qp8pqyEZ3xJ6XeKuWSHq3pzF.; mtop_partitioned_detect\=1; _m_h5_tk\=753dfd5f0130289345219fd7af284be2_1770115209589; _tb_token_\=a4e34651a135; xlly_s\=1; cookie2\=19b2fc98042dc25f831ba8841bccf23e
    m.goofish.com.cookies=t\=99ab8258d2319d751803cd49ba4e02e5; cna\=BJYIIlibxg4CAbA7Aqlv+h/Y; _m_h5_tk_enc\=29070a0996475242dc8a2964c39c1759; _samesite_flag_\=true; tfstk\=g3Ctf8Nu0y3O89PQ2f23opQaijz3rJbavG7SinxihMIduihisIAMhEtd4hxguOxjkHI2jdA1SSBAj9RDj1XGH9INPdjAuP8XcisvmO23ZN7wgIZlD7Vl7iEy2Wf9GmbB_EAUCBbLZN7wgGbKjcPuMIrw3ntfcd9IREtIfnsXf2aplEmshfsfRyKeujGsCjTIOF8r5IOfcwapuHT6GdsfRyL2An_wHjKjChlApM5YQZMkSjGf9FpTNNtIGe5pWdK55ZcjG489B3_6AlKsj29AXdC3608OdaK54n1lwjsrq3LmByUK3xJ68Dk_yqE_WB92J34E4xk2Qp8pqyEZ3xJ6XeKuWSHq3pzF.; mtop_partitioned_detect\=1; _m_h5_tk\=753dfd5f0130289345219fd7af284be2_1770115209589; _tb_token_\=a4e34651a135; xlly_s\=1; cookie2\=19b2fc98042dc25f831ba8841bccf23e
    www.goofish.com.cookies=t\=99ab8258d2319d751803cd49ba4e02e5; cna\=BJYIIlibxg4CAbA7Aqlv+h/Y; _m_h5_tk_enc\=29070a0996475242dc8a2964c39c1759; _samesite_flag_\=true; tfstk\=g3Ctf8Nu0y3O89PQ2f23opQaijz3rJbavG7SinxihMIduihisIAMhEtd4hxguOxjkHI2jdA1SSBAj9RDj1XGH9INPdjAuP8XcisvmO23ZN7wgIZlD7Vl7iEy2Wf9GmbB_EAUCBbLZN7wgGbKjcPuMIrw3ntfcd9IREtIfnsXf2aplEmshfsfRyKeujGsCjTIOF8r5IOfcwapuHT6GdsfRyL2An_wHjKjChlApM5YQZMkSjGf9FpTNNtIGe5pWdK55ZcjG489B3_6AlKsj29AXdC3608OdaK54n1lwjsrq3LmByUK3xJ68Dk_yqE_WB92J34E4xk2Qp8pqyEZ3xJ6XeKuWSHq3pzF.; mtop_partitioned_detect\=1; _m_h5_tk\=753dfd5f0130289345219fd7af284be2_1770115209589; _tb_token_\=a4e34651a135; xlly_s\=1; cookie2\=19b2fc98042dc25f831ba8841bccf23e
    ----------------------------------------

  [FILE] pom.xml
    Путь: /Users/yanmore/IdeaProjects/multiParser/pom.xml
    Размер: 5093 байт
    Дата изменения: 2026-01-19T23:35:23.299531773Z
    Содержимое:
    ----------------------------------------
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
             http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
    
        <groupId>com.parser</groupId>
        <artifactId>product-parser</artifactId>
        <version>1.0.0</version>
        <packaging>jar</packaging>
    
        <properties>
            <maven.compiler.source>17</maven.compiler.source>
            <maven.compiler.target>17</maven.compiler.target>
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
            <selenium.version>4.20.0</selenium.version>
        </properties>
    
        <dependencies>
            <!-- HTTP клиент -->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>4.5.14</version>
            </dependency>
    
            <!-- JSON -->
            <dependency>
                <groupId>org.json</groupId>
                <artifactId>json</artifactId>
                <version>20231013</version>
            </dependency>
    
    
            <dependency>
                <groupId>io.github.bonigarcia</groupId>
                <artifactId>webdrivermanager</artifactId>
                <version>5.8.0</version>
            </dependency>
    
            <!-- Telegram -->
            <dependency>
                <groupId>org.telegram</groupId>
                <artifactId>telegrambots</artifactId>
                <version>6.8.0</version>
            </dependency>
    
            <!-- Logging -->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>1.4.11</version>
            </dependency>
    
            <!-- Jackson -->
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.15.3</version>
            </dependency>
    
            <!-- Selenium -->
            <dependency>
                <groupId>org.seleniumhq.selenium</groupId>
                <artifactId>selenium-java</artifactId>
                <version>${selenium.version}</version>
            </dependency>
    
    
            <!-- Apache Commons для удобства -->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>3.14.0</version>
            </dependency>
    
            <dependency>
                <groupId>com.github.luben</groupId>
                <artifactId>zstd-jni</artifactId>
                <version>1.5.5-5</version>
            </dependency>
    
            <!-- SLF4J API -->
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
                <version>2.0.9</version>
            </dependency>
        </dependencies>
    
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.11.0</version>
                    <configuration>
                        <source>17</source>
                        <target>17</target>
                        <encoding>UTF-8</encoding>
                    </configuration>
                </plugin>
    
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-shade-plugin</artifactId>
                    <version>3.5.0</version>
                    <executions>
                        <execution>
                            <phase>package</phase>
                            <goals>
                                <goal>shade</goal>
                            </goals>
                            <configuration>
                                <transformers>
                                    <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                        <mainClass>com.parser.Main</mainClass>
                                    </transformer>
                                </transformers>
                                <filters>
                                    <filter>
                                        <artifact>*:*</artifact>
                                        <excludes>
                                            <exclude>META-INF/*.SF</exclude>
                                            <exclude>META-INF/*.DSA</exclude>
                                            <exclude>META-INF/*.RSA</exclude>
                                            <exclude>META-INF/*.EC</exclude>
                                            <exclude>META-INF/NOTICE*</exclude>
                                            <exclude>META-INF/LICENSE*</exclude>
                                            <exclude>META-INF/versions/*</exclude>
                                            <exclude>META-INF/maven/**</exclude>
                                        </excludes>
                                    </filter>
                                </filters>
                            </configuration>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </build>
    </project>
    ----------------------------------------
  [DIR] logs

  [FILE] dependency-reduced-pom.xml
    Путь: /Users/yanmore/IdeaProjects/multiParser/dependency-reduced-pom.xml
    Размер: 2216 байт
    Дата изменения: 2026-02-03T07:45:47.103885845Z
    Содержимое:
    ----------------------------------------
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
      <modelVersion>4.0.0</modelVersion>
      <groupId>com.parser</groupId>
      <artifactId>product-parser</artifactId>
      <version>1.0.0</version>
      <build>
        <plugins>
          <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <configuration>
              <source>17</source>
              <target>17</target>
              <encoding>UTF-8</encoding>
            </configuration>
          </plugin>
          <plugin>
            <artifactId>maven-shade-plugin</artifactId>
            <version>3.5.0</version>
            <executions>
              <execution>
                <phase>package</phase>
                <goals>
                  <goal>shade</goal>
                </goals>
                <configuration>
                  <transformers>
                    <transformer>
                      <mainClass>com.parser.Main</mainClass>
                    </transformer>
                  </transformers>
                  <filters>
                    <filter>
                      <artifact>*:*</artifact>
                      <excludes>
                        <exclude>META-INF/*.SF</exclude>
                        <exclude>META-INF/*.DSA</exclude>
                        <exclude>META-INF/*.RSA</exclude>
                        <exclude>META-INF/*.EC</exclude>
                        <exclude>META-INF/NOTICE*</exclude>
                        <exclude>META-INF/LICENSE*</exclude>
                        <exclude>META-INF/versions/*</exclude>
                        <exclude>META-INF/maven/**</exclude>
                      </excludes>
                    </filter>
                  </filters>
                </configuration>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
      <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.target>17</maven.compiler.target>
        <selenium.version>4.20.0</selenium.version>
        <maven.compiler.source>17</maven.compiler.source>
      </properties>
    </project>
    ----------------------------------------

  [FILE] .gitignore
    Путь: /Users/yanmore/IdeaProjects/multiParser/.gitignore
    Размер: 0 байт
    Дата изменения: 2026-01-17T12:50:01.802474294Z
    [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]
  [DIR] .mvn
  [DIR] data

    [FILE] whitelist.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/whitelist.txt
      Размер: 136 байт
      Дата изменения: 2026-02-03T07:11:17.257484577Z
      Содержимое:
      ----------------------------------------
      # Whitelist - authorized users
      # Format: one user ID per line
      # Created: Mon Feb 02 22:30:59 MSK 2026
      
      1080595280
      1652510924
      5328022266
      ----------------------------------------
    [DIR] user_queries

      [FILE] 1080595280.txt
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_queries/1080595280.txt
        Размер: 22 байт
        Дата изменения: 2026-01-19T07:36:06.709025027Z
        Содержимое:
        ----------------------------------------
        stone island
        cav empt
        ----------------------------------------

      [FILE] 5328022266.txt
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_queries/5328022266.txt
        Размер: 23 байт
        Дата изменения: 2026-01-19T07:42:44.706382918Z
        Содержимое:
        ----------------------------------------
        number nine
        raf simons
        ----------------------------------------
    [DIR] logs
    [DIR] user_products
    [DIR] sent_products
    [DIR] user_settings

      [FILE] 6937423668.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/6937423668.json
        Размер: 334 байт
        Дата изменения: 2026-01-17T21:22:17.000818167Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":20,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":500,"priceCurrency":"rubles","notifyNewOnly":true,"notifyTelegram":true,"notifyEmail":false,"notifySound":true,"minPrice":0.0,"maxPrice":0.0,"locations":[],"excludedKeywords":[],"enableProxy":false,"proxyAddress":"","proxyPort":0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

      [FILE] 5279294557.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/5279294557.json
        Размер: 334 байт
        Дата изменения: 2026-02-02T19:34:08.646637973Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":20,"maxAgeMinutes":1440,"maxPages":20,"rowsPerPage":30,"priceCurrency":"rubles","notifyNewOnly":true,"notifyTelegram":true,"notifyEmail":false,"notifySound":true,"minPrice":0.0,"maxPrice":0.0,"locations":[],"excludedKeywords":[],"enableProxy":false,"proxyAddress":"","proxyPort":0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

      [FILE] 5328022266.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/5328022266.json
        Размер: 227 байт
        Дата изменения: 2026-01-19T07:43:10.908043946Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":300,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":100,"priceCurrency":"rubles","notifyNewOnly":true,"notifyTelegram":true,"notifyEmail":false,"minPrice":0.0,"maxPrice":0.0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

      [FILE] 1080595280.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/1080595280.json
        Размер: 335 байт
        Дата изменения: 2026-01-29T10:53:09.510649779Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":20,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":500,"priceCurrency":"rubles","notifyNewOnly":false,"notifyTelegram":true,"notifyEmail":false,"notifySound":true,"minPrice":0.0,"maxPrice":0.0,"locations":[],"excludedKeywords":[],"enableProxy":false,"proxyAddress":"","proxyPort":0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

    [FILE] user_6937423668_queries.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_6937423668_queries.txt
      Размер: 13 байт
      Дата изменения: 2026-01-17T15:22:23.938396657Z
      Содержимое:
      ----------------------------------------
      stone island
      ----------------------------------------
    [DIR] data

      [FILE] whitelist.txt
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/data/whitelist.txt
        Размер: 114 байт
        Дата изменения: 2026-01-20T08:42:33.667681455Z
        Содержимое:
        ----------------------------------------
        # Whitelist - authorized users
        # Format: one user ID per line
        # Created: Tue Jan 20 11:42:33 MSK 2026
        
        1080595280
        ----------------------------------------
      [DIR] sent_products

        [FILE] user_5279294557.txt
          Путь: /Users/yanmore/IdeaProjects/multiParser/data/data/sent_products/user_5279294557.txt
          Размер: 10682 байт
          Дата изменения: 2026-02-02T20:15:54.720529502Z
          Содержимое:
          ----------------------------------------
          1020356812979
          1018046227667
          1019536529140
          1018001467436
          1020231348099
          1018451550611
          1018510046808
          1019583813790
          1017969179796
          1017851107500
          1017960443039
          1017966911985
          1018554866958
          1020335316255
          1019416233166
          1019384969377
          1018696886240
          1020293644797
          1020332568440
          1019445669106
          1017910951234
          1017814223302
          1020122552336
          1017828871509
          1018582586901
          1017884319515
          1019530409244
          1019333453456
          1019531097555
          1019379345303
          1020146088817
          1020268916794
          1019464341720
          1017935775699
          1018683186297
          1020103356330
          1020335916869
          1019574853352
          1019535073834
          1018546602518
          1018671206534
          1020162240181
          1017865651409
          1018498438185
          1019563061151
          1019573965656
          1019330773423
          1020326420871
          1020193720459
          1017879147041
          1020338024996
          1018570166844
          1018538250901
          1018577222911
          1019588037610
          1019365845852
          1017892235254
          1018042871350
          1018557838297
          1019413993946
          1017823951761
          1019564845208
          1018700146838
          1017995279973
          1019414009622
          1019333201885
          1019417421192
          1018024271526
          1018479922672
          1018608886477
          1019452997469
          1019414409314
          1020175024588
          1017897479980
          1019432781063
          1019529169274
          1018648234310
          1018583254308
          1017840207998
          1019549281554
          1017993527037
          1018524814996
          1017997195594
          1020268640491
          1018591710114
          1018682814434
          1019518841089
          1019585533003
          1018561518908
          1017972395203
          1018612590058
          1020266116203
          1018616326347
          1019464921566
          1019505113712
          1020324032789
          1017900567327
          1019537825530
          1018665062051
          1018476470152
          1018677658732
          1019530701758
          1018553170799
          1017892271137
          1020355120664
          1019459365120
          1018054203754
          1020215584411
          1019425421462
          1018029427235
          1017905827062
          1018509526737
          1019486453149
          1020197372665
          1017932843721
          1020276528649
          1018646570649
          1019525473366
          1018692026091
          1017999275324
          1017910127406
          1020359228525
          1020147584801
          1019512329193
          1017823043668
          1017858807707
          1019385001515
          1019415833180
          1020354068876
          1018471662094
          1019445681495
          1020216556569
          1017881539181
          1018451498272
          1020363780231
          1018058683422
          1018039279732
          1017984723729
          1018689682088
          1019465001770
          1018543966671
          1020215632314
          1019572317782
          1020193232705
          1019478021788
          1017872279836
          1018687442710
          1019530385261
          1020283584174
          1020316652639
          1019573213845
          1017989939892
          1018545654821
          1020293692841
          1018651414454
          1017986575922
          1020168420330
          1018501394732
          1017952627442
          1017828779573
          1018694858416
          1017957071658
          1019568741407
          1017966243356
          1017947715206
          1018451294020
          1018595902367
          1019425717031
          1020126328263
          1017920831378
          1017835383420
          1018460354449
          1018558154954
          1018617094956
          1020342540242
          1018639622825
          1018506510776
          1020234820920
          1017933227039
          1017885343454
          1020165300217
          1017918503188
          1017860159748
          1018583134930
          1019425537228
          1020313908132
          1017897343976
          1019422097040
          1017842307102
          1018654462135
          1017944987582
          1017800631466
          1017958331844
          1020300992693
          1018040291678
          1020195096491
          1018685294996
          1019583677461
          1020114500194
          1020281584506
          1020194624910
          1018485526976
          1019412013543
          1019460193523
          1020099672242
          1018546050734
          1020288032656
          1018620754495
          1019546049917
          1019425389288
          1018519794072
          1020273220023
          1020136272239
          1020281232465
          1019452301537
          1018680206668
          1019452761184
          1017941783961
          1018588990366
          1018516958154
          1020194876109
          1020171916172
          1017816203054
          1020329208158
          1017855115691
          1017921239365
          1020234252877
          1019450369706
          1017826023152
          1018577530229
          1017867555734
          1019423017613
          1017913963451
          1018531522845
          1020177372609
          1020185204052
          1019403661934
          1019333449470
          1019587597173
          1019424825284
          1017838523496
          1019361737862
          1018574014284
          1019382309357
          1018532642153
          1020214980844
          1019553997323
          1017901427051
          1018454830835
          1018570962897
          1018669374924
          1018558162805
          1018677342389
          1019464229812
          1020184084336
          1017956671097
          1019579497564
          1020310292320
          1018564370681
          1018588598991
          1018040979233
          1017800647274
          1018526710833
          1017900287383
          1020135216598
          1020311036483
          1017862083195
          1017895943155
          1018666362753
          1019500489814
          1020352076737
          1018583490359
          1019451189037
          1018595330844
          1018634922178
          1018525234045
          1019489581734
          1020329512246
          1019438277907
          1020173544381
          1017934151178
          1020248132011
          1019487485868
          1018475982460
          1018012443543
          1019438485673
          1017913939468
          1020102816692
          1020212504872
          1017847131801
          1019586793803
          1019562729553
          1020191552677
          1018451214930
          1017903743488
          1018028319468
          1017885003140
          1020359504456
          1018033143021
          1020333724527
          1018583898133
          1020133072035
          1020283580551
          1017944739631
          1018039267475
          1017826455498
          1017848511106
          1018033651917
          1018016679264
          1017853071716
          1019369721559
          1019428473585
          1018001987285
          1018042351140
          1019479717184
          1019460481457
          1020341276655
          1018005579201
          1019432105883
          1017863859424
          1017932519656
          1019401657343
          1017844515864
          1020212896316
          1019460801626
          1020333848563
          1020268920322
          1018537278248
          1018489986371
          1018584246138
          1019579945754
          1017974431950
          1017933167792
          1019362629360
          1020345652903
          1017909371734
          1017801791737
          1020137236492
          1019551697804
          1019499169977
          1020334500575
          1017882199351
          1019426421850
          1020236984673
          1018648138047
          1017942543803
          1019490733548
          1019569945222
          1019464829471
          1020160316684
          1020235424295
          1020337684777
          1020260852471
          1017843907056
          1017849115574
          1019465781216
          1017865931967
          1018015543129
          1018607242260
          1020137240729
          1020255084776
          1018665078463
          1020271640365
          1019466781678
          1018676018373
          1019560313728
          1019475081892
          1019483253360
          1020199384469
          1017908827514
          1018490634845
          1017824143279
          1020155244755
          1018471934272
          1019396745729
          1018529490895
          1020354236967
          1018554478113
          1020343956602
          1017933555656
          1020224224278
          1018059247828
          1018672606638
          1018565310884
          1017870915419
          1020308068070
          1019450325031
          1020266748187
          1018040935152
          1017975279873
          1017897063823
          1018030631671
          1018619210859
          1017800467748
          1018564222148
          1018564226867
          1017836151113
          1019452117372
          1019429701866
          1018564754852
          1017972455174
          1018559214364
          1020155600739
          1018545406321
          1018673230497
          1017908311208
          1017844859259
          1017962943897
          1020164380082
          1017864659260
          1018598042876
          1019452473279
          1020269104610
          1019440869676
          1018050347057
          1018565110188
          1020102204055
          1017821775623
          1017893491605
          1018594338395
          1020205296411
          1019572005607
          1017915819106
          1018008575689
          1018517666670
          1018041575688
          1017935859365
          1018055983985
          1018680206729
          1019419749557
          1017893499671
          1018612138131
          1018060071487
          1018553690021
          1018020819987
          1020194788898
          1020133508191
          1019419097871
          1020185464323
          1018555494156
          1020162920174
          1019587469268
          1019567405272
          1019393857855
          1017836735491
          1019496313947
          1019392245996
          1020316920776
          1018621322912
          1018564534690
          1020332256975
          1018503638566
          1020208056472
          1020197868160
          1018584290713
          1018049167313
          1018668590129
          1019401013690
          1017827271186
          1018594122009
          1019558209548
          1020125744642
          1018548054416
          1018651322610
          1017821899209
          1020194924432
          1020196832696
          1018689682107
          1018486902702
          1020351220651
          1017883951737
          1017851739004
          1018554558473
          1017869887179
          1020160148546
          1017839779807
          1017845627620
          1020177484065
          1018532806786
          1017855859163
          1018527282190
          1018550482169
          1017857507320
          1020103284705
          1018571310402
          1020183444947
          1020269288767
          1019400773067
          1019352769643
          1018665918319
          1017895319198
          1018685150879
          1018674982467
          1019441645110
          1019355741863
          1020314340752
          1019547461965
          1017935015430
          1019381721264
          1020329152578
          1019427141111
          1017890383347
          1019464173596
          1020322064762
          1018534666173
          1019568169193
          1017946591551
          1018451542585
          1017955107013
          1017837931901
          1019451993297
          1019495717795
          1018685126771
          1017903595220
          1018550862750
          1018709446306
          1020237980256
          1017898167143
          1020157904024
          1018519606840
          1019368885319
          1018616586930
          1018696078042
          1018583362678
          1018662106863
          1019416597544
          1018505778834
          1017886779766
          1018467682233
          1017898191388
          1020230388257
          1019434053313
          1017956103446
          1019458629697
          1020180912971
          1018591298730
          1020194460900
          1019333709014
          1017800467433
          1019550917855
          1020290508787
          1020359236602
          1020103536501
          1020320744915
          1020136440761
          1019445765359
          1018032815408
          1020294136591
          1018564930385
          1020139760975
          1019464573034
          1020215388743
          1018553970636
          1020101904797
          1017979091846
          1019408541578
          1020188068931
          1019533097266
          1020321700438
          1020234008626
          1019553025840
          1018672274665
          1018042351523
          1019423545422
          1019508173805
          1019330757423
          1019490509418
          1018507542681
          1020186548484
          1018583510325
          1017906851582
          1018526498714
          1019532309192
          1018505650856
          1018509630659
          1018457442665
          1018597574424
          1017842943509
          1019399757700
          1018643358669
          1018579610514
          1020155140707
          1018661926450
          1018704610815
          1019501061346
          1020232400453
          1017935615156
          1019586025395
          1018679946874
          1019497017718
          1019464985878
          1018543878290
          1020171944079
          1017980643440
          1019537565851
          1018541218552
          1017981979360
          1020215688385
          1018710218543
          1019569309236
          1017906375755
          1020163768299
          1020274532762
          1019538413531
          1018699622014
          1019572737704
          1017993699933
          1019352037810
          1018566394169
          1019514789207
          1018056795438
          1018512774936
          1018484106831
          1018583150742
          1017914903829
          1019415577332
          1018482394994
          1017856359498
          1020236976566
          1018548402299
          1019384093306
          1017853039861
          1019466649306
          1018564342309
          1019368521815
          1018637098109
          1019468917999
          1020209112509
          1019530069955
          1019554233785
          1019503409995
          1020336208933
          1019401709328
          1020360732297
          1019527905874
          1019426677588
          1018615690218
          1019513757650
          1017897991231
          1017855879516
          1018706642808
          1018547598985
          1019438621337
          1019397577693
          1020168364593
          1019562961072
          1019474545405
          1018032299202
          1018584362628
          1018661926786
          1018636014885
          1017913415411
          1019498429053
          1020265300519
          1017914015029
          1018619442082
          1020328408186
          1019489741824
          1019424069297
          1017908783589
          1019466509128
          1017871223472
          1020328408180
          1018483918876
          1018646030182
          1018661458053
          1017984539858
          1020214412090
          1017907171820
          1019589125725
          1019539757266
          1020215520425
          1020348628455
          1018583698885
          1020163376257
          1018034291729
          1017839819070
          1017887939589
          1020319972564
          1018579846241
          1019437525699
          1019414437273
          1018449258127
          1018617902429
          1017958179783
          1018546150818
          1018695522343
          1020127176716
          1019424937589
          1020137560833
          1020329088815
          1019479601423
          1019543785997
          1020138496576
          1018564586750
          1019516129966
          1018590230149
          1020348944690
          1018682130584
          1018677082537
          1017999451535
          1018500530577
          1018029511581
          1019585317086
          1018502898037
          1019446981804
          1017935255996
          1019450901970
          1019333133979
          1020130272845
          1018007559275
          1018680990693
          1017938995279
          1018467666601
          1017944115521
          1017924959955
          1019393641543
          1020147168486
          1017874183590
          1020175320858
          1019428213476
          1020151588247
          1019580729114
          1017860727763
          1017853123633
          1019550049422
          1020292200580
          1020236872247
          1018583906150
          1019557621702
          1018034327741
          1019535269266
          1019445713439
          1017854979265
          1017807423661
          1019406369784
          1020212264532
          1018530410896
          1019381205848
          1018502562376
          1018706734827
          1020284888876
          1020196852803
          1020102156147
          1018653238143
          1018591118705
          1019418181864
          1020326148831
          1018041391247
          1018027771833
          1018672342431
          1018698210974
          1019354065697
          1018709522616
          1018507234024
          1020229740815
          1018635210692
          1017899911184
          1020148776418
          1018633282703
          1020249428227
          1018543310135
          1020359056652
          ----------------------------------------

        [FILE] user_1080595280.txt
          Путь: /Users/yanmore/IdeaProjects/multiParser/data/data/sent_products/user_1080595280.txt
          Размер: 12082 байт
          Дата изменения: 2026-02-03T07:48:05.657106847Z
          Содержимое:
          ----------------------------------------
          1020438244695
          1018805274448
          1018781134048
          1020231348099
          1018451550611
          1020464008146
          1017969179796
          1019637473774
          1017960443039
          1020439692084
          1019615705283
          1017828871509
          1017884319515
          1020146088817
          1019464341720
          1020409788813
          1019535073834
          1019671377750
          1017865651409
          1019690769946
          1019563061151
          1020454116593
          1020326420871
          1020193720459
          1020385496278
          1019588037610
          1020364600291
          1018732734911
          1018087795974
          1019646517035
          1018098975036
          1019701557573
          1018111207606
          1019662009906
          1019333201885
          1018608886477
          1020175024588
          1019671417486
          1018648234310
          1018583254308
          1018733426620
          1019549281554
          1018732410854
          1018156023984
          1018803542628
          1017997195594
          1019646201648
          1020454540144
          1019585533003
          1018561518908
          1017972395203
          1019663457304
          1020436268153
          1017808451206
          1019649649006
          1018476470152
          1019530701758
          1018553170799
          1019640069756
          1020215584411
          1019425421462
          1017965551724
          1017905827062
          1019486453149
          1018087403118
          1019613117871
          1018646570649
          1020147584801
          1017823043668
          1018148295228
          1020354068876
          1018163683795
          1018689682088
          1018543966671
          1018734466771
          1018747130424
          1018062531025
          1019572317782
          1017872279836
          1019530385261
          1020316652639
          1017989939892
          1018545654821
          1018501394732
          1018119863638
          1017952627442
          1019632449410
          1017804811581
          1018774982835
          1019425717031
          1018558154954
          1018732858962
          1018733638035
          1018506510776
          1017933227039
          1017885343454
          1018583134930
          1019425537228
          1019422097040
          1018119895696
          1018654462135
          1019627381016
          1020300992693
          1017801935659
          1018076103115
          1018161419675
          1019583677461
          1020114500194
          1018801206148
          1018485526976
          1019460193523
          1019425389288
          1018519794072
          1020454488083
          1019452301537
          1018680206668
          1017941783961
          1020194876109
          1020171916172
          1017816203054
          1018130939134
          1018803586273
          1020234252877
          1019616989495
          1020435740291
          1018155831933
          1020424780244
          1018121151119
          1019654337602
          1019333449470
          1019587597173
          1019647945923
          1019553997323
          1020459152065
          1018125023674
          1018771890090
          1018732734990
          1018677342389
          1019464229812
          1019594001971
          1018140287779
          1020310292320
          1017800647274
          1017900287383
          1019500489814
          1018726930487
          1020248132011
          1019487485868
          1018475982460
          1018805146541
          1017913939468
          1020102816692
          1017847131801
          1018796574589
          1019562729553
          1017903743488
          1019687201787
          1018028319468
          1018583898133
          1020133072035
          1020283580551
          1018039267475
          1018791470070
          1017826455498
          1018752230922
          1018719298138
          1018810038134
          1018033651917
          1018016679264
          1017853071716
          1019460481457
          1017932519656
          1020367804157
          1018723430239
          1020420072494
          1020464320348
          1017801791737
          1018155831991
          1018745902127
          1018144495941
          1020235424295
          1020260852471
          1018809546074
          1020271640365
          1018791314972
          1018676018373
          1018783498986
          1018076199170
          1019483253360
          1020199384469
          1018755354748
          1018781538930
          1018133099446
          1018780726806
          1020155244755
          1019691113732
          1019656493969
          1020354236967
          1020467740475
          1017933555656
          1017870915419
          1019450325031
          1020266748187
          1019635481775
          1018030631671
          1018619210859
          1017800467748
          1018564222148
          1020405096215
          1019606501383
          1018151091095
          1017844859259
          1018805258639
          1019663461343
          1017864659260
          1018061883832
          1019682117230
          1020378168753
          1020102204055
          1019613261971
          1017893491605
          1020205296411
          1018075831806
          1020379456105
          1018008575689
          1018728194560
          1018129727976
          1018060071487
          1020399772458
          1018020819987
          1018119443400
          1019628701458
          1018775518484
          1018743526284
          1020162920174
          1020422628504
          1020454440160
          1019393857855
          1019392245996
          1019691177373
          1018621322912
          1019687425284
          1018049167313
          1020385492362
          1018668590129
          1019596049237
          1018791122928
          1018594122009
          1020364412492
          1020408696644
          1017883951737
          1018554558473
          1017869887179
          1018124139260
          1018167783148
          1018532806786
          1018059671644
          1018133811663
          1020103284705
          1018571310402
          1019400773067
          1018075659957
          1019651309601
          1018674982467
          1020109712329
          1019547461965
          1018076063300
          1018099863591
          1019427141111
          1019464173596
          1019568169193
          1017837931901
          1019610773897
          1020466736890
          1018090355946
          1019687293439
          1018709446306
          1019368885319
          1020463360714
          1020367644344
          1018467682233
          1019592021999
          1017898191388
          1018107895631
          1020230388257
          1019434053313
          1019333709014
          1019550917855
          1020290508787
          1018805154535
          1020103536501
          1018162419646
          1019445765359
          1018032815408
          1020294136591
          1018564930385
          1019533097266
          1020321700438
          1018134099927
          1018672274665
          1018156219476
          1020378340448
          1020422776500
          1018583510325
          1018526498714
          1018457442665
          1020454080658
          1018597574424
          1019597009838
          1018643358669
          1019687725070
          1018661926450
          1017935615156
          1019651841218
          1019464985878
          1018543878290
          1020171944079
          1018805266419
          1019650925159
          1018710218543
          1017906375755
          1020163768299
          1019538413531
          1018699622014
          1019572737704
          1020436720421
          1018566394169
          1020433072283
          1018150827546
          1018512774936
          1018147067794
          1019687801012
          1019650585205
          1018548402299
          1019691081081
          1019466649306
          1018564342309
          1019468917999
          1019641109471
          1020421452588
          1017807863543
          1019651145629
          1020336208933
          1019401709328
          1017897991231
          1017855879516
          1019438621337
          1020395072600
          1018032299202
          1018733026897
          1020459684051
          1018773502077
          1019347229042
          1017908783589
          1019466509128
          1017871223472
          1020411916917
          1020417756829
          1018099307388
          1018787118774
          1019589125725
          1019683797355
          1017839819070
          1018083423726
          1019414437273
          1019662609317
          1019687681003
          1019687353396
          1020127176716
          1018821122274
          1020450156987
          1019674757424
          1020329088815
          1019479601423
          1019613593300
          1018734966152
          1020389560023
          1018783866612
          1018677082537
          1018500530577
          1019450901970
          1019333133979
          1018109731823
          1018800090489
          1020130272845
          1018100439137
          1019621313035
          1017938995279
          1018091915095
          1017944115521
          1017924959955
          1020102988922
          1019393641543
          1020147168486
          1020175320858
          1019580729114
          1018727210088
          1020292200580
          1018034327741
          1017854979265
          1018077035227
          1019606445667
          1019683189060
          1020212264532
          1019381205848
          1018502562376
          1018706734827
          1020102156147
          1020364160799
          1018653238143
          1019607165871
          1020408352829
          1018507234024
          1019645241953
          1018733562414
          1018543310135
          1020359056652
          1020439080865
          1018046227667
          1019536529140
          1019640621853
          1019583813790
          1017966911985
          1019697637202
          1018808990989
          1019445669106
          1018160355384
          1018532542947
          1020122552336
          1019530409244
          1019650709629
          1018119607583
          1019379345303
          1018808350923
          1017935775699
          1020104540096
          1020384452928
          1018726830576
          1020414028705
          1020103356330
          1020335916869
          1018546602518
          1018671206534
          1018075663839
          1019611669826
          1019330773423
          1018577222911
          1020376564546
          1018769982013
          1019682789213
          1017892235254
          1018557838297
          1020459496219
          1020454504355
          1020399272382
          1017995279973
          1019606885019
          1018024271526
          1018067239851
          1020411776029
          1018479922672
          1019669693406
          1019452997469
          1019414409314
          1019682245081
          1019432781063
          1017840207998
          1020464160461
          1020268640491
          1018682814434
          1018135367985
          1018159839705
          1019464921566
          1020324032789
          1017900567327
          1019537825530
          1018677658732
          1017892271137
          1020355120664
          1019459365120
          1018131655283
          1020390528398
          1019685393791
          1017806507116
          1020197372665
          1017932843721
          1018064451045
          1019525473366
          1018692026091
          1020419828747
          1017999275324
          1020411840734
          1020359228525
          1019512329193
          1019634125362
          1019664965631
          1019415833180
          1019650317788
          1018471662094
          1018805194757
          1019445681495
          1019642433261
          1017881539181
          1018451498272
          1018058683422
          1020363780231
          1018039279732
          1017984723729
          1018156215426
          1018775054446
          1019465001770
          1020463052382
          1019478021788
          1020283584174
          1019678497132
          1018651414454
          1017828779573
          1019568741407
          1018065183495
          1020417392023
          1019662613634
          1018451294020
          1018595902367
          1017920831378
          1018105631827
          1020463616418
          1020234820920
          1018711478963
          1017897343976
          1019671145978
          1017800631466
          1018147183703
          1018811462524
          1020281584506
          1020194624910
          1018083523777
          1018789738421
          1017814435391
          1019592373564
          1019598073496
          1019546049917
          1019691309886
          1019452761184
          1018104011348
          1017855115691
          1018112971964
          1018773546236
          1018129383952
          1018155959669
          1020463644215
          1020459596216
          1018100795460
          1019361737862
          1018574014284
          1018532642153
          1020421068902
          1020454228459
          1019685877638
          1020214980844
          1018819594500
          1017901427051
          1018806750105
          1019636349418
          1018570962897
          1019613241858
          1020184084336
          1019627621764
          1019638425805
          1018564370681
          1018716186960
          1020135216598
          1019660521140
          1019606725186
          1020463472695
          1017895943155
          1020352076737
          1018583490359
          1018634922178
          1018737134265
          1019592185680
          1019489581734
          1019438277907
          1020173544381
          1019663381539
          1018451522440
          1018012443543
          1019438485673
          1019627937899
          1019606393750
          1018451214930
          1019671785101
          1020262756125
          1019594841908
          1020359504456
          1018033143021
          1020333724527
          1018160155952
          1019618101990
          1017944739631
          1018084539171
          1018781554038
          1019612413133
          1018725710665
          1019369721559
          1019428473585
          1018461986506
          1019664565546
          1020475164136
          1018042351140
          1018086679765
          1018005579201
          1019626757178
          1018801946043
          1020212896316
          1020333848563
          1017981123243
          1019579945754
          1017933167792
          1019362629360
          1018117931660
          1019606417872
          1018085399415
          1018151003143
          1020398884909
          1020334500575
          1017882199351
          1017802791631
          1018062159272
          1018715826366
          1019426421850
          1019687569138
          1019569945222
          1019464829471
          1020160316684
          1020337684777
          1017849115574
          1018015543129
          1019613705009
          1018106519907
          1019651757507
          1020255084776
          1018665078463
          1019466781678
          1020425100956
          1018805242913
          1019560313728
          1018723890089
          1018809362592
          1019396745729
          1020379560236
          1018159583727
          1020224224278
          1018059247828
          1018672606638
          1018565310884
          1019676133928
          1018811374891
          1019333209711
          1017975279873
          1018760026393
          1017897063823
          1018564226867
          1020412444587
          1017836151113
          1018795582487
          1019429701866
          1017972455174
          1020155600739
          1018673230497
          1017908311208
          1020419612192
          1018598042876
          1018565110188
          1018064263204
          1018065999374
          1019652049729
          1018132575565
          1018594338395
          1019613717407
          1020224548404
          1018517666670
          1018156143429
          1018680206729
          1019419749557
          1017893499671
          1018612138131
          1018074275983
          1018443154622
          1018553690021
          1020133508191
          1019682001493
          1018774714924
          1018785082422
          1019587469268
          1019567405272
          1017836735491
          1020396600768
          1020316920776
          1018564534690
          1018584290713
          1020364180909
          1017827271186
          1020125744642
          1019664053236
          1018548054416
          1017821899209
          1019697785961
          1018689682107
          1018486902702
          1020351220651
          1017851739004
          1017845627620
          1020177484065
          1018800310090
          1017855859163
          1019690945410
          1018550482169
          1017857507320
          1018098427828
          1018665918319
          1017895319198
          1018685150879
          1019441645110
          1019355741863
          1020314340752
          1017890383347
          1017946591551
          1018451542585
          1020412560371
          1017955107013
          1018685126771
          1020237980256
          1019687145985
          1018583362678
          1018662106863
          1019666969577
          1017886779766
          1019613589327
          1020194460900
          1018083147575
          1017800467433
          1020359236602
          1020320744915
          1018800334008
          1018082523535
          1020215388743
          1020101904797
          1020188068931
          1019663829722
          1019553025840
          1020366132803
          1019330757423
          1018507542681
          1018133739775
          1018744862828
          1020388796682
          1020400096340
          1017842943509
          1018579610514
          1020110136783
          1020232400453
          1019645505383
          1019589221199
          1018732598708
          1020401408162
          1020215688385
          1019609473393
          1019569309236
          1018056795438
          1018583150742
          1018075563973
          1018799910736
          1018482394994
          1017856359498
          1020378092189
          1020236976566
          1019602921240
          1019368521815
          1020209112509
          1020374752789
          1018075099390
          1018733246038
          1020385980165
          1019554233785
          1019663109317
          1019503409995
          1020360732297
          1020385344821
          1019426677588
          1019663897858
          1018706642808
          1018547598985
          1019562961072
          1019474545405
          1019606269869
          1018584362628
          1017913415411
          1020368788832
          1017914015029
          1020328408186
          1019489741824
          1019424069297
          1018778898405
          1019592841593
          1018661458053
          1020214412090
          1019539757266
          1020215520425
          1018768250537
          1020348628455
          1018725922394
          1020399072509
          1018449258127
          1018756670271
          1019648689106
          1019689765638
          1018733342865
          1018546150818
          1018732438955
          1019424937589
          1018154063147
          1020395832609
          1018564586750
          1018590230149
          1020459860224
          1017999451535
          1018502898037
          1018459046123
          1017935255996
          1019667861664
          1019682617623
          1018007559275
          1018809494472
          1020389624606
          1019649809991
          1018118035177
          1020474996357
          1017853123633
          1018150767765
          1019550049422
          1020236872247
          1018583906150
          1020385664050
          1020411860365
          1019445713439
          1019607457506
          1017950847552
          1017807423661
          1019649905703
          1020284888876
          1020196852803
          1018591118705
          1020326148831
          1018041391247
          1018027771833
          1018672342431
          1018709522616
          1018460162287
          1018711650754
          1020456620306
          1020229740815
          1020148776418
          1020249428227
          ----------------------------------------

    [FILE] user_1080595280_queries.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_1080595280_queries.txt
      Размер: 22 байт
      Дата изменения: 2026-02-02T19:27:03.908549685Z
      Содержимое:
      ----------------------------------------
      cav empt
      stone island
      ----------------------------------------
    [DIR] backups

    [FILE] user_5279294557_queries.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_5279294557_queries.txt
      Размер: 22 байт
      Дата изменения: 2026-02-02T19:45:57.607690885Z
      Содержимое:
      ----------------------------------------
      Stone Island
      Givenchy
      ----------------------------------------

    [FILE] access_requests.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/access_requests.txt
      Размер: 127 байт
      Дата изменения: 2026-02-02T20:41:57.113833027Z
      Содержимое:
      ----------------------------------------
      6937423668|2026-01-29 13:55:59|unauthorized_command
      2115277940|2026-02-02 22:38:52|/start
      807950622|2026-02-02 23:41:57|/start
      ----------------------------------------
  [DIR] src
    [DIR] test
      [DIR] java
    [DIR] main
      [DIR] resources

        [FILE] logback.xml
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/logback.xml
          Размер: 2027 байт
          Дата изменения: 2026-02-02T19:12:37.291007929Z
          Содержимое:
          ----------------------------------------
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
              <property name="LOG_DIR" value="./logs" />
              <property name="LOG_FILE" value="parser" />
              <property name="MAX_LOG_DAYS" value="7" />
              <property name="MAX_LOG_SIZE" value="50MB" />
          
              <!-- Консольный аппендер -->
              <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
                  <encoder>
                      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <!-- Файловый аппендер с автоочисткой -->
              <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
                  <file>${LOG_DIR}/${LOG_FILE}.log</file>
          
                  <!-- Политика ротации по времени -->
                  <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                      <fileNamePattern>${LOG_DIR}/${LOG_FILE}.%d{yyyy-MM-dd}.log</fileNamePattern>
                      <!-- Храним логи только 7 дней -->
                      <maxHistory>${MAX_LOG_DAYS}</maxHistory>
                      <!-- Очищаем старые логи автоматически -->
                      <cleanHistoryOnStart>true</cleanHistoryOnStart>
                  </rollingPolicy>
          
                  <!-- Политика ротации по размеру -->
                  <triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy">
                      <maxFileSize>${MAX_LOG_SIZE}</maxFileSize>
                  </triggeringPolicy>
          
                  <encoder>
                      <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <!-- Логирование Selenium -->
              <logger name="org.openqa.selenium" level="WARN" />
              <logger name="io.github.bonigarcia" level="WARN" />
              <logger name="org.apache.http" level="WARN" />
          
              <!-- Корневой логгер -->
              <root level="INFO">
                  <appender-ref ref="CONSOLE" />
                  <appender-ref ref="FILE" />
              </root>
          </configuration>
          ----------------------------------------

        [FILE] cookie.properties
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/cookie.properties
          Размер: 233 байт
          Дата изменения: 2026-01-19T09:31:29.778055459Z
          Содержимое:
          ----------------------------------------
          h5api.m.goofish.com.cookies=_m_h5_tk=abc123def456_1705420800000; _m_h5_tk_enc=abc123def456_1705420800000; _tb_token_=xyz789; cna=test123; t=md5hash123; cookie2=md5hash456; _samesite_flag_=true; XSRF-TOKEN=token123; isg=BC_randomtoken
          ----------------------------------------

        [FILE] logback-debug.xml
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/logback-debug.xml
          Размер: 363 байт
          Дата изменения: 2026-01-16T19:22:31.341841447Z
          Содержимое:
          ----------------------------------------
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
              <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
                  <encoder>
                      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <root level="DEBUG">
                  <appender-ref ref="CONSOLE" />
              </root>
          </configuration>
          ----------------------------------------

        [FILE] config.properties
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/config.properties
          Размер: 1369 байт
          Дата изменения: 2026-02-03T07:12:13.454979989Z
          Содержимое:
          ----------------------------------------
          # ======================
          # Telegram Bot Settings
          # ======================
          telegram.bot.token=8404858867:AAF6AkEToZgCktCdZsPV62jgEqK1vul_QFg
          telegram.bot.username=goofishparse_bot
          telegram.admin.id=1080595280
          
          # Parser Configuration
          parser.default.check_interval=20
          parser.default.max_age_minutes=1440
          parser.default.rows_per_page=30
          parser.default.max_pages=20
          parser.default.notify_new_only=true
          
          # Thread Pool Configuration
          thread.pool.core.size=5
          thread.pool.max.size=20
          thread.pool.queue.capacity=100
          thread.pool.keepalive.seconds=60
          
          # Storage Configuration
          storage.data.dir=./data
          storage.backup.enabled=true
          storage.backup.interval.hours=24
          
          # HTTP Configuration
          http.connect.timeout=30000
          http.read.timeout=45000
          http.user.agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
          http.max.retries=3
          http.retry.delay=1000
          
          # Cookie Configuration
          cookie.file=cookies.properties
          cookie.auto.update=true
          cookie.update.interval.minutes=60
          cookie.backup.enabled=true
          cookie.dynamic.enabled=true
          cookie.cache.ttl.minutes=30
          
          # Logging Configuration
          logging.level=INFO
          logging.file=parser.log
          logging.max.size.mb=10
          logging.max.backups=5
          
          # API Configuration
          api.goofish.base_url=https://h5api.m.goofish.com
          api.goofish.search.endpoint=/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/
          api.goofish.delay.between.requests=2000
          api.goofish.max.products.per.page=500
          ----------------------------------------
      [DIR] java
        [DIR] com
          [DIR] parser
            [DIR] core

              [FILE] UserSession.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/core/UserSession.java
                Размер: 9510 байт
                Дата изменения: 2026-01-19T09:31:29.768832921Z
                Содержимое:
                ----------------------------------------
                package com.parser.core;
                
                import com.parser.config.ParserSettings;
                import com.parser.model.UserSettings;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.util.*;
                
                /**
                 * Класс, представляющий сессию парсера для пользователя
                 */
                public class UserSession {
                    private static final Logger logger = LoggerFactory.getLogger(UserSession.class);
                
                    private final long userId;
                    private final List<String> queries;
                    private final UserSettings settings;
                
                    // Состояние
                    private volatile boolean running;
                    private volatile boolean paused;
                    private String status;
                    private String lastError;
                
                    // Статистика
                    private int totalProductsFound;
                    private int requestsMade;
                    private int errorsCount;
                
                    // Временные метки
                    private Date startTime;
                    private Date endTime;
                    private Date lastIterationTime;
                    private Date lastProductFoundTime;
                
                    // История найденных товаров (последние 100)
                    private final List<Map<String, Object>> recentProducts;
                
                    public UserSession(long userId, List<String> queries, UserSettings settings) {
                        this.userId = userId;
                        this.queries = new ArrayList<>(queries);
                        this.settings = settings;
                        this.running = false;
                        this.paused = false;
                        this.status = ParserSettings.STATUS_STOPPED;
                        this.totalProductsFound = 0;
                        this.requestsMade = 0;
                        this.errorsCount = 0;
                        this.recentProducts = new LinkedList<>();
                    }
                
                    // Геттеры
                    public long getUserId() {
                        return userId;
                    }
                
                    public List<String> getQueries() {
                        return new ArrayList<>(queries);
                    }
                
                    public UserSettings getSettings() {
                        return settings;
                    }
                
                    public boolean isRunning() {
                        return running;
                    }
                
                    public boolean isPaused() {
                        return paused;
                    }
                
                    public String getStatus() {
                        return status;
                    }
                
                    public String getLastError() {
                        return lastError;
                    }
                
                    public int getTotalProductsFound() {
                        return totalProductsFound;
                    }
                
                    public int getRequestsMade() {
                        return requestsMade;
                    }
                
                    public int getErrorsCount() {
                        return errorsCount;
                    }
                
                    public Date getStartTime() {
                        return startTime;
                    }
                
                    public Date getEndTime() {
                        return endTime;
                    }
                
                    public Date getLastIterationTime() {
                        return lastIterationTime;
                    }
                
                    public Date getLastProductFoundTime() {
                        return lastProductFoundTime;
                    }
                
                    public List<Map<String, Object>> getRecentProducts() {
                        return new ArrayList<>(recentProducts);
                    }
                
                    // Сеттеры
                    public void setRunning(boolean running) {
                        this.running = running;
                        this.status = running ? ParserSettings.STATUS_RUNNING : ParserSettings.STATUS_STOPPED;
                        if (running) {
                            this.startTime = new Date();
                        } else {
                            this.endTime = new Date();
                        }
                    }
                
                    public void setPaused(boolean paused) {
                        this.paused = paused;
                        this.status = paused ? ParserSettings.STATUS_PAUSED :
                                (running ? ParserSettings.STATUS_RUNNING : ParserSettings.STATUS_STOPPED);
                    }
                
                    public void setStatus(String status) {
                        this.status = status;
                    }
                
                    public void setLastError(String lastError) {
                        this.lastError = lastError;
                    }
                
                    public void setStartTime(Date startTime) {
                        this.startTime = startTime;
                    }
                
                    public void setEndTime(Date endTime) {
                        this.endTime = endTime;
                    }
                
                    public void setLastIterationTime(Date lastIterationTime) {
                        this.lastIterationTime = lastIterationTime;
                    }
                
                    public void setLastProductFoundTime(Date lastProductFoundTime) {
                        this.lastProductFoundTime = lastProductFoundTime;
                    }
                
                    // Методы для работы со статистикой
                    public void addProductsFound(int count) {
                        this.totalProductsFound += count;
                        this.lastProductFoundTime = new Date();
                    }
                
                    public void incrementRequestsMade() {
                        this.requestsMade++;
                    }
                
                    public void incrementErrors() {
                        this.errorsCount++;
                    }
                
                    public void addRecentProduct(Map<String, Object> productInfo) {
                        synchronized (recentProducts) {
                            recentProducts.add(0, productInfo); // Добавляем в начало
                
                            // Ограничиваем размер истории
                            if (recentProducts.size() > 100) {
                                recentProducts.remove(recentProducts.size() - 1);
                            }
                        }
                    }
                
                    /**
                     * Получение подробного статуса сессии
                     */
                    public Map<String, Object> getDetailedStatus() {
                        Map<String, Object> status = new HashMap<>();
                
                        status.put("userId", userId);
                        status.put("running", running);
                        status.put("paused", paused);
                        status.put("status", this.status);
                        status.put("queriesCount", queries.size());
                        status.put("totalProductsFound", totalProductsFound);
                        status.put("requestsMade", requestsMade);
                        status.put("errorsCount", errorsCount);
                        status.put("lastError", lastError);
                
                        // Временные метки
                        status.put("startTime", startTime != null ? startTime.getTime() : null);
                        status.put("endTime", endTime != null ? endTime.getTime() : null);
                        status.put("lastIterationTime", lastIterationTime != null ? lastIterationTime.getTime() : null);
                        status.put("lastProductFoundTime", lastProductFoundTime != null ? lastProductFoundTime.getTime() : null);
                
                        // Uptime
                        if (startTime != null) {
                            long uptime = System.currentTimeMillis() - startTime.getTime();
                            status.put("uptime", formatUptime(uptime));
                        }
                
                        // Настройки
                        if (settings != null) {
                            Map<String, Object> settingsMap = new HashMap<>();
                            settingsMap.put("checkInterval", settings.getCheckInterval());
                            settingsMap.put("maxAgeMinutes", settings.getMaxAgeMinutes());
                            settingsMap.put("maxPages", settings.getMaxPages());
                            settingsMap.put("rowsPerPage", settings.getRowsPerPage());
                            settingsMap.put("priceCurrency", settings.getPriceCurrency());
                            settingsMap.put("notifyNewOnly", settings.isNotifyNewOnly());
                            status.put("settings", settingsMap);
                        }
                
                        // Запросы (первые 5)
                        status.put("sampleQueries", queries.size() > 5 ?
                                queries.subList(0, 5) : queries);
                
                        return status;
                    }
                
                    /**
                     * Форматирование времени работы
                     */
                    private String formatUptime(long millis) {
                        long seconds = millis / 1000;
                        long minutes = seconds / 60;
                        long hours = minutes / 60;
                        long days = hours / 24;
                
                        if (days > 0) {
                            return String.format("%dд %dч %dм", days, hours % 24, minutes % 60);
                        } else if (hours > 0) {
                            return String.format("%dч %dм %dс", hours, minutes % 60, seconds % 60);
                        } else if (minutes > 0) {
                            return String.format("%dм %dс", minutes, seconds % 60);
                        } else {
                            return String.format("%dс", seconds);
                        }
                    }
                
                    /**
                     * Получение статистики эффективности
                     */
                    public Map<String, Object> getEfficiencyStats() {
                        Map<String, Object> stats = new HashMap<>();
                
                        if (requestsMade > 0) {
                            double productsPerRequest = (double) totalProductsFound / requestsMade;
                            double errorRate = (double) errorsCount / requestsMade;
                
                            stats.put("productsPerRequest", Math.round(productsPerRequest * 100.0) / 100.0);
                            stats.put("errorRate", Math.round(errorRate * 10000.0) / 100.0); // в процентах
                            stats.put("successRate", Math.round((1 - errorRate) * 10000.0) / 100.0);
                        }
                
                        if (startTime != null && lastIterationTime != null) {
                            long avgIterationTime = (lastIterationTime.getTime() - startTime.getTime()) /
                                    Math.max(requestsMade, 1);
                            stats.put("avgIterationTimeMs", avgIterationTime);
                        }
                
                        return stats;
                    }
                
                    /**
                     * Сброс статистика
                     */
                    public void resetStatistics() {
                        totalProductsFound = 0;
                        requestsMade = 0;
                        errorsCount = 0;
                        recentProducts.clear();
                        lastError = null;
                        logger.info("Statistics reset for user {}", userId);
                    }
                
                    /**
                     * Обновление списка запросов
                     */
                    public boolean updateQueries(List<String> newQueries) {
                        if (newQueries == null || newQueries.isEmpty()) {
                            logger.warn("Attempted to set empty queries for user {}", userId);
                            return false;
                        }
                
                        this.queries.clear();
                        this.queries.addAll(newQueries);
                        logger.debug("Queries updated for user {}, now has {} queries",
                                userId, queries.size());
                        return true;
                    }
                
                    /**
                     * Проверка, активна ли сессия
                     */
                    public boolean isActive() {
                        return running && !paused;
                    }
                
                    @Override
                    public String toString() {
                        return String.format("UserSession{userId=%d, running=%s, queries=%d, found=%d}",
                                userId, running, queries.size(), totalProductsFound);
                    }
                }
                ----------------------------------------

              [FILE] ThreadManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/core/ThreadManager.java
                Размер: 17407 байт
                Дата изменения: 2026-02-02T19:12:03.987035871Z
                Содержимое:
                ----------------------------------------
                package com.parser.core;
                
                import com.parser.config.Config;
                import com.parser.model.Product;
                import com.parser.model.UserSettings;
                import com.parser.parser.ParserFactory;
                import com.parser.parser.SiteParser;
                import com.parser.service.CookieService;
                import com.parser.storage.UserDataManager;
                import com.parser.storage.UserSentProductsManager;
                import com.parser.storage.WhitelistManager;
                import com.parser.telegram.TelegramNotificationService;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.util.*;
                import java.util.concurrent.*;
                
                /**
                 * Управление потоками парсеров пользователей
                 */
                public class ThreadManager {
                    private static final Logger logger = LoggerFactory.getLogger(ThreadManager.class);
                
                    private final Map<Long, UserSession> userSessions = new ConcurrentHashMap<>();
                    private final ThreadPoolExecutor threadPool;
                    private final ScheduledExecutorService scheduler;
                
                    private int totalProductsFound = 0;
                    private int totalRequestsMade = 0;
                    private final Date startTime = new Date();
                
                    public ThreadManager() {
                        int coreSize = Config.getThreadPoolCoreSize();
                        int maxSize = Config.getThreadPoolMaxSize();
                        int keepAlive = Config.getInt("thread.pool.keepalive.seconds", 60);
                
                        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>(50);
                        threadPool = new ThreadPoolExecutor(coreSize, maxSize, keepAlive, TimeUnit.SECONDS,
                                workQueue, new ThreadPoolExecutor.CallerRunsPolicy());
                
                        scheduler = Executors.newScheduledThreadPool(1);
                
                        // Логирование статистики каждые 10 минут
                        scheduler.scheduleAtFixedRate(this::logStatistics, 10, 10, TimeUnit.MINUTES);
                
                        // 🔴 ПРОВЕРКА COOKIES ПЕРЕД АВТООБНОВЛЕНИЕМ
                        if (Config.getCookieAutoUpdate() && CookieService.hasValidCookies()) {
                            int interval = Config.getCookieUpdateInterval();
                            scheduler.scheduleAtFixedRate(() -> {
                                try {
                                    if (Config.isDynamicCookiesEnabled()) {
                                        logger.info("Auto-updating cookies...");
                                        CookieService.refreshCookies("www.goofish.com");
                                    }
                                } catch (Exception e) {
                                    logger.error("Cookie auto-update failed: {}", e.getMessage());
                                }
                            }, interval, interval, TimeUnit.MINUTES);
                        } else {
                            logger.warn("⚠️ Cookie auto-update disabled: cookies not valid");
                        }
                
                        logger.info("ThreadManager initialized: core={}, max={}", coreSize, maxSize);
                    }
                
                    public boolean startUserParser(long userId) {
                        logger.info("Starting parser for user {}", userId);
                
                        // 🔴 ПРОВЕРКА WHITELIST
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            logger.warn("User {} not in whitelist", userId);
                            TelegramNotificationService.sendMessage(userId, "❌ You are not authorized to use this bot");
                            return false;
                        }
                
                        // 🔴 ПРОВЕРКА COOKIES ПЕРЕД ЗАПУСКОМ
                        if (!CookieService.hasValidCookies()) {
                            logger.error("Cannot start parser for user {}: cookies not valid", userId);
                            TelegramNotificationService.sendMessage(userId,
                                    "❌ Parser cannot start: cookies not valid!\n" +
                                            "Please wait for administrator to refresh cookies.");
                            return false;
                        }
                
                        if (userSessions.containsKey(userId) && userSessions.get(userId).isRunning()) {
                            TelegramNotificationService.sendMessage(userId, "⚠️ Parser already running");
                            return false;
                        }
                
                        List<String> queries = UserDataManager.getUserQueries(userId);
                        if (queries.isEmpty()) {
                            TelegramNotificationService.sendMessage(userId, "📭 No search queries added. Use /addquery");
                            return false;
                        }
                
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                        UserSession session = new UserSession(userId, queries, settings);
                        userSessions.put(userId, session);
                
                        threadPool.submit(() -> runUserParser(session));
                
                        logger.info("Parser started for user {}: {} queries", userId, queries.size());
                        TelegramNotificationService.sendMessage(userId,
                                "✅ Parser started!\nQueries: " + queries.size() + "\nCheck interval: " + settings.getCheckInterval() + " sec");
                
                        return true;
                    }
                
                    private void runUserParser(UserSession session) {
                        long userId = session.getUserId();
                        session.setRunning(true);
                
                        logger.info("Parser loop started for user {}", userId);
                
                        try {
                            SiteParser parser = ParserFactory.createParser("goofish");
                
                            while (session.isRunning() && !Thread.currentThread().isInterrupted()) {
                                // 🔴 ПРОВЕРКА COOKIES ПЕРЕД КАЖДОЙ ИТЕРАЦИЕЙ
                                if (!CookieService.hasValidCookies()) {
                                    logger.warn("Cookies invalid for user {}, pausing parser", userId);
                                    TelegramNotificationService.sendMessage(userId,
                                            "⚠️ Parser paused: cookies need refresh\n" +
                                                    "Waiting for administrator action...");
                
                                    // Ждем восстановления cookies
                                    while (!CookieService.hasValidCookies() && session.isRunning()) {
                                        Thread.sleep(60000); // Проверяем каждую минуту
                                    }
                
                                    if (session.isRunning()) {
                                        TelegramNotificationService.sendMessage(userId, "✅ Cookies restored, resuming parser");
                                    }
                                }
                
                                for (String query : session.getQueries()) {
                                    if (!session.isRunning()) break;
                
                                    try {
                                        List<Product> products = parser.search(
                                                query,
                                                session.getSettings().getMaxPages(),
                                                session.getSettings().getRowsPerPage(),
                                                session.getSettings().getMaxAgeMinutes()
                                        );
                
                                        totalRequestsMade++;
                                        session.incrementRequestsMade();
                
                                        if (!products.isEmpty()) {
                                            session.addProductsFound(products.size());
                                            totalProductsFound += products.size();
                
                                            sendProductNotifications(userId, products, query, session.getSettings());
                
                                            UserDataManager.addUserProducts(userId, products);
                                        }
                
                                        Thread.sleep(Config.getInt("api.goofish.delay.between.requests", 2000));
                
                                    } catch (Exception e) {
                                        logger.error("Error searching '{}' for user {}: {}", query, userId, e.getMessage());
                                        session.incrementErrors();
                                        session.setLastError("Search error: " + e.getMessage());
                
                                        TelegramNotificationService.sendMessage(userId,
                                                "❌ Ошибка при поиске '" + query + "': " + e.getMessage());
                
                                        Thread.sleep(5000);
                                    }
                                }
                
                                // Обновляем cookies после полного цикла
                                if (session.isRunning() && Config.isDynamicCookiesEnabled() && CookieService.hasValidCookies()) {
                                    try {
                                        logger.info("🔄 Обновление cookies после цикла (user={})", userId);
                                        CookieService.refreshCookies("www.goofish.com");
                                    } catch (Exception e) {
                                        logger.warn("Cookie refresh after cycle failed (user={}): {}", userId, e.getMessage());
                                    }
                                }
                
                                int interval = session.getSettings().getCheckInterval();
                                for (int i = 0; i < interval && session.isRunning(); i++) {
                                    Thread.sleep(1000);
                                }
                
                                session.setLastIterationTime(new Date());
                            }
                
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            logger.info("Parser thread interrupted for user {}", userId);
                        } catch (Exception e) {
                            logger.error("Parser error for user {}: {}", userId, e.getMessage(), e);
                            TelegramNotificationService.sendMessage(userId,
                                    "❌ Критическая ошибка парсера: " + e.getMessage());
                        } finally {
                            session.setRunning(false);
                            userSessions.remove(userId);
                            String message = String.format("🛑 Parser stopped\nTotal found: %d products\nErrors: %d",
                                    session.getTotalProductsFound(), session.getErrorsCount());
                            TelegramNotificationService.sendMessage(userId, message);
                        }
                    }
                
                    private void sendProductNotifications(long userId, List<Product> products, String query, UserSettings settings) {
                        if (products == null || products.isEmpty()) {
                            return;
                        }
                
                        logger.info("Отправка уведомлений: {} товаров для пользователя {}", products.size(), userId);
                
                        Set<String> productIds = new HashSet<>();
                        Map<String, Product> productMap = new HashMap<>();
                
                        for (Product p : products) {
                            productIds.add(p.getId());
                            productMap.put(p.getId(), p);
                        }
                
                        Set<String> sentProductIds = UserSentProductsManager.getSentProductsForUser(userId);
                        Set<String> newProductIds = new HashSet<>();
                
                        for (String productId : productIds) {
                            if (!sentProductIds.contains(productId)) {
                                newProductIds.add(productId);
                            }
                        }
                
                        if (newProductIds.isEmpty()) {
                            logger.debug("Нет новых товаров для пользователя {}", userId);
                            return;
                        }
                
                        List<Product> productsToSend = new ArrayList<>();
                        for (String productId : newProductIds) {
                            Product p = productMap.get(productId);
                            if (p != null) {
                                productsToSend.add(p);
                            }
                        }
                
                        logger.info("Будет отправлено {} новых товаров пользователю {} (всего найдено {})",
                                productsToSend.size(), userId, products.size());
                
                        UserSentProductsManager.markProductsAsSent(userId, newProductIds);
                
                        String summary = String.format("🔍 Найдено <b>%d новых товаров</b> по запросу: <i>%s</i>\n\n",
                                productsToSend.size(), escapeHtml(query));
                        TelegramNotificationService.sendHtmlMessage(userId, summary);
                
                        for (int i = 0; i < productsToSend.size(); i++) {
                            Product p = productsToSend.get(i);
                
                            try {
                                if (p.hasCoverImage()) {
                                    sendProductWithPhoto(userId, p, i + 1, productsToSend.size());
                                } else {
                                    sendProductAsText(userId, p, i + 1, productsToSend.size());
                                }
                
                                Thread.sleep(800);
                            } catch (InterruptedException e) {
                                Thread.currentThread().interrupt();
                                break;
                            } catch (Exception e) {
                                logger.error("Ошибка отправки уведомления для товара {}: {}", p.getId(), e.getMessage());
                            }
                        }
                    }
                
                    private void sendProductWithPhoto(long userId, Product p, int number, int total) {
                        try {
                            String caption = formatProductCaption(p, number, total);
                
                            boolean sent = TelegramNotificationService.sendPhotoWithHtmlCaption(userId,
                                    p.getCoverImageUrl(), caption);
                
                            if (!sent) {
                                sendProductAsText(userId, p, number, total);
                            }
                        } catch (Exception e) {
                            logger.warn("Failed to send photo for product {}, sending as text: {}",
                                    p.getId(), e.getMessage());
                            sendProductAsText(userId, p, number, total);
                        }
                    }
                
                    private void sendProductAsText(long userId, Product p, int number, int total) {
                        try {
                            String message = formatProductCaption(p, number, total);
                            TelegramNotificationService.sendHtmlMessage(userId, message);
                        } catch (Exception e) {
                            logger.error("Failed to send product text for {}: {}", p.getId(), e.getMessage());
                        }
                    }
                
                    private String formatProductCaption(Product p, int number, int total) {
                        String fullTitle = p.getTitle();
                        if (fullTitle == null || fullTitle.isEmpty() || "No title".equals(fullTitle)) {
                            fullTitle = "Товар #" + p.getId();
                        }
                
                        String titleLink = String.format("<a href=\"%s\"><b>%s</b></a>",
                                escapeHtml(p.getUrl()),
                                escapeHtml(fullTitle));
                
                        double priceYuan = p.getPrice();
                        double priceRub = priceYuan * 12;
                        String price = String.format("💰 <b>%.0f ¥</b> (≈%.0f руб.)",
                                priceYuan, priceRub);
                
                        String age = String.format("⏳ %s", p.getAgeDisplay());
                
                        String location = "";
                        if (p.getLocation() != null && !p.getLocation().isEmpty() && !"Не указано".equals(p.getLocation())) {
                            location = String.format("\n📍 %s", escapeHtml(p.getLocation()));
                        }
                
                        return String.format("%s\n\n%s\n%s%s", titleLink, price, age, location);
                    }
                
                    private String escapeHtml(String text) {
                        if (text == null) return "";
                        return text.replace("&", "&amp;")
                                .replace("<", "&lt;")
                                .replace(">", "&gt;")
                                .replace("\"", "&quot;")
                                .replace("'", "&#39;")
                                .replace("\n", "<br/>");
                    }
                
                    public boolean stopUserParser(long userId) {
                        UserSession session = userSessions.get(userId);
                        if (session != null) {
                            session.setRunning(false);
                            userSessions.remove(userId);
                            logger.info("Parser stopped for user {}", userId);
                            return true;
                        }
                        return false;
                    }
                
                    public boolean pauseUserParser(long userId) {
                        UserSession session = userSessions.get(userId);
                        if (session != null && session.isRunning()) {
                            session.setPaused(true);
                            logger.info("Parser paused for user {}", userId);
                            return true;
                        }
                        return false;
                    }
                
                    public boolean resumeUserParser(long userId) {
                        UserSession session = userSessions.get(userId);
                        if (session != null && session.isPaused()) {
                            session.setPaused(false);
                            logger.info("Parser resumed for user {}", userId);
                            return true;
                        }
                        return false;
                    }
                
                    public Map<String, Object> getUserStatus(long userId) {
                        UserSession session = userSessions.get(userId);
                        return session != null ? session.getDetailedStatus() : null;
                    }
                
                    public Map<String, Object> getGlobalStatistics() {
                        Map<String, Object> stats = new HashMap<>();
                        stats.put("totalUsers", userSessions.size());
                        stats.put("totalProductsFound", totalProductsFound);
                        stats.put("totalRequestsMade", totalRequestsMade);
                        stats.put("uptime", System.currentTimeMillis() - startTime.getTime());
                        stats.put("activeThreads", threadPool.getActiveCount());
                        stats.put("poolSize", threadPool.getPoolSize());
                        stats.put("dynamicCookiesEnabled", Config.isDynamicCookiesEnabled());
                        stats.put("cookiesValid", CookieService.hasValidCookies());
                        return stats;
                    }
                
                    private void logStatistics() {
                        logger.info("Stats: users={}, products={}, requests={}, threads={}/{}, cookiesValid={}",
                                userSessions.size(), totalProductsFound, totalRequestsMade,
                                threadPool.getActiveCount(), threadPool.getPoolSize(),
                                CookieService.hasValidCookies());
                    }
                
                    public List<Long> getActiveUsers() {
                        return new ArrayList<>(userSessions.keySet());
                    }
                
                    public boolean isUserParserRunning(long userId) {
                        UserSession session = userSessions.get(userId);
                        return session != null && session.isRunning();
                    }
                
                    public void shutdown() {
                        logger.info("Shutting down ThreadManager...");
                
                        for (long userId : new ArrayList<>(userSessions.keySet())) {
                            stopUserParser(userId);
                        }
                
                        threadPool.shutdown();
                        scheduler.shutdown();
                
                        try {
                            if (!threadPool.awaitTermination(30, TimeUnit.SECONDS)) {
                                threadPool.shutdownNow();
                            }
                            if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                                scheduler.shutdownNow();
                            }
                            logger.info("ThreadManager shutdown complete");
                        } catch (InterruptedException e) {
                            threadPool.shutdownNow();
                            scheduler.shutdownNow();
                            Thread.currentThread().interrupt();
                        }
                    }
                }
                ----------------------------------------
            [DIR] test

              [FILE] SimpleTest.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/test/SimpleTest.java
                Размер: 1033 байт
                Дата изменения: 2026-01-19T23:09:01.610800597Z
                Содержимое:
                ----------------------------------------
                package com.parser.test;
                
                import org.apache.http.client.methods.HttpGet;
                import org.apache.http.util.EntityUtils;
                
                public class SimpleTest {
                    public static void main(String[] args) throws Exception {
                        // Простой GET запрос на сайт
                        String url = "https://www.goofish.com/search?q=stone%20island&spm=a21ybx.search.searchInput.0";
                
                        HttpGet request = new HttpGet(url);
                        request.setHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36");
                
                        try (var response = org.apache.http.impl.client.HttpClients.createDefault().execute(request)) {
                            String body = EntityUtils.toString(response.getEntity());
                            System.out.println("Статус: " + response.getStatusLine().getStatusCode());
                            System.out.println("Длина ответа: " + body.length());
                            System.out.println("Первые 500 символов:");
                            System.out.println(body.substring(0, Math.min(500, body.length())));
                        }
                    }
                }
                ----------------------------------------

              [FILE] ApiTester.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/test/ApiTester.java
                Размер: 25478 байт
                Дата изменения: 2026-01-19T23:35:14.091230081Z
                Содержимое:
                ----------------------------------------
                package com.parser.test;
                
                import com.parser.service.CookieService;
                import org.apache.http.client.methods.HttpPost;
                import org.apache.http.entity.StringEntity;
                import org.apache.http.impl.client.CloseableHttpClient;
                import org.apache.http.impl.client.HttpClients;
                import org.apache.http.util.EntityUtils;
                import org.json.JSONArray;
                import org.json.JSONObject;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.io.ByteArrayInputStream;
                import java.io.ByteArrayOutputStream;
                import java.nio.charset.StandardCharsets;
                import java.security.MessageDigest;
                import java.util.Arrays;
                import java.util.HashMap;
                import java.util.LinkedHashMap;
                import java.util.Map;
                
                // Для zstd декомпрессии - две опции:
                // Вариант 1: Используем Apache Commons Compress (уже есть в зависимостях через docker-java)
                import org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream;
                // Или Вариант 2: Используем чистую Java библиотеку (добавить в pom.xml)
                // import com.github.luben.zstd.ZstdInputStream;
                
                public class ApiTester {
                    private static final Logger logger = LoggerFactory.getLogger(ApiTester.class);
                    private static final String APP_KEY = "34839810";
                
                    public static void main(String[] args) {
                        try {
                            System.out.println("🧪 Тестирование API Goofish с динамической подписью...");
                
                            // Инициализируем куки
                            CookieService.initialize();
                
                            // Получаем свежие куки
                            String domain = "h5api.m.goofish.com";
                            String cookieHeader = CookieService.getCookieHeader(domain);
                            System.out.println("🍪 Куки получены (длина: " + cookieHeader.length() + " символов)");
                
                            // Извлекаем токен из куки _m_h5_tk
                            String token = extractTokenFromCookies(cookieHeader);
                            if (token.isEmpty()) {
                                System.err.println("❌ Не удалось извлечь токен из куки");
                                return;
                            }
                            System.out.println("🔑 Токен: " + (token.length() > 20 ? token.substring(0, 17) + "..." : token));
                
                            // Используем текущее время
                            long timestamp = System.currentTimeMillis();
                            System.out.println("⏰ Текущее время: " + timestamp);
                
                            // Формируем данные для запроса
                            String data = buildSearchData("stone island", 1, 30);
                            System.out.println("📝 Данные запроса: " + data.substring(0, Math.min(100, data.length())) + "...");
                
                            // Генерируем подпись
                            String sign = generateSignature(token, timestamp, data);
                            System.out.println("🔐 Подпись: " + sign);
                
                            // Строим URL с параметрами
                            String url = buildApiUrl(timestamp, sign);
                            System.out.println("📤 URL запроса: " + url);
                
                            // Создаем POST запрос
                            HttpPost request = new HttpPost(url);
                
                            // Устанавливаем заголовки как в реальном браузере
                            setBrowserHeaders(request);
                
                            // Добавляем куки
                            if (cookieHeader != null && !cookieHeader.isEmpty()) {
                                request.setHeader("Cookie", cookieHeader);
                                System.out.println("✅ Добавлены куки в заголовок");
                            } else {
                                System.err.println("⚠️ Куки пустые!");
                            }
                
                            // Формируем тело запроса (application/x-www-form-urlencoded)
                            String formData = "data=" + java.net.URLEncoder.encode(data, "UTF-8");
                            request.setEntity(new StringEntity(formData, StandardCharsets.UTF_8));
                
                            // Выполняем запрос
                            try (CloseableHttpClient client = HttpClients.createDefault();
                                 var response = client.execute(request)) {
                
                                int statusCode = response.getStatusLine().getStatusCode();
                                String contentType = response.getFirstHeader("Content-Type") != null ?
                                        response.getFirstHeader("Content-Type").getValue() : "unknown";
                                String contentEncoding = response.getFirstHeader("Content-Encoding") != null ?
                                        response.getFirstHeader("Content-Encoding").getValue() : "unknown";
                
                                System.out.println("\n📥 Ответ сервера:");
                                System.out.println("Статус: " + statusCode);
                                System.out.println("Content-Type: " + contentType);
                                System.out.println("Content-Encoding: " + contentEncoding);
                
                                // Выводим заголовки ответа
                                System.out.println("\n📋 Заголовки ответа:");
                                for (org.apache.http.Header header : response.getAllHeaders()) {
                                    String headerName = header.getName();
                                    String headerValue = header.getValue();
                
                                    // Сокращаем длинные значения
                                    if (headerValue.length() > 100) {
                                        headerValue = headerValue.substring(0, 97) + "...";
                                    }
                
                                    System.out.println("  " + headerName + ": " + headerValue);
                
                                    // Отслеживаем обновление куки
                                    if ("Set-Cookie".equalsIgnoreCase(headerName)) {
                                        System.out.println("  ⚠️ Сервер обновил куки!");
                                    }
                                }
                
                                // Получаем сырые байты ответа
                                byte[] responseBytes = EntityUtils.toByteArray(response.getEntity());
                                String responseBody;
                
                                // Обрабатываем сжатие в зависимости от Content-Encoding
                                if ("zstd".equalsIgnoreCase(contentEncoding)) {
                                    System.out.println("\n🔄 Распаковываем zstd сжатие...");
                                    responseBody = decompressZstd(responseBytes);
                                } else if ("gzip".equalsIgnoreCase(contentEncoding) || "deflate".equalsIgnoreCase(contentEncoding)) {
                                    // HttpClient обычно автоматически обрабатывает gzip/deflate
                                    responseBody = new String(responseBytes, StandardCharsets.UTF_8);
                                } else {
                                    // Без сжатия
                                    responseBody = new String(responseBytes, StandardCharsets.UTF_8);
                                }
                
                                System.out.println("\n📄 Тело ответа:");
                                if (responseBody.length() > 1000) {
                                    System.out.println(responseBody.substring(0, 1000) + "...");
                                    System.out.println("... (полный ответ: " + responseBody.length() + " символов)");
                                } else {
                                    System.out.println(responseBody);
                                }
                
                                // Парсим JSON ответ
                                if (responseBody.trim().startsWith("{") || responseBody.trim().startsWith("[")) {
                                    try {
                                        JSONObject json = new JSONObject(responseBody);
                                        System.out.println("\n✅ JSON успешно распарсен");
                
                                        if (json.has("ret")) {
                                            Object ret = json.get("ret");
                                            System.out.println("ret: " + ret);
                
                                            if (ret instanceof org.json.JSONArray) {
                                                org.json.JSONArray retArray = (org.json.JSONArray) ret;
                                                for (int i = 0; i < retArray.length(); i++) {
                                                    String retItem = retArray.getString(i);
                                                    System.out.println("  ret[" + i + "]: " + retItem);
                
                                                    if (retItem.contains("FAIL_SYS_ILLEGAL_ACCESS")) {
                                                        System.err.println("❌ ОШИБКА: НЕЗАКОННЫЙ ЗАПРОС!");
                                                        System.err.println("   Причина: неверная подпись или устаревшие параметры");
                                                    } else if (retItem.contains("被挤爆啦")) {
                                                        System.err.println("❌ ОШИБКА: СЕРВЕР ПЕРЕГРУЖЕН!");
                                                        System.err.println("   Сообщение: " + retItem);
                                                    }
                                                }
                                            }
                                        }
                
                                        if (json.has("data")) {
                                            Object dataObj = json.get("data");
                                            System.out.println("data тип: " + dataObj.getClass().getSimpleName());
                
                                            if (dataObj instanceof JSONObject) {
                                                JSONObject dataJson = (JSONObject) dataObj;
                
                                                // Проверяем различные возможные структуры данных
                                                if (dataJson.has("resultList")) {
                                                    System.out.println("✅ Найдены товары в resultList!");
                                                    Object resultList = dataJson.get("resultList");
                                                    if (resultList instanceof JSONArray) {
                                                        JSONArray items = (JSONArray) resultList;
                                                        System.out.println("   Количество товаров: " + items.length());
                                                        for (int i = 0; i < Math.min(3, items.length()); i++) {
                                                            System.out.println("   Товар " + (i+1) + ": " + items.get(i));
                                                        }
                                                    }
                                                } else if (dataJson.has("items")) {
                                                    System.out.println("✅ Найдены товары в items!");
                                                } else if (dataJson.has("list")) {
                                                    System.out.println("✅ Найдены товары в list!");
                                                } else {
                                                    System.out.println("📊 Структура data: " + dataJson.toString(2));
                                                }
                                            } else if (dataObj instanceof String) {
                                                System.out.println("data (строка): " + dataObj);
                                                // Проверяем, не является ли это URL для редиректа/авторизации
                                                String dataStr = (String) dataObj;
                                                if (dataStr.contains("http") || dataStr.contains("login")) {
                                                    System.err.println("⚠️  Возможно требуется авторизация!");
                                                }
                                            }
                                        } else {
                                            System.out.println("📊 Полная структура JSON: " + json.toString(2));
                                        }
                
                                    } catch (Exception e) {
                                        System.err.println("❌ Ошибка парсинга JSON: " + e.getMessage());
                                        e.printStackTrace();
                
                                        // Показываем начало ответа для отладки
                                        if (responseBody.length() > 200) {
                                            System.err.println("Первые 200 символов ответа: " + responseBody.substring(0, 200));
                                        }
                                    }
                                } else {
                                    System.err.println("❌ Ответ не в формате JSON");
                                    if (responseBody.contains("<html") || responseBody.contains("<!DOCTYPE")) {
                                        System.err.println("⚠️ Получена HTML страница вместо JSON. Возможно, куки недействительны.");
                                    } else if (responseBody.length() < 100) {
                                        System.err.println("Короткий ответ: " + responseBody);
                                    }
                                }
                
                                // Анализ ответа
                                analyzeResponse(statusCode, responseBody);
                
                            }
                
                        } catch (Exception e) {
                            System.err.println("❌ Критическая ошибка: " + e.getMessage());
                            e.printStackTrace();
                        }
                    }
                
                    /**
                     * Распаковка zstd сжатых данных
                     */
                    /**
                     * Распаковка zstd сжатых данных
                     */
                    private static String decompressZstd(byte[] compressedData) {
                        try {
                            System.out.println("📦 Размер сжатых данных: " + compressedData.length + " байт");
                
                            try (ByteArrayInputStream bais = new ByteArrayInputStream(compressedData);
                                 org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream zstdIn =
                                         new org.apache.commons.compress.compressors.zstandard.ZstdCompressorInputStream(bais);
                                 ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
                
                                byte[] buffer = new byte[8192];
                                int len;
                                while ((len = zstdIn.read(buffer)) > 0) {
                                    baos.write(buffer, 0, len);
                                }
                
                                String result = baos.toString("UTF-8");
                                System.out.println("✅ Zstd успешно распакован");
                                System.out.println("📄 Размер распакованных данных: " + result.length() + " символов");
                                return result;
                            }
                
                        } catch (Exception e) {
                            System.err.println("❌ Ошибка распаковки zstd: " + e.getMessage());
                            e.printStackTrace();
                
                            // Пробуем прочитать как обычную строку (на случай, если это не zstd)
                            try {
                                String fallback = new String(compressedData, StandardCharsets.UTF_8);
                                System.out.println("⚠️  Используем fallback чтение как UTF-8");
                                return fallback;
                            } catch (Exception e2) {
                                return "Ошибка при обработке ответа: " + e.getMessage();
                            }
                        }
                    }
                
                    /**
                     * Извлечение токена из строки куки
                     */
                    private static String extractTokenFromCookies(String cookieHeader) {
                        if (cookieHeader == null || cookieHeader.isEmpty()) {
                            return "";
                        }
                
                        // Разделяем куки по точке с запятой
                        String[] cookiePairs = cookieHeader.split("; ");
                        for (String pair : cookiePairs) {
                            if (pair.startsWith("_m_h5_tk=")) {
                                String value = pair.substring(9); // Убираем "_m_h5_tk="
                                // Токен - часть до первого подчеркивания
                                int underscoreIndex = value.indexOf('_');
                                if (underscoreIndex != -1) {
                                    return value.substring(0, underscoreIndex);
                                }
                                return value;
                            }
                        }
                
                        return "";
                    }
                
                    /**
                     * Генерация подписи MD5
                     */
                    private static String generateSignature(String token, long timestamp, String data) {
                        try {
                            String signString = token + "&" + timestamp + "&" + APP_KEY + "&" + data;
                
                            MessageDigest md = MessageDigest.getInstance("MD5");
                            byte[] hash = md.digest(signString.getBytes(StandardCharsets.UTF_8));
                
                            StringBuilder hex = new StringBuilder();
                            for (byte b : hash) {
                                String h = Integer.toHexString(0xff & b);
                                if (h.length() == 1) {
                                    hex.append('0');
                                }
                                hex.append(h);
                            }
                
                            return hex.toString();
                        } catch (Exception e) {
                            System.err.println("❌ Ошибка генерации подписи: " + e.getMessage());
                            return "";
                        }
                    }
                
                    /**
                     * Формирование данных для поиска
                     */
                    private static String buildSearchData(String query, int page, int rows) {
                        JSONObject data = new JSONObject();
                        data.put("pageNumber", page);
                        data.put("keyword", query);
                        data.put("fromFilter", false);
                        data.put("rowsPerPage", rows);
                        data.put("sortValue", "");
                        data.put("sortField", "");
                        data.put("customDistance", "");
                        data.put("gps", "");
                        data.put("propValueStr", new JSONObject());
                        data.put("customGps", "");
                        data.put("searchReqFromPage", "pcSearch");
                        data.put("extraFilterValue", "{}");
                        data.put("userPositionJson", "{}");
                
                        return data.toString();
                    }
                
                    /**
                     * Построение URL API с параметрами
                     */
                    private static String buildApiUrl(long timestamp, String sign) {
                        Map<String, String> params = new LinkedHashMap<>();
                        params.put("jsv", "2.7.2");
                        params.put("appKey", APP_KEY);
                        params.put("t", String.valueOf(timestamp));
                        params.put("sign", sign);
                        params.put("v", "1.0");
                        params.put("type", "originaljson");
                        params.put("accountSite", "xianyu");
                        params.put("dataType", "json");
                        params.put("timeout", "20000");
                        params.put("api", "mtop.taobao.idlemtopsearch.pc.search");
                        params.put("sessionOption", "AutoLoginOnly");
                        params.put("spm_cnt", "a21ybx.search.0.0");
                        params.put("spm_pre", "a21ybx.search.searchInput.0");
                
                        StringBuilder url = new StringBuilder("https://h5api.m.goofish.com/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/?");
                
                        boolean first = true;
                        for (Map.Entry<String, String> entry : params.entrySet()) {
                            if (!first) {
                                url.append("&");
                            }
                            url.append(entry.getKey())
                                    .append("=")
                                    .append(java.net.URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8));
                            first = false;
                        }
                
                        return url.toString();
                    }
                
                    /**
                     * Установка заголовков браузера
                     */
                    private static void setBrowserHeaders(HttpPost request) {
                        request.setHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 YaBrowser/25.10.0.0 Safari/537.36");
                        request.setHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");
                        request.setHeader("Accept", "application/json");
                        request.setHeader("Accept-Encoding", "gzip, deflate, br, zstd");
                        request.setHeader("Accept-Language", "ru,en;q=0.9");
                        request.setHeader("Origin", "https://www.goofish.com");
                        request.setHeader("Referer", "https://www.goofish.com/");
                        request.setHeader("Sec-Fetch-Dest", "empty");
                        request.setHeader("Sec-Fetch-Mode", "cors");
                        request.setHeader("Sec-Fetch-Site", "same-site");
                        request.setHeader("sec-ch-ua", "\"Chromium\";v=\"140\", \"Not=A?Brand\";v=\"24\", \"YaBrowser\";v=\"25.10\", \"Yowser\";v=\"2.5\", \"YaBrowserCorp\";v=\"140\"");
                        request.setHeader("sec-ch-ua-mobile", "?0");
                        request.setHeader("sec-ch-ua-platform", "\"macOS\"");
                        request.setHeader("x-accept-terminal", "pc");
                        request.setHeader("Connection", "keep-alive");
                        request.setHeader("Pragma", "no-cache");
                        request.setHeader("Cache-Control", "no-cache");
                    }
                
                    /**
                     * Анализ ответа сервера
                     */
                    private static void analyzeResponse(int statusCode, String responseBody) {
                        System.out.println("\n🔍 Анализ ответа:");
                
                        if (statusCode == 200) {
                            System.out.println("✅ HTTP статус: 200 OK");
                
                            if (responseBody.contains("FAIL_SYS_ILLEGAL_ACCESS")) {
                                System.err.println("❌ Содержимое: НЕЗАКОННЫЙ ЗАПРОС");
                                System.err.println("   Возможные причины:");
                                System.err.println("   1. Неверная подпись (sign)");
                                System.err.println("   2. Устаревший timestamp (t)");
                                System.err.println("   3. Неверный токен из куки _m_h5_tk");
                                System.err.println("   4. Неверный формат данных (data)");
                            } else if (responseBody.contains("FAIL_SYS_SESSION_EXPIRED")) {
                                System.err.println("❌ Содержимое: СЕССИЯ ИСТЕКЛА");
                                System.err.println("   Требуется обновление куки");
                            } else if (responseBody.contains("SUCCESS")) {
                                System.out.println("✅ Содержимое: УСПЕШНЫЙ ЗАПРОС");
                            } else if (responseBody.contains("resultList") || responseBody.contains("\"data\":")) {
                                System.out.println("✅ Содержимое: НАЙДЕНЫ ДАННЫЕ");
                            } else if (responseBody.contains("\"ret\":") && responseBody.contains("SUCCESS")) {
                                System.out.println("✅ Содержимое: API УСПЕШНО ВЫПОЛНЕНО");
                            } else {
                                System.out.println("⚠️  Содержимое: НЕИЗВЕСТНЫЙ ОТВЕТ");
                                System.out.println("   Первые 200 символов: " +
                                        (responseBody.length() > 200 ? responseBody.substring(0, 200) + "..." : responseBody));
                            }
                        } else if (statusCode == 403) {
                            System.err.println("❌ HTTP статус: 403 FORBIDDEN");
                            System.err.println("   Доступ запрещен. Возможно, куки недействительны.");
                        } else if (statusCode == 429) {
                            System.err.println("❌ HTTP статус: 429 TOO MANY REQUESTS");
                            System.err.println("   Слишком много запросов. Нужно добавить задержку.");
                        } else if (statusCode == 401) {
                            System.err.println("❌ HTTP статус: 401 UNAUTHORIZED");
                            System.err.println("   Требуется авторизация. Куки устарели.");
                        } else {
                            System.err.println("❌ HTTP статус: " + statusCode);
                        }
                    }
                
                    /**
                     * Дополнительный метод для отладки куки
                     */
                    private static void debugCookies(String cookieHeader) {
                        System.out.println("\n🔍 Отладка куки:");
                
                        if (cookieHeader == null || cookieHeader.isEmpty()) {
                            System.err.println("❌ Куки пустые");
                            return;
                        }
                
                        String[] cookies = cookieHeader.split("; ");
                        System.out.println("📊 Всего куки: " + cookies.length);
                
                        // Важные куки для проверки
                        String[] importantCookies = {"_m_h5_tk", "_m_h5_tk_enc", "_tb_token_", "cna", "cookie2", "t", "tfstk"};
                
                        for (String cookie : cookies) {
                            String[] parts = cookie.split("=", 2);
                            if (parts.length == 2) {
                                String name = parts[0];
                                String value = parts[1];
                
                                // Проверяем, важная ли это кука
                                boolean isImportant = Arrays.asList(importantCookies).contains(name);
                
                                if (isImportant) {
                                    System.out.print("⭐ ");
                                } else {
                                    System.out.print("   ");
                                }
                
                                System.out.print(String.format("%-25s", name + ":"));
                
                                // Обрезаем длинные значения
                                if (value.length() > 50) {
                                    System.out.println(value.substring(0, 47) + "...");
                                } else {
                                    System.out.println(value);
                                }
                
                                // Особый анализ для _m_h5_tk
                                if ("_m_h5_tk".equals(name)) {
                                    if (value.contains("_")) {
                                        String[] tokenParts = value.split("_", 2);
                                        System.out.println("        Токен: " + tokenParts[0]);
                                        System.out.println("        Время: " + tokenParts[1]);
                                        System.out.println("        Статус: " + (tokenParts[0].length() == 32 ? "✅ Корректный" : "❌ Некорректный"));
                                    } else {
                                        System.err.println("        ⚠️ Нет временной метки в _m_h5_tk!");
                                    }
                                }
                            }
                        }
                    }
                }
                ----------------------------------------
            [DIR] util

              [FILE] HttpUtils.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/util/HttpUtils.java
                Размер: 20508 байт
                Дата изменения: 2026-01-19T09:31:29.777394501Z
                Содержимое:
                ----------------------------------------
                package com.parser.util;
                
                import com.parser.config.Config;
                import com.parser.config.CookieConfig;
                import com.parser.service.CookieService;
                import org.apache.http.HttpHeaders;
                import org.apache.http.HttpStatus;
                import org.apache.http.client.config.CookieSpecs;
                import org.apache.http.client.config.RequestConfig;
                import org.apache.http.client.methods.CloseableHttpResponse;
                import org.apache.http.client.methods.HttpGet;
                import org.apache.http.client.methods.HttpPost;
                import org.apache.http.entity.StringEntity;
                import org.apache.http.impl.client.CloseableHttpClient;
                import org.apache.http.impl.client.HttpClients;
                import org.apache.http.impl.client.LaxRedirectStrategy;
                import org.apache.http.util.EntityUtils;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.net.URL;
                import java.nio.charset.StandardCharsets;
                import java.util.HashMap;
                import java.util.Map;
                import java.util.Random;
                
                /**
                 * Утилиты для работы с HTTP запросами
                 */
                public class HttpUtils {
                    private static final Logger logger = LoggerFactory.getLogger(HttpUtils.class);
                    private static final Random random = new Random();
                
                    // Константы для заголовков кук
                    private static final String HEADER_COOKIE = "Cookie";
                    private static final String HEADER_SET_COOKIE = "Set-Cookie";
                    private static final String HEADER_CONTENT_LENGTH = "Content-Length";
                
                    // Конфигурация HTTP клиента
                    private static final RequestConfig requestConfig = RequestConfig.custom()
                            .setConnectTimeout(Config.getHttpConnectTimeout())
                            .setSocketTimeout(Config.getHttpReadTimeout())
                            .setConnectionRequestTimeout(5000)
                            .setRedirectsEnabled(true)
                            .setCookieSpec(CookieSpecs.STANDARD)
                            .build();
                
                    // Пул HTTP клиентов
                    private static volatile CloseableHttpClient httpClient = null;
                
                    /**
                     * Получение HTTP клиента
                     */
                    private static synchronized CloseableHttpClient getHttpClient() {
                        if (httpClient == null) {
                            httpClient = HttpClients.custom()
                                    .setDefaultRequestConfig(requestConfig)
                                    .setRedirectStrategy(new LaxRedirectStrategy())
                                    .setUserAgent(getRandomUserAgent())
                                    .setMaxConnTotal(100)
                                    .setMaxConnPerRoute(20)
                                    .disableCookieManagement() // Управляем куками вручную
                                    .build();
                            logger.debug("HTTP client initialized");
                        }
                        return httpClient;
                    }
                
                    /**
                     * Отправка GET запроса
                     */
                    public static String sendGetRequest(String url) throws Exception {
                        return sendGetRequest(url, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * Отправка GET запроса с указанием User-Agent
                     */
                    public static String sendGetRequest(String url, String userAgent) throws Exception {
                        return sendGetRequest(url, userAgent, true);
                    }
                
                    /**
                     * Отправка GET запроса с расширенными параметрами
                     */
                    public static String sendGetRequest(String url, String userAgent, boolean useCookies) throws Exception {
                        if (url == null || url.isEmpty()) {
                            throw new IllegalArgumentException("URL cannot be empty");
                        }
                
                        logger.debug("Sending GET request to: {}", url);
                
                        HttpGet request = new HttpGet(url);
                        request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                        request.setHeader(HttpHeaders.ACCEPT, "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8");
                        request.setHeader(HttpHeaders.ACCEPT_LANGUAGE, "en-US,en;q=0.9,ru;q=0.8");
                        request.setHeader(HttpHeaders.ACCEPT_ENCODING, "gzip, deflate, br");
                        request.setHeader(HttpHeaders.CONNECTION, "keep-alive");
                        request.setHeader("Upgrade-Insecure-Requests", "1");
                
                        // Добавляем куки, если требуется
                        if (useCookies) {
                            String domain = extractDomain(url);
                            try {
                                // Используем динамические куки из CookieService
                                String cookieHeader = CookieService.getCookieHeader(domain);
                                if (cookieHeader != null && !cookieHeader.isEmpty()) {
                                    request.setHeader(HEADER_COOKIE, cookieHeader);
                                    logger.debug("Added dynamic cookies for domain {} ({} chars)",
                                            domain, cookieHeader.length());
                                } else {
                                    logger.warn("No dynamic cookies available for domain: {}", domain);
                                    // Fallback на статические куки
                                    String cookies = CookieConfig.getCookiesForDomain(domain);
                                    if (cookies != null && !cookies.isEmpty()) {
                                        request.setHeader(HEADER_COOKIE, cookies);
                                        logger.debug("Using static cookies for domain: {}", domain);
                                    }
                                }
                            } catch (Exception e) {
                                logger.warn("Failed to get dynamic cookies for {}, falling back to static: {}",
                                        domain, e.getMessage());
                                // Fallback на статические куки
                                String cookies = CookieConfig.getCookiesForDomain(domain);
                                if (cookies != null && !cookies.isEmpty()) {
                                    request.setHeader(HEADER_COOKIE, cookies);
                                    logger.debug("Using static cookies for domain: {}", domain);
                                }
                            }
                        }
                
                        // Добавляем случайные заголовки для имитации браузера
                        addRandomHeaders(request);
                
                        try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                            int statusCode = response.getStatusLine().getStatusCode();
                            logger.debug("Response status: {} for URL: {}", statusCode, url);
                
                            // Обновляем куки из ответа, если требуется
                            if (Config.getCookieAutoUpdate() && useCookies) {
                                updateCookiesFromResponse(url, response);
                            }
                
                            if (statusCode == HttpStatus.SC_OK) {
                                String content = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
                                logger.trace("Response content length: {} chars for URL: {}", content.length(), url);
                                return content;
                            } else if (statusCode == HttpStatus.SC_TOO_MANY_REQUESTS) {
                                logger.warn("Rate limit exceeded for URL: {}", url);
                                throw new Exception("Rate limit exceeded (429)");
                            } else if (statusCode == HttpStatus.SC_FORBIDDEN) {
                                logger.warn("Access forbidden for URL: {}", url);
                                throw new Exception("Access forbidden (403) - May need fresh cookies");
                            } else if (statusCode == HttpStatus.SC_NOT_FOUND) {
                                logger.warn("URL not found: {}", url);
                                throw new Exception("Page not found (404)");
                            } else if (statusCode == HttpStatus.SC_UNAUTHORIZED) {
                                logger.warn("Unauthorized for URL: {}", url);
                                throw new Exception("Unauthorized (401) - Check cookies");
                            } else {
                                logger.warn("HTTP error {} for URL: {}", statusCode, url);
                                throw new Exception("HTTP error: " + statusCode);
                            }
                        } catch (Exception e) {
                            logger.error("Error sending request to {}: {}", url, e.getMessage());
                            throw e;
                        }
                    }
                
                    /**
                     * Отправка POST запроса
                     */
                    public static String sendPostRequest(String url, String jsonBody) throws Exception {
                        return sendPostRequest(url, jsonBody, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * Отправка POST запроса с расширенными параметрами
                     */
                    public static String sendPostRequest(String url, String jsonBody, String userAgent, boolean useCookies) throws Exception {
                        logger.debug("Sending POST request to: {}", url);
                
                        HttpPost request = new HttpPost(url);
                        request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                        request.setHeader(HttpHeaders.CONTENT_TYPE, "application/json");
                        request.setHeader(HttpHeaders.ACCEPT, "application/json");
                        request.setHeader(HttpHeaders.ACCEPT_ENCODING, "gzip, deflate, br");
                
                        if (jsonBody != null && !jsonBody.isEmpty()) {
                            request.setEntity(new StringEntity(jsonBody, StandardCharsets.UTF_8));
                        }
                
                        // Добавляем куки
                        if (useCookies) {
                            String domain = extractDomain(url);
                            String cookieHeader = CookieService.getCookieHeader(domain);
                            if (cookieHeader != null && !cookieHeader.isEmpty()) {
                                request.setHeader(HEADER_COOKIE, cookieHeader);
                            }
                        }
                
                        try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                            int statusCode = response.getStatusLine().getStatusCode();
                            if (statusCode == HttpStatus.SC_OK) {
                                String content = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
                                logger.debug("POST response length: {} chars", content.length());
                                return content;
                            } else {
                                throw new Exception("HTTP POST error: " + statusCode);
                            }
                        }
                    }
                
                    /**
                     * Извлечение домена из URL
                     */
                    public static String extractDomain(String url) {
                        try {
                            URL urlObj = new URL(url);
                            return urlObj.getHost();
                        } catch (Exception e) {
                            logger.warn("Failed to extract domain from URL: {}", url);
                            return "";
                        }
                    }
                
                    /**
                     * Обновление куки из заголовков ответа
                     */
                    private static void updateCookiesFromResponse(String url, CloseableHttpResponse response) {
                        try {
                            String domain = extractDomain(url);
                            org.apache.http.Header[] setCookieHeaders = response.getHeaders(HEADER_SET_COOKIE);
                
                            if (setCookieHeaders.length > 0) {
                                logger.debug("Found {} Set-Cookie headers for domain: {}", setCookieHeaders.length, domain);
                                for (org.apache.http.Header header : setCookieHeaders) {
                                    CookieConfig.parseSetCookieHeader(domain, header.getValue());
                                }
                                CookieConfig.saveCookies();
                            }
                        } catch (Exception e) {
                            logger.warn("Failed to update cookies from response: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение стандартного User-Agent
                     */
                    public static String getDefaultUserAgent() {
                        return Config.getHttpUserAgent();
                    }
                
                    /**
                     * Получение случайного User-Agent
                     */
                    public static String getRandomUserAgent() {
                        String[] userAgents = {
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0",
                                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                                "Mozilla/5.0 (iPhone; CPU iPhone OS 17_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Mobile/15E148 Safari/604.1",
                                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 YaBrowser/25.10.0.0 Safari/537.36"
                        };
                
                        return userAgents[random.nextInt(userAgents.length)];
                    }
                
                    /**
                     * Добавление случайных заголовков для имитации браузера
                     */
                    private static void addRandomHeaders(HttpGet request) {
                        if (random.nextBoolean()) {
                            request.setHeader("Sec-Fetch-Dest", "document");
                            request.setHeader("Sec-Fetch-Mode", "navigate");
                            request.setHeader("Sec-Fetch-Site", "none");
                            request.setHeader("Sec-Fetch-User", "?1");
                        }
                
                        if (random.nextBoolean()) {
                            request.setHeader(HttpHeaders.CACHE_CONTROL, "max-age=0");
                        }
                
                        // Случайный Referer
                        String[] referers = {
                                "https://www.google.com/",
                                "https://www.bing.com/",
                                "https://www.yahoo.com/",
                                "https://www.baidu.com/",
                                "https://h5.m.goofish.com/",
                                "https://www.goofish.com/",
                                ""
                        };
                        String referer = referers[random.nextInt(referers.length)];
                        if (!referer.isEmpty()) {
                            request.setHeader(HttpHeaders.REFERER, referer);
                        }
                    }
                
                    /**
                     * Кодирование URL параметров
                     */
                    public static String encodeUrl(String value) {
                        if (value == null) {
                            return "";
                        }
                        try {
                            return java.net.URLEncoder.encode(value, StandardCharsets.UTF_8.toString());
                        } catch (Exception e) {
                            logger.error("Error encoding URL value: {}", e.getMessage());
                            return value;
                        }
                    }
                
                    /**
                     * Декодирование URL параметров
                     */
                    public static String decodeUrl(String value) {
                        if (value == null) {
                            return "";
                        }
                        try {
                            return java.net.URLDecoder.decode(value, StandardCharsets.UTF_8.toString());
                        } catch (Exception e) {
                            logger.error("Error decoding URL value: {}", e.getMessage());
                            return value;
                        }
                    }
                
                    /**
                     * Создание случайной задержки для имитации человеческого поведения
                     */
                    public static void randomDelay(int minMs, int maxMs) {
                        try {
                            int delay = minMs + random.nextInt(maxMs - minMs);
                            Thread.sleep(delay);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            logger.warn("Delay interrupted");
                        }
                    }
                
                    /**
                     * Проверка доступности URL
                     */
                    public static boolean isUrlAccessible(String url) {
                        return isUrlAccessible(url, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * Проверка доступности URL с указанием использования куки
                     */
                    public static boolean isUrlAccessible(String url, String userAgent, boolean useCookies) {
                        try {
                            HttpGet request = new HttpGet(url);
                            request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                
                            if (useCookies) {
                                String domain = extractDomain(url);
                                String cookies = CookieConfig.getCookiesForDomain(domain);
                                if (cookies != null && !cookies.isEmpty()) {
                                    request.setHeader(HEADER_COOKIE, cookies);
                                }
                            }
                
                            try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                                int statusCode = response.getStatusLine().getStatusCode();
                                return statusCode == HttpStatus.SC_OK;
                            }
                        } catch (Exception e) {
                            logger.debug("URL not accessible {}: {}", url, e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Получение размера содержимого по URL
                     */
                    public static long getContentLength(String url) throws Exception {
                        return getContentLength(url, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * Получение размера содержимого по URL с указанием использования куки
                     */
                    public static long getContentLength(String url, String userAgent, boolean useCookies) throws Exception {
                        try {
                            HttpGet request = new HttpGet(url);
                            request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                
                            if (useCookies) {
                                String domain = extractDomain(url);
                                String cookies = CookieConfig.getCookiesForDomain(domain);
                                if (cookies != null && !cookies.isEmpty()) {
                                    request.setHeader(HEADER_COOKIE, cookies);
                                }
                            }
                
                            try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                                if (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {
                                    org.apache.http.Header[] headers = response.getHeaders(HEADER_CONTENT_LENGTH);
                                    if (headers.length > 0) {
                                        try {
                                            return Long.parseLong(headers[0].getValue());
                                        } catch (NumberFormatException e) {
                                            return -1;
                                        }
                                    }
                                }
                                return -1;
                            }
                        } catch (Exception e) {
                            logger.error("Error getting content length for {}: {}", url, e.getMessage());
                            throw e;
                        }
                    }
                
                    /**
                     * Проверка валидности куки
                     */
                    public static boolean testCookies(String url) {
                        try {
                            logger.info("Testing cookies for URL: {}", url);
                            String response = sendGetRequest(url, getDefaultUserAgent(), true);
                
                            // Проверяем ответ на признаки того, что мы авторизованы
                            if (response.contains("登录") || response.contains("login") ||
                                    response.contains("未登录") || response.contains("未授权") ||
                                    response.contains("请登录") || response.contains("signin")) {
                                logger.warn("Cookies appear to be invalid or expired");
                                return false;
                            }
                
                            logger.info("Cookies test successful for: {}", url);
                            return true;
                        } catch (Exception e) {
                            logger.error("Cookies test failed for {}: {}", url, e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Закрытие HTTP клиента
                     */
                    public static synchronized void closeHttpClient() {
                        if (httpClient != null) {
                            try {
                                httpClient.close();
                                httpClient = null;
                                logger.debug("HTTP client closed");
                            } catch (Exception e) {
                                logger.error("Error closing HTTP client: {}", e.getMessage());
                            }
                        }
                    }
                
                    /**
                     * Создание URL с параметрами
                     */
                    public static String buildUrlWithParams(String baseUrl, Map<String, String> params) {
                        StringBuilder url = new StringBuilder(baseUrl);
                        if (params != null && !params.isEmpty()) {
                            url.append("?");
                            boolean first = true;
                            for (Map.Entry<String, String> entry : params.entrySet()) {
                                if (!first) {
                                    url.append("&");
                                }
                                url.append(encodeUrl(entry.getKey()))
                                        .append("=")
                                        .append(encodeUrl(entry.getValue()));
                                first = false;
                            }
                        }
                        return url.toString();
                    }
                
                    /**
                     * Создание URL с параметрами из массива
                     */
                    public static String buildUrlWithParams(String baseUrl, String[][] params) {
                        Map<String, String> paramMap = new HashMap<>();
                        if (params != null) {
                            for (String[] param : params) {
                                if (param.length >= 2) {
                                    paramMap.put(param[0], param[1]);
                                }
                            }
                        }
                        return buildUrlWithParams(baseUrl, paramMap);
                    }
                
                    /**
                     * Получение HTTP клиента для внешнего использования
                     */
                    public static CloseableHttpClient getHttpClientInstance() {
                        return getHttpClient();
                    }
                }
                ----------------------------------------
            [DIR] config

              [FILE] ParserSettings.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/config/ParserSettings.java
                Размер: 3366 байт
                Дата изменения: 2026-01-19T09:31:29.768131546Z
                Содержимое:
                ----------------------------------------
                package com.parser.config;
                
                /**
                 * Класс с константами для настроек парсера
                 */
                public class ParserSettings {
                    // Минимальные и максимальные значения для валидации
                
                    public static final int MIN_CHECK_INTERVAL = 20; // секунд
                    public static final int MAX_CHECK_INTERVAL = 3600; // секунд
                
                    public static final int MIN_MAX_AGE_MINUTES = 1;
                    public static final int MAX_MAX_AGE_MINUTES = 10080; // 7 дней
                
                    public static final int MIN_MAX_PAGES = 1;
                    public static final int MAX_MAX_PAGES = 50;
                
                    public static final int MIN_ROWS_PER_PAGE = 10;
                    public static final int MAX_ROWS_PER_PAGE = 1000;
                
                    // Коды валют
                    public static final String CURRENCY_YUAN = "yuan";
                    public static final String CURRENCY_RUBLES = "rubles";
                
                    // Поддерживаемые сайты
                    public static final String SITE_GOOFISH = "goofish";
                    public static final String SITE_TAOBAO = "taobao";
                    public static final String SITE_JD = "jd";
                
                    // Статусы парсера
                    public static final String STATUS_RUNNING = "running";
                    public static final String STATUS_STOPPED = "stopped";
                    public static final String STATUS_PAUSED = "paused";
                    public static final String STATUS_ERROR = "error";
                
                    // Типы уведомлений
                    public static final String NOTIFY_TELEGRAM = "telegram";
                    public static final String NOTIFY_EMAIL = "email";
                    public static final String NOTIFY_WEBHOOK = "webhook";
                
                    /**
                     * Валидация интервала проверки
                     */
                    public static boolean isValidCheckInterval(int interval) {
                        return interval >= MIN_CHECK_INTERVAL && interval <= MAX_CHECK_INTERVAL;
                    }
                
                    /**
                     * Валидация максимального возраста товара
                     */
                    public static boolean isValidMaxAge(int maxAge) {
                        return maxAge >= MIN_MAX_AGE_MINUTES && maxAge <= MAX_MAX_AGE_MINUTES;
                    }
                
                    /**
                     * Нормализация интервала проверки
                     */
                    public static int normalizeCheckInterval(int interval) {
                        return Math.max(MIN_CHECK_INTERVAL, Math.min(interval, MAX_CHECK_INTERVAL));
                    }
                
                    /**
                     * Нормализация максимального возраста
                     */
                    public static int normalizeMaxAge(int maxAge) {
                        return Math.max(MIN_MAX_AGE_MINUTES, Math.min(maxAge, MAX_MAX_AGE_MINUTES));
                    }
                
                    /**
                     * Проверка поддержки сайта
                     */
                    public static boolean isSiteSupported(String site) {
                        return SITE_GOOFISH.equalsIgnoreCase(site) ||
                                SITE_TAOBAO.equalsIgnoreCase(site) ||
                                SITE_JD.equalsIgnoreCase(site);
                    }
                
                    /**
                     * Получение курса валюты (обновленный актуальный курс)
                     */
                    public static double getCurrencyRate(String fromCurrency, String toCurrency) {
                        if (CURRENCY_YUAN.equals(fromCurrency) && CURRENCY_RUBLES.equals(toCurrency)) {
                            return 14.0; // Обновленный курс юаня к рублю (январь 2026)
                        } else if (CURRENCY_RUBLES.equals(fromCurrency) && CURRENCY_YUAN.equals(toCurrency)) {
                            return 1.0 / 14.0; // Обратный курс
                        }
                        return 1.0;
                    }
                }
                ----------------------------------------

              [FILE] Config.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/config/Config.java
                Размер: 7360 байт
                Дата изменения: 2026-01-28T19:39:31.93253313Z
                Содержимое:
                ----------------------------------------
                package com.parser.config;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.*;
                import java.util.Properties;
                
                /**
                 * Класс для управления конфигурацией приложения
                 */
                public class Config {
                    private static final Logger logger = LoggerFactory.getLogger(Config.class);
                    private static final Properties properties = new Properties();
                    private static final String CONFIG_FILE = "config.properties";
                    private static volatile boolean isLoaded = false;
                
                    static {
                        synchronized (Config.class) {
                            if (!isLoaded) {
                                loadProperties();
                                isLoaded = true;
                            }
                        }
                    }
                
                    private static void loadProperties() {
                        File externalConfig = new File(CONFIG_FILE);
                        if (externalConfig.exists()) {
                            try (InputStream input = new FileInputStream(externalConfig)) {
                                properties.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded configuration from: {}", CONFIG_FILE);
                                return;
                            } catch (IOException e) {
                                logger.warn("Failed to load external config: {}", e.getMessage());
                            }
                        }
                
                        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(CONFIG_FILE)) {
                            if (input != null) {
                                properties.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded configuration from resources");
                            } else {
                                setDefaults();
                                logger.warn("Config file not found, using defaults");
                            }
                        } catch (IOException e) {
                            setDefaults();
                            logger.error("Error loading config: {}", e.getMessage());
                        }
                    }
                
                    private static void setDefaults() {
                        properties.setProperty("telegram.bot.token", "");
                        properties.setProperty("telegram.bot.username", "");
                        properties.setProperty("telegram.admin.id", "0");
                        properties.setProperty("parser.default.check_interval", "300");
                        properties.setProperty("parser.default.max_age_minutes", "1440");
                        properties.setProperty("parser.default.max_pages", "3");
                        properties.setProperty("parser.default.rows_per_page", "100");
                        properties.setProperty("thread.pool.core.size", "3");
                        properties.setProperty("thread.pool.max.size", "10");
                        properties.setProperty("thread.pool.keepalive.seconds", "60");
                        properties.setProperty("storage.data.dir", "./data");
                        properties.setProperty("storage.backup.enabled", "true");
                        properties.setProperty("http.connect.timeout", "10000");
                        properties.setProperty("http.read.timeout", "15000");
                        properties.setProperty("http.user.agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36");
                        properties.setProperty("cookie.auto.update", "true");
                        properties.setProperty("cookie.update.interval.minutes", "120");
                        properties.setProperty("cookie.dynamic.enabled", "true");
                        properties.setProperty("cookie.cache.ttl.minutes", "30");
                        properties.setProperty("logging.level", "INFO");
                        properties.setProperty("api.goofish.delay.between.requests", "2000");
                    }
                
                    public static int getInt(String key, int defaultValue) {
                        try {
                            return Integer.parseInt(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid integer for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    public static long getLong(String key, long defaultValue) {
                        try {
                            return Long.parseLong(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid long for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    public static String getString(String key, String defaultValue) {
                        String value = properties.getProperty(key, defaultValue);
                        return value != null ? value.trim() : defaultValue;
                    }
                
                    public static boolean getBoolean(String key, boolean defaultValue) {
                        String value = properties.getProperty(key, String.valueOf(defaultValue));
                        return value != null && (value.trim().toLowerCase().matches("true|yes|1"));
                    }
                
                    public static double getDouble(String key, double defaultValue) {
                        try {
                            return Double.parseDouble(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid double for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    public static void setProperty(String key, String value) {
                        properties.setProperty(key, value);
                    }
                
                    public static void saveConfig() {
                        try (OutputStream output = new FileOutputStream(CONFIG_FILE)) {
                            properties.store(output, "Product Parser Configuration");
                            logger.info("Configuration saved");
                        } catch (IOException e) {
                            logger.error("Failed to save configuration: {}", e.getMessage());
                        }
                    }
                
                    public static void reload() {
                        synchronized (Config.class) {
                            properties.clear();
                            loadProperties();
                            logger.info("Configuration reloaded");
                        }
                    }
                
                    // Convenience methods
                    public static String getTelegramBotToken() {
                        return getString("telegram.bot.token", "");
                    }
                
                    public static String getTelegramBotUsername() {
                        return getString("telegram.bot.username", "");
                    }
                
                    public static long getTelegramAdminId() {
                        return getLong("telegram.admin.id", 0);
                    }
                
                    public static int getThreadPoolCoreSize() {
                        return getInt("thread.pool.core.size", 3);
                    }
                
                    public static int getThreadPoolMaxSize() {
                        return getInt("thread.pool.max.size", 10);
                    }
                
                    public static int getHttpConnectTimeout() {
                        return getInt("http.connect.timeout", 10000);
                    }
                
                    public static int getHttpReadTimeout() {
                        return getInt("http.read.timeout", 15000);
                    }
                
                    public static String getHttpUserAgent() {
                        return getString("http.user.agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36");
                    }
                
                    public static boolean isDynamicCookiesEnabled() {
                        return getBoolean("cookie.dynamic.enabled", true);
                    }
                
                    public static boolean getCookieAutoUpdate() {
                        return getBoolean("cookie.auto.update", true);
                    }
                
                    public static int getCookieUpdateInterval() {
                        return getInt("cookie.update.interval.minutes", 120);
                    }
                
                    public static String getStorageDataDir() {
                        return getString("storage.data.dir", "./data");
                    }
                
                    public static int getDefaultCheckInterval() {
                        return getInt("parser.default.check_interval", 300);
                    }
                
                    public static int getDefaultMaxAgeMinutes() {
                        return getInt("parser.default.max_age_minutes", 1440);
                    }
                
                    public static int getDefaultMaxPages() {
                        return getInt("parser.default.max_pages", 20);
                    }
                
                    public static int getDefaultRowsPerPage() {
                        return getInt("parser.default.rows_per_page", 30);
                    }
                }
                ----------------------------------------

              [FILE] CookieConfig.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/config/CookieConfig.java
                Размер: 10300 байт
                Дата изменения: 2026-01-19T09:31:29.76763413Z
                Содержимое:
                ----------------------------------------
                package com.parser.config;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.*;
                import java.util.Properties;
                
                /**
                 * Класс для управления куки файлами
                 */
                public class CookieConfig {
                    private static final Logger logger = LoggerFactory.getLogger(CookieConfig.class);
                    private static final Properties cookies = new Properties();
                    private static final String COOKIE_FILE = "cookies.properties";
                    private static volatile boolean isLoaded = false;
                
                    static {
                        synchronized (CookieConfig.class) {
                            if (!isLoaded) {
                                loadCookies();
                                isLoaded = true;
                            }
                        }
                    }
                
                    /**
                     * Загрузка куки из файла
                     */
                    private static void loadCookies() {
                        // Попытка 1: Загрузка из файла в текущей директории
                        File externalFile = new File(COOKIE_FILE);
                        if (externalFile.exists() && externalFile.isFile()) {
                            try (InputStream input = new FileInputStream(externalFile)) {
                                cookies.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded cookies from external file: {}", COOKIE_FILE);
                                return;
                            } catch (IOException e) {
                                logger.warn("Failed to load external cookie file: {}", e.getMessage());
                            }
                        }
                
                        // Попытка 2: Загрузка из ресурсов
                        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(COOKIE_FILE)) {
                            if (input != null) {
                                cookies.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded cookies from resources: {}", COOKIE_FILE);
                            } else {
                                logger.warn("Cookie file not found");
                            }
                        } catch (IOException e) {
                            logger.error("Error loading cookies from resources: {}", e.getMessage(), e);
                        }
                    }
                
                    /**
                     * Получение куки для домена
                     */
                    public static String getCookiesForDomain(String domain) {
                        if (domain == null || domain.trim().isEmpty()) {
                            return "";
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        String cookiesStr = cookies.getProperty(key, "");
                        return cookiesStr != null ? cookiesStr.trim() : "";
                    }
                
                    /**
                     * Установка куки для домена
                     */
                    public static void setCookiesForDomain(String domain, String cookieString) {
                        if (domain == null || domain.trim().isEmpty()) {
                            return;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        cookies.setProperty(key, cookieString != null ? cookieString.trim() : "");
                        saveCookies();
                        logger.info("Cookies updated for domain: {}", domain);
                    }
                
                    /**
                     * Получение конкретного куки по имени для домена
                     */
                    public static String getCookie(String domain, String cookieName) {
                        if (domain == null || domain.trim().isEmpty() || cookieName == null || cookieName.trim().isEmpty()) {
                            return "";
                        }
                
                        String allCookies = getCookiesForDomain(domain);
                        if (allCookies == null || allCookies.isEmpty()) {
                            return "";
                        }
                
                        String[] cookiePairs = allCookies.split("; ");
                        for (String pair : cookiePairs) {
                            String[] parts = pair.split("=", 2);
                            if (parts.length == 2 && parts[0].trim().equals(cookieName.trim())) {
                                return parts[1].trim();
                            }
                        }
                
                        return "";
                    }
                
                    /**
                     * Установка конкретного куки
                     */
                    public static void setCookie(String domain, String cookieName, String cookieValue) {
                        if (domain == null || domain.trim().isEmpty() || cookieName == null || cookieName.trim().isEmpty()) {
                            return;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        String currentCookies = cookies.getProperty(key, "");
                
                        // Создаем новую строку куки
                        StringBuilder newCookies = new StringBuilder();
                        boolean replaced = false;
                
                        if (currentCookies != null && !currentCookies.trim().isEmpty()) {
                            String[] cookiePairs = currentCookies.split("; ");
                            for (String pair : cookiePairs) {
                                String[] parts = pair.split("=", 2);
                                if (parts.length == 2) {
                                    if (parts[0].trim().equals(cookieName.trim())) {
                                        // Заменяем существующий куки
                                        newCookies.append(cookieName.trim()).append("=").append(cookieValue != null ? cookieValue.trim() : "").append("; ");
                                        replaced = true;
                                    } else {
                                        newCookies.append(pair).append("; ");
                                    }
                                }
                            }
                        }
                
                        // Если куки не было, добавляем новый
                        if (!replaced) {
                            newCookies.append(cookieName.trim()).append("=").append(cookieValue != null ? cookieValue.trim() : "").append("; ");
                        }
                
                        // Убираем последнюю точку с запятой
                        String result = newCookies.toString();
                        if (result.endsWith("; ")) {
                            result = result.substring(0, result.length() - 2);
                        }
                
                        cookies.setProperty(key, result);
                        saveCookies();
                        logger.debug("Cookie {} set for domain {}", cookieName, domain);
                    }
                
                    /**
                     * Удаление куки
                     */
                    public static void removeCookie(String domain, String cookieName) {
                        if (domain == null || domain.trim().isEmpty() || cookieName == null || cookieName.trim().isEmpty()) {
                            return;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        String currentCookies = cookies.getProperty(key, "");
                
                        if (currentCookies == null || currentCookies.trim().isEmpty()) {
                            return;
                        }
                
                        StringBuilder newCookies = new StringBuilder();
                        String[] cookiePairs = currentCookies.split("; ");
                
                        for (String pair : cookiePairs) {
                            String[] parts = pair.split("=", 2);
                            if (parts.length == 2 && !parts[0].trim().equals(cookieName.trim())) {
                                if (newCookies.length() > 0) {
                                    newCookies.append("; ");
                                }
                                newCookies.append(pair);
                            }
                        }
                
                        cookies.setProperty(key, newCookies.toString());
                        saveCookies();
                        logger.debug("Cookie {} removed from domain {}", cookieName, domain);
                    }
                
                    /**
                     * Очистка всех куки для домена
                     */
                    public static void clearCookiesForDomain(String domain) {
                        if (domain == null || domain.trim().isEmpty()) {
                            return;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        cookies.remove(key);
                        saveCookies();
                        logger.info("All cookies cleared for domain: {}", domain);
                    }
                
                    /**
                     * Сохранение куки в файл
                     */
                    public static void saveCookies() {
                        File externalFile = new File(COOKIE_FILE);
                        try (OutputStream output = new FileOutputStream(externalFile)) {
                            cookies.store(output, "Cookies for HTTP requests\nAuto-generated file");
                            logger.debug("Cookies saved to: {}", COOKIE_FILE);
                        } catch (IOException e) {
                            logger.error("Failed to save cookies: {}", e.getMessage(), e);
                        }
                    }
                
                    /**
                     * Получение списка всех доменов с куки
                     */
                    public static String[] getCookieDomains() {
                        return cookies.stringPropertyNames().stream()
                                .filter(key -> key != null && key.endsWith(".cookies"))
                                .map(key -> key.substring(0, key.length() - 8))
                                .toArray(String[]::new);
                    }
                
                    /**
                     * Проверка наличия куки для домена
                     */
                    public static boolean hasCookiesForDomain(String domain) {
                        if (domain == null || domain.trim().isEmpty()) {
                            return false;
                        }
                
                        String key = domain.toLowerCase().trim() + ".cookies";
                        String cookieString = cookies.getProperty(key, "");
                        return cookieString != null && !cookieString.trim().isEmpty();
                    }
                
                    /**
                     * Получение всех куки в виде строки для конкретного домена
                     */
                    public static String getAllCookiesAsString(String domain) {
                        return getCookiesForDomain(domain);
                    }
                
                    /**
                     * Парсинг строки куки из заголовка Set-Cookie
                     */
                    public static void parseSetCookieHeader(String domain, String setCookieHeader) {
                        if (domain == null || domain.trim().isEmpty() || setCookieHeader == null || setCookieHeader.trim().isEmpty()) {
                            return;
                        }
                
                        String[] cookiesArray = setCookieHeader.split(";\\s*");
                        for (String cookie : cookiesArray) {
                            String[] parts = cookie.split("=", 2);
                            if (parts.length == 2) {
                                String name = parts[0].trim();
                                String value = parts[1].trim();
                
                                // Пропускаем атрибуты
                                if (name.equalsIgnoreCase("path") ||
                                        name.equalsIgnoreCase("domain") ||
                                        name.equalsIgnoreCase("expires") ||
                                        name.equalsIgnoreCase("max-age") ||
                                        name.equalsIgnoreCase("secure") ||
                                        name.equalsIgnoreCase("httponly") ||
                                        name.equalsIgnoreCase("samesite")) {
                                    continue;
                                }
                
                                setCookie(domain, name, value);
                            }
                        }
                
                        logger.debug("Parsed Set-Cookie header for domain: {}", domain);
                    }
                
                    /**
                     * Релоад куки из файла
                     */
                    public static void reload() {
                        synchronized (CookieConfig.class) {
                            cookies.clear();
                            loadCookies();
                            logger.info("Cookies reloaded");
                        }
                    }
                }
                ----------------------------------------
            [DIR] parser

              [FILE] GoofishParser.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/GoofishParser.java
                Размер: 36266 байт
                Дата изменения: 2026-02-02T18:57:14.488095511Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;import com.parser.config.Config;import com.parser.model.Product;import com.parser.service.CookieService;import com.parser.util.HttpUtils;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.util.EntityUtils;import org.json.JSONArray;import org.json.JSONObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.nio.charset.StandardCharsets;import java.security.MessageDigest;import java.util.*;import java.util.regex.Matcher;import java.util.regex.Pattern;/** * Исправленный парсер для Goofish с правильным POST запросом и обработкой zstd */public class GoofishParser extends BaseParser {    private static final Logger logger = LoggerFactory.getLogger(GoofishParser.class);    private static final String SEARCH_ENDPOINT = "/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/";    private static final String APP_KEY = "34839810";    private static final Pattern PUBLISHED_AGO_ZH = Pattern.compile("(\\d+)\\s*(分钟|小?时|天)前发布");    private static final Random random = new Random();    private static long lastRequestTime = 0;    public GoofishParser() {        super("goofish", "https://h5api.m.goofish.com");    }    @Override    protected String buildSearchUrl(String query, int page, int rows) {        // Для POST запроса URL формируется без параметра data        return buildApiUrl(query, page, rows);    }    /**     * Формирование URL API     */    private String buildApiUrl(String query, int page, int rows) {        try {            long timestamp = System.currentTimeMillis();            String token = getTokenFromCookies();            if (token.isEmpty()) {                logger.error("❌ Token is empty! Check cookies");                return "";            }            // Формируем data параметр для подписи            String dataStr = buildSearchData(query, page, rows);            String sign = generateSignature(token, timestamp, dataStr);            // Строим URL с параметрами как в реальном запросе            Map<String, String> params = new LinkedHashMap<>();            params.put("jsv", "2.7.2");            params.put("appKey", APP_KEY);            params.put("t", String.valueOf(timestamp));            params.put("sign", sign);            params.put("v", "1.0");            params.put("type", "originaljson");            params.put("accountSite", "xianyu");            params.put("dataType", "json");            params.put("timeout", "20000");            params.put("api", "mtop.taobao.idlemtopsearch.pc.search");            params.put("sessionOption", "AutoLoginOnly");            params.put("spm_cnt", "a21ybx.search.0.0");            params.put("spm_pre", "a21ybx.search.searchInput.0");            return HttpUtils.buildUrlWithParams(baseUrl + SEARCH_ENDPOINT, params);        } catch (Exception e) {            logger.error("Error building URL: {}", e.getMessage());            return "";        }    }    /**     * Формирование данных для поиска     */    private String buildSearchData(String query, int page, int rows) {        JSONObject data = new JSONObject();        data.put("pageNumber", page);        data.put("keyword", query);        // Настройки запроса: показываем самые новые товары первыми        data.put("fromFilter", true);        data.put("rowsPerPage", rows);        data.put("sortValue", "desc");        data.put("sortField", "create");        data.put("customDistance", "");        data.put("gps", "");        JSONObject propValueStr = new JSONObject();        propValueStr.put("searchFilter", "");        data.put("propValueStr", propValueStr);        data.put("customGps", "");        data.put("searchReqFromPage", "pcSearch");        data.put("extraFilterValue", "{}");        data.put("userPositionJson", "{}");        return data.toString();    }    /**     * Переопределяем выполнение запроса для использования POST и обработки zstd     */    @Override    protected String executeSearchRequest(String url, String query, int page, int rows) throws Exception {        // Формируем тело запроса        String dataStr = buildSearchData(query, page, rows);        String formData = "data=" + java.net.URLEncoder.encode(dataStr, "UTF-8");        logger.info("📤 POST запрос к: {}", url);        logger.debug("📝 Тело запроса: {}", formData);        // Создаем POST запрос        HttpPost request = new HttpPost(url);        // Устанавливаем заголовки как в реальном запросе        request.setHeader("User-Agent", "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 YaBrowser/25.10.0.0 Safari/537.36");        request.setHeader("Content-Type", "application/x-www-form-urlencoded; charset=UTF-8");        request.setHeader("Accept", "application/json");        request.setHeader("Accept-Encoding", "gzip, deflate, br, zstd");        request.setHeader("Accept-Language", "ru,en;q=0.9");        request.setHeader("Origin", "https://www.goofish.com");        request.setHeader("Referer", "https://www.goofish.com/");        request.setHeader("Sec-Fetch-Dest", "empty");        request.setHeader("Sec-Fetch-Mode", "cors");        request.setHeader("Sec-Fetch-Site", "same-site");        request.setHeader("sec-ch-ua", "\"Chromium\";v=\"140\", \"Not=A?Brand\";v=\"24\", \"YaBrowser\";v=\"25.10\", \"Yowser\";v=\"2.5\", \"YaBrowserCorp\";v=\"140\"");        request.setHeader("sec-ch-ua-mobile", "?0");        request.setHeader("sec-ch-ua-platform", "\"macOS\"");        request.setHeader("x-accept-terminal", "pc");        // Добавляем куки        String domain = "h5api.m.goofish.com";        String cookieHeader = CookieService.getCookieHeader(domain);        if (cookieHeader != null && !cookieHeader.isEmpty()) {            request.setHeader("Cookie", cookieHeader);            logger.debug("✅ Добавлены куки: {} символов", cookieHeader.length());        } else {            logger.warn("⚠️ Куки пустые!");        }        // Устанавливаем тело запроса        request.setEntity(new StringEntity(formData, StandardCharsets.UTF_8));        // Выполняем запрос        try (var response = HttpUtils.getHttpClientInstance().execute(request)) {            int statusCode = response.getStatusLine().getStatusCode();            String contentType = response.getFirstHeader("Content-Type") != null ?                    response.getFirstHeader("Content-Type").getValue() : "unknown";            String contentEncoding = response.getFirstHeader("Content-Encoding") != null ?                    response.getFirstHeader("Content-Encoding").getValue() : "unknown";            logger.info("📥 Ответ: статус={}, content-type={}, content-encoding={}",                    statusCode, contentType, contentEncoding);            // Получаем сырые байты ответа            byte[] responseBytes = EntityUtils.toByteArray(response.getEntity());            String responseBody;            // Обрабатываем сжатие            if ("zstd".equalsIgnoreCase(contentEncoding)) {                logger.info("🔄 Распаковываем zstd сжатие...");                responseBody = decompressZstd(responseBytes);            } else if ("gzip".equalsIgnoreCase(contentEncoding) || "deflate".equalsIgnoreCase(contentEncoding)) {                // HttpClient обычно автоматически обрабатывает gzip/deflate                responseBody = new String(responseBytes, StandardCharsets.UTF_8);            } else {                // Без сжатия                responseBody = new String(responseBytes, StandardCharsets.UTF_8);            }            // Логируем заголовки для отладки            org.apache.http.Header[] headers = response.getAllHeaders();            logger.debug("📋 Заголовки ответа:");            for (org.apache.http.Header header : headers) {                if (header.getName().equalsIgnoreCase("Set-Cookie") ||                        header.getName().equalsIgnoreCase("Content-Type") ||                        header.getName().equalsIgnoreCase("Content-Encoding") ||                        header.getName().equalsIgnoreCase("X-EagleEye-Id")) {                    logger.debug("   {}: {}", header.getName(), header.getValue());                }            }            logger.debug("📄 Тело ответа (первые 500 символов): {}",                    responseBody.length() > 500 ? responseBody.substring(0, 500) + "..." : responseBody);            if (statusCode == 200) {                // Проверяем, это JSON или что-то другое                if (responseBody.trim().startsWith("{") || responseBody.trim().startsWith("[")) {                    logger.info("✅ Получен JSON ответ, длина: {} символов", responseBody.length());                    return responseBody;                } else {                    logger.error("❌ Ответ не JSON. Первые 200 символов: {}",                            responseBody.length() > 200 ? responseBody.substring(0, 200) : responseBody);                    // Проверяем, не получили ли мы HTML страницу с ошибкой                    if (responseBody.contains("<html") || responseBody.contains("<!DOCTYPE")) {                        logger.error("⚠️ Получена HTML страница вместо JSON. Возможно, куки недействительны.");                    } else if (responseBody.contains("被挤爆啦") || responseBody.contains("FAIL_SYS_ILLEGAL_ACCESS")) {                        logger.error("⚠️ API вернуло ошибку: {}",                                responseBody.length() > 100 ? responseBody.substring(0, 100) : responseBody);                    }                    throw new Exception("Ответ не в формате JSON: " + contentType);                }            } else {                logger.error("❌ HTTP ошибка {}: {}", statusCode,                        responseBody.length() > 200 ? responseBody.substring(0, 200) + "..." : responseBody);                throw new Exception("HTTP error: " + statusCode);            }        } catch (Exception e) {            logger.error("❌ Ошибка выполнения запроса: {}", e.getMessage());            throw e;        }    }    /**     * Распаковка zstd сжатых данных     */    private String decompressZstd(byte[] compressedData) {        try {            logger.debug("📦 Размер сжатых данных: {} байт", compressedData.length);            // Используем zstd-jni для распаковки            byte[] decompressed = com.github.luben.zstd.Zstd.decompress(compressedData, 10 * 1024 * 1024); // Макс 10MB            String result = new String(decompressed, StandardCharsets.UTF_8);            logger.debug("✅ Zstd успешно распакован");            logger.debug("📄 Размер распакованных данных: {} символов", result.length());            return result;        } catch (Exception e) {            logger.error("❌ Ошибка распаковки zstd: {}", e.getMessage());            // Пробуем прочитать как обычную строку            try {                String fallback = new String(compressedData, StandardCharsets.UTF_8);                logger.warn("⚠️ Используем fallback чтение как UTF-8");                return fallback;            } catch (Exception e2) {                return "Ошибка при обработке ответа: " + e.getMessage();            }        }    }    // Остальные методы остаются без изменений    @Override    protected List<Product> parseResponse(String response, String query) {        List<Product> products = new ArrayList<>();        if (response == null || response.isEmpty()) {            logger.warn("Empty response");            return products;        }        try {            JSONObject json = new JSONObject(response);            // Проверка наличия ошибок            if (json.has("ret")) {                String ret = json.optString("ret", "");                if (ret.contains("被挤爆啦") || ret.contains("RGV587_ERROR") ||                        ret.contains("FAIL_SYS_ILLEGAL_ACCESS")) {                    logger.error("API error: {}", ret);                    return products;                }            }            // Получаем данные            JSONObject data = json.optJSONObject("data");            if (data == null) {                logger.warn("No data in response");                return products;            }            // Извлекаем список товаров            JSONArray resultList = data.optJSONArray("resultList");            if (resultList == null || resultList.length() == 0) {                logger.debug("No items found in response");                return products;            }            logger.info("Found {} items", resultList.length());            for (int i = 0; i < resultList.length(); i++) {                try {                    JSONObject item = resultList.getJSONObject(i);                    Product product = parseProductItem(item, query);                    if (product != null && isValidProduct(product)) {                        products.add(product);                    }                } catch (Exception e) {                    logger.debug("Error parsing item {}: {}", i, e.getMessage());                }            }            logger.info("Successfully parsed {} products", products.size());        } catch (Exception e) {            logger.error("Error parsing response: {}", e.getMessage());            logger.debug("Response content (first 500 chars): {}",                    response.length() > 500 ? response.substring(0, 500) + "..." : response);        }        return products;    }    private Product parseProductItem(JSONObject item, String query) {        try {            JSONObject data = item.optJSONObject("data");            if (data == null) return null;            JSONObject itemObj = data.optJSONObject("item");            if (itemObj == null) return null;            JSONObject mainObj = itemObj.optJSONObject("main");            if (mainObj == null) return null;            JSONObject itemData = data.optJSONObject("itemData");            JSONObject exContent = mainObj.optJSONObject("exContent");            // Извлечение ID товара            String itemId = null;            if (itemData != null) itemId = itemData.optString("itemId", "");            if ((itemId == null || itemId.isEmpty()) && exContent != null) {                itemId = exContent.optString("itemId", "");            }            if (itemId == null || itemId.isEmpty()) return null;            Product product = new Product();            product.setId(itemId);            product.setSite("goofish");            product.setQuery(query);            // 🔴 ИСПРАВЛЕНИЕ: ПАРСИНГ НАЗВАНИЯ - только из title полей            String title = "";            // Приоритет 1: data.itemData.title            if (itemData != null) {                title = itemData.optString("title", "");            }            // Приоритет 2: main.exContent.title (если нет в itemData)            if ((title == null || title.isEmpty()) && exContent != null) {                title = exContent.optString("title", "");            }            // Приоритет 3: main.clickParam.args.subject            if ((title == null || title.isEmpty()) && mainObj != null) {                JSONObject clickParam = mainObj.optJSONObject("clickParam");                if (clickParam != null) {                    JSONObject args = clickParam.optJSONObject("args");                    if (args != null) {                        title = args.optString("subject", "");                    }                }            }            // 🔴 ФИЛЬТР: Убираем слишком длинные названия (вероятно описания)            if (title != null && title.length() > 150) {                title = title.substring(0, 147) + "...";            }            // Если название пустое, создаем информативное            if (title == null || title.isEmpty() || "No title".equals(title) || "null".equals(title)) {                title = "Товар #" + itemId + " (" + query + ")";            }            product.setTitle(title);            // Цена в юанях            double price = extractPrice(itemData, exContent);            product.setPrice(price);            // Возраст товара            long publishTime = extractPublishTime(mainObj, itemData, exContent);            int ageMinutes = calculateAge(publishTime);            Integer ageFromTags = extractAgeMinutesFromTags(exContent, mainObj);            if (ageFromTags != null) {                if (publishTime <= 0 || ageMinutes <= 0 || ageMinutes > 10080) {                    ageMinutes = ageFromTags;                } else {                    if (Math.abs(ageMinutes - ageFromTags) > 60) {                        ageMinutes = ageFromTags;                    }                }            }            product.setAgeMinutes(ageMinutes);            // Локация            String location = itemData != null ? itemData.optString("area", "") : "";            product.setLocation(location.isEmpty() ? "Не указано" : location);            // URL            product.setUrl("https://www.goofish.com/item?id=" + itemId);            // Изображения            List<String> images = extractImages(mainObj, itemObj, data);            product.setImages(images);            logger.debug("Parsed: {} ({}¥, {}min, {} images)",                    product.getShortTitle(), price, ageMinutes, images.size());            return product;        } catch (Exception e) {            logger.error("Error parsing product item: {}", e.getMessage());            return null;        }    }    private double extractPrice(JSONObject itemData, JSONObject exContent) {        if (itemData != null) {            Object priceObj = itemData.opt("price");            if (priceObj != null) return parsePrice(priceObj);        }        if (exContent != null) {            Object priceObj = exContent.opt("price");            if (priceObj != null) return parsePrice(priceObj);        }        return 0.0;    }    private double parsePrice(Object priceObj) {        if (priceObj instanceof String) {            return extractPrice((String) priceObj);        }        if (priceObj instanceof Number) {            return ((Number) priceObj).doubleValue();        }        if (priceObj instanceof JSONArray) {            JSONArray arr = (JSONArray) priceObj;            StringBuilder sb = new StringBuilder();            for (int i = 0; i < arr.length(); i++) {                JSONObject part = arr.optJSONObject(i);                if (part != null && "integer".equals(part.optString("type"))) {                    sb.append(part.optString("text"));                }            }            return extractPrice(sb.toString());        }        return 0.0;    }    public double extractPrice(String priceStr) {        if (priceStr == null || priceStr.isEmpty()) return 0.0;        try {            String clean = priceStr.replaceAll("[^\\d.,]", "").replace(',', '.');            return Double.parseDouble(clean);        } catch (NumberFormatException e) {            return 0.0;        }    }    private long extractPublishTime(JSONObject main, JSONObject itemData, JSONObject exContent) {        // Путь 1: args.publishTime        if (main != null) {            JSONObject clickParam = main.optJSONObject("clickParam");            if (clickParam != null) {                JSONObject args = clickParam.optJSONObject("args");                if (args != null && args.has("publishTime")) {                    Object time = args.opt("publishTime");                    if (time instanceof String) return Long.parseLong((String) time);                    if (time instanceof Number) return ((Number) time).longValue();                }            }        }        // Путь 2: itemData.publishTime        if (itemData != null && itemData.has("publishTime")) {            Object time = itemData.opt("publishTime");            if (time instanceof String) return Long.parseLong((String) time);            if (time instanceof Number) return ((Number) time).longValue();        }        return 0;    }    /**     * Пытается извлечь "возраст" из UI-меток в ответе (часто там есть строка вида "6小时前发布").     * Возвращает возраст в минутах или null, если не удалось.     */    private Integer extractAgeMinutesFromTags(JSONObject exContent, JSONObject mainObj) {        try {            // Путь 1: mainObj.clickParam.args.serviceUtParams (строка JSON с content)            if (mainObj != null) {                JSONObject clickParam = mainObj.optJSONObject("clickParam");                if (clickParam != null) {                    JSONObject args = clickParam.optJSONObject("args");                    if (args != null) {                        String serviceUtParams = args.optString("serviceUtParams", "");                        Integer parsed = parseAgeMinutesFromText(serviceUtParams);                        if (parsed != null) return parsed;                    }                }            }            // Путь 2: exContent.fishTags.r2.tagList[*].data.content            if (exContent != null) {                JSONObject fishTags = exContent.optJSONObject("fishTags");                if (fishTags != null) {                    JSONObject r2 = fishTags.optJSONObject("r2");                    if (r2 != null) {                        JSONArray tagList = r2.optJSONArray("tagList");                        if (tagList != null) {                            for (int i = 0; i < Math.min(5, tagList.length()); i++) {                                JSONObject tag = tagList.optJSONObject(i);                                if (tag == null) continue;                                JSONObject data = tag.optJSONObject("data");                                if (data == null) continue;                                String content = data.optString("content", "");                                Integer parsed = parseAgeMinutesFromText(content);                                if (parsed != null) return parsed;                            }                        }                    }                }            }        } catch (Exception ignored) {        }        return null;    }    private Integer parseAgeMinutesFromText(String text) {        if (text == null || text.isEmpty()) return null;        Matcher m = PUBLISHED_AGO_ZH.matcher(text);        if (!m.find()) return null;        int value;        try {            value = Integer.parseInt(m.group(1));        } catch (NumberFormatException e) {            return null;        }        String unit = m.group(2);        if (unit.contains("分钟")) return Math.max(1, value);        if (unit.contains("时")) return Math.max(1, value * 60);        if (unit.contains("天")) return Math.max(1, value * 24 * 60);        return null;    }    private int calculateAge(long publishTime) {        if (publishTime <= 0) return 0;        // Определяем формат времени (секунды или миллисекунды)        if (publishTime < 10000000000L) {            publishTime = publishTime * 1000;        }        long ageMs = System.currentTimeMillis() - publishTime;        int ageMinutes = (int) (ageMs / (1000 * 60));        return Math.max(1, Math.min(ageMinutes, 10080)); // 1 до 7 дней    }    private List<String> extractImages(JSONObject main, JSONObject itemObj, JSONObject data) {        List<String> images = new ArrayList<>();        // Путь 1: data.picUrl (главное фото)        if (data != null && data.has("picUrl")) {            String picUrl = data.optString("picUrl", "");            if (isValidImageUrl(picUrl)) {                images.add(picUrl);                logger.debug("✅ Найдено фото в data.picUrl");            }        }        // Путь 2: data.pics (массив фото)        if (data != null && data.has("pics")) {            JSONArray pics = data.optJSONArray("pics");            if (pics != null) {                for (int i = 0; i < Math.min(5, pics.length()); i++) {                    try {                        JSONObject pic = pics.optJSONObject(i);                        if (pic != null) {                            // Пробуем разные поля                            String url = pic.optString("picUrl", "");                            if (url.isEmpty()) {                                url = pic.optString("pic_url", "");                            }                            if (url.isEmpty()) {                                url = pic.optString("url", "");                            }                            if (isValidImageUrl(url) && !images.contains(url)) {                                images.add(url);                                logger.debug("✅ Найдено фото в data.pics[{}]", i);                            }                        }                    } catch (Exception e) {                        logger.debug("Error parsing pic at index {}: {}", i, e.getMessage());                    }                }            }        }        // Путь 3: itemObj.extra.picUrl (дополнительное фото)        if (itemObj != null) {            JSONObject extra = itemObj.optJSONObject("extra");            if (extra != null) {                String picUrl = extra.optString("picUrl", "");                if (picUrl.isEmpty()) {                    picUrl = extra.optString("pic_url", "");                }                if (isValidImageUrl(picUrl) && !images.contains(picUrl)) {                    images.add(picUrl);                    logger.debug("✅ Найдено фото в itemObj.extra.picUrl");                }            }        }        // Путь 4: main.exContent.picUrl (исходное фото)        if (main != null) {            JSONObject exContent = main.optJSONObject("exContent");            if (exContent != null) {                String picUrl = exContent.optString("picUrl", "");                if (picUrl.isEmpty()) {                    picUrl = exContent.optString("pic_url", "");                }                if (isValidImageUrl(picUrl) && !images.contains(picUrl)) {                    images.add(picUrl);                    logger.debug("✅ Найдено фото в main.exContent.picUrl");                }            }        }        // Путь 5: Прямые поля объекта (на случай если структура упрощена)        if (data != null) {            // Проверяем прямые поля в data            String directPic = data.optString("image", "");            if (directPic.isEmpty()) {                directPic = data.optString("img", "");            }            if (isValidImageUrl(directPic) && !images.contains(directPic)) {                images.add(directPic);                logger.debug("✅ Найдено фото в data.image");            }        }        if (images.isEmpty()) {            logger.debug("⚠️ Фотографии не найдены для товара");        } else {            logger.debug("📷 Найдено фотографий: {}", images.size());        }        return images;    }    private boolean isValidImageUrl(String url) {        if (url == null || url.isEmpty()) {            return false;        }        // Должно быть HTTPS или HTTP        if (!url.startsWith("http://") && !url.startsWith("https://")) {            return false;        }        // Проверяем расширение файла        String lowerUrl = url.toLowerCase();        String[] validExtensions = {".jpg", ".jpeg", ".png", ".gif", ".webp", ".heic"};        boolean hasValidExtension = false;        for (String ext : validExtensions) {            if (lowerUrl.contains(ext)) {                hasValidExtension = true;                break;            }        }        // Если нет расширения - может быть OK (CDN с query parameters)        if (!hasValidExtension && (lowerUrl.contains("alicdn") || lowerUrl.contains("taobaocdn"))) {            return true;        }        return hasValidExtension;    }    private boolean isValidProduct(Product product) {        return product.getId() != null && !product.getId().isEmpty() &&                product.getTitle() != null && !product.getTitle().isEmpty() &&                product.getUrl() != null && !product.getUrl().isEmpty();    }    private String getTokenFromCookies() {        try {            String cookies = CookieService.getCookieHeader("h5api.m.goofish.com");            if (cookies == null || cookies.isEmpty()) return "";            String[] pairs = cookies.split("; ");            for (String pair : pairs) {                if (pair.startsWith("_m_h5_tk=")) {                    String mh5tk = pair.substring(9);                    if (mh5tk.contains("_")) {                        return mh5tk.split("_")[0];                    }                }            }        } catch (Exception e) {            logger.warn("Error getting token: {}", e.getMessage());        }        return "";    }    private String generateSignature(String token, long timestamp, String data) {        try {            String signString = token + "&" + timestamp + "&" + APP_KEY + "&" + data;            MessageDigest md = MessageDigest.getInstance("MD5");            byte[] hash = md.digest(signString.getBytes(StandardCharsets.UTF_8));            StringBuilder hex = new StringBuilder();            for (byte b : hash) {                String h = Integer.toHexString(0xff & b);                if (h.length() == 1) hex.append('0');                hex.append(h);            }            return hex.toString();        } catch (Exception e) {            logger.error("Error generating signature: {}", e.getMessage());            return "";        }    }    /**     * Переопределяем метод search для использования POST запросов     */    @Override    public List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes) {        List<Product> allProducts = new ArrayList<>();        logger.info("Starting search: site={}, query='{}', pages={}, rows={}, maxAge={}min",                siteName, query, maxPages, rowsPerPage, maxAgeMinutes);        for (int page = 1; page <= maxPages; page++) {            if (Thread.currentThread().isInterrupted()) break;            try {                // Формируем URL для API                String url = buildSearchUrl(query, page, rowsPerPage);                if (url.isEmpty()) {                    logger.error("Failed to build URL for page {}", page);                    break;                }                // Выполняем POST запрос                String response = executeSearchRequest(url, query, page, rowsPerPage);                totalRequests++;                // Парсим ответ                List<Product> products = parseResponse(response, query);                if (products.isEmpty()) {                    logger.debug("No products on page {}", page);                    break;                }                // Фильтруем по возрасту                List<Product> filtered = new ArrayList<>();                for (Product p : products) {                    if (p.getAgeMinutes() <= maxAgeMinutes) {                        filtered.add(p);                    }                }                allProducts.addAll(filtered);                logger.info("Page {}: found {} products ({} after age filter)",                        page, products.size(), filtered.size());                // Диагностика: если возрастной фильтр режет слишком много, показываем пару примеров (INFO),                // чтобы было понятно, почему “на сайте сегодняшние, а у нас их мало”.                if (products.size() > 0 && filtered.size() < products.size()) {                    int removed = products.size() - filtered.size();                    if (filtered.isEmpty() || removed >= Math.max(5, products.size() / 2)) {                        StringBuilder dbg = new StringBuilder();                        dbg.append("Age filter removed ").append(removed)                                .append(" of ").append(products.size())                                .append(" (maxAgeMinutes=").append(maxAgeMinutes).append("). Examples: ");                        int shown = 0;                        for (Product p : products) {                            if (p.getAgeMinutes() > maxAgeMinutes) {                                dbg.append(p.getId()).append("(age=").append(p.getAgeMinutes()).append("m)");                                shown++;                                if (shown >= 5) break;                                dbg.append(", ");                            }                        }                        logger.info(dbg.toString());                    }                }                // Останавливаемся только если API реально вернуло меньше rowsPerPage.                // Иначе можем преждевременно остановиться из-за возрастного фильтра и не добрать товары.                if (products.size() < rowsPerPage) break;                // Задержка между запросами                int delay = getRequestDelay();                if (delay > 0 && page < maxPages) {                    Thread.sleep(delay);                }            } catch (Exception e) {                failedRequests++;                logger.error("Error on page {}: {}", page, e.getMessage());                if (shouldStopOnError(e)) break;                try {                    Thread.sleep(3000);                } catch (InterruptedException ie) {                    Thread.currentThread().interrupt();                    break;                }            }        }        logger.info("Search completed: found {} products in {} requests",                allProducts.size(), totalRequests);        return allProducts;    }}
                ----------------------------------------

              [FILE] ParserFactory.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/ParserFactory.java
                Размер: 2244 байт
                Дата изменения: 2026-01-19T22:14:58.626726844Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.HashMap;
                import java.util.Map;
                
                /**
                 * Фабрика для создания парсеров различных сайтов
                 * Упрощена для легкого добавления новых сайтов
                 */
                public class ParserFactory {
                    private static final Logger logger = LoggerFactory.getLogger(ParserFactory.class);
                    private static final Map<String, Class<? extends SiteParser>> parsers = new HashMap<>();
                    private static final Map<String, SiteParser> instances = new HashMap<>();
                
                    static {
                        // Регистрируем доступные парсеры
                        registerParser("goofish", GoofishParser.class);
                        // Здесь легко добавить новые парсеры:
                        // registerParser("taobao", TaobaoParser.class);
                        // registerParser("jd", JdParser.class);
                    }
                
                    public static void registerParser(String siteName, Class<? extends SiteParser> parserClass) {
                        String key = siteName.toLowerCase();
                        parsers.put(key, parserClass);
                        logger.info("Registered parser for: {}", siteName);
                    }
                
                    public static SiteParser createParser(String siteName) {
                        String key = siteName.toLowerCase();
                
                        if (!parsers.containsKey(key)) {
                            throw new IllegalArgumentException("Unsupported site: " + siteName);
                        }
                
                        if (!instances.containsKey(key)) {
                            try {
                                SiteParser parser = parsers.get(key).getDeclaredConstructor().newInstance();
                                instances.put(key, parser);
                                logger.debug("Created parser instance for: {}", siteName);
                            } catch (Exception e) {
                                throw new RuntimeException("Failed to create parser for: " + siteName, e);
                            }
                        }
                
                        return instances.get(key);
                    }
                
                    public static boolean hasParser(String siteName) {
                        return parsers.containsKey(siteName.toLowerCase());
                    }
                
                    public static String[] getSupportedSites() {
                        return parsers.keySet().toArray(new String[0]);
                    }
                
                    public static void clearCache() {
                        instances.clear();
                        logger.info("Parser cache cleared");
                    }
                }
                ----------------------------------------

              [FILE] BaseParser.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/BaseParser.java
                Размер: 5947 байт
                Дата изменения: 2026-01-19T23:44:07.572926724Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import com.parser.config.Config;
                import com.parser.model.Product;
                import com.parser.util.HttpUtils;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.ArrayList;
                import java.util.List;
                
                /**
                 * Абстрактный базовый класс для всех парсеров
                 */
                public abstract class BaseParser implements SiteParser {
                    protected static final Logger logger = LoggerFactory.getLogger(BaseParser.class);
                
                    protected String siteName;
                    protected String baseUrl;
                    protected String userAgent;
                
                    protected int totalRequests = 0;
                    protected int failedRequests = 0;
                    protected long totalParseTime = 0;
                
                    public BaseParser(String siteName, String baseUrl) {
                        this.siteName = siteName;
                        this.baseUrl = baseUrl;
                        this.userAgent = HttpUtils.getDefaultUserAgent();
                    }
                
                    @Override
                    public String getSiteName() {
                        return siteName;
                    }
                
                    protected abstract List<Product> parseResponse(String response, String query);
                    protected abstract String buildSearchUrl(String query, int page, int rows);
                
                    @Override
                    public List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes) {
                        List<Product> allProducts = new ArrayList<>();
                
                        logger.info("Starting search: site={}, query='{}', pages={}, rows={}, maxAge={}min",
                                siteName, query, maxPages, rowsPerPage, maxAgeMinutes);
                
                        for (int page = 1; page <= maxPages; page++) {
                            if (Thread.currentThread().isInterrupted()) break;
                
                            try {
                                String url = buildSearchUrl(query, page, rowsPerPage);
                                long requestStart = System.currentTimeMillis();
                                String response = HttpUtils.sendGetRequest(url, userAgent);
                                totalRequests++;
                
                                long parseStart = System.currentTimeMillis();
                                List<Product> products = parseResponse(response, query);
                                totalParseTime += System.currentTimeMillis() - parseStart;
                
                                if (products.isEmpty()) {
                                    logger.debug("No products on page {}", page);
                                    break;
                                }
                
                                // Фильтруем по возрасту
                                List<Product> filtered = new ArrayList<>();
                                for (Product p : products) {
                                    if (p.getAgeMinutes() <= maxAgeMinutes) {
                                        filtered.add(p);
                                    }
                                }
                
                                allProducts.addAll(filtered);
                                logger.info("Page {}: found {} products ({} after age filter)", page, products.size(), filtered.size());
                
                                if (filtered.size() < rowsPerPage) break;
                
                                int delay = getRequestDelay();
                                if (delay > 0 && page < maxPages) {
                                    Thread.sleep(delay);
                                }
                
                            } catch (Exception e) {
                                failedRequests++;
                                logger.error("Error on page {}: {}", page, e.getMessage());
                
                                if (shouldStopOnError(e)) break;
                
                                try {
                                    Thread.sleep(3000);
                                } catch (InterruptedException ie) {
                                    Thread.currentThread().interrupt();
                                    break;
                                }
                            }
                        }
                
                        logger.info("Search completed: found {} products in {} requests", allProducts.size(), totalRequests);
                        return allProducts;
                    }
                
                    @Override
                    public List<Product> search(String query) {
                        return search(query, 3, 100, 1440);
                    }
                
                    /**
                     * Метод для выполнения запроса (может быть переопределен для POST)
                     */
                    protected String executeSearchRequest(String url, String query, int page, int rows) throws Exception {
                        return HttpUtils.sendGetRequest(url, userAgent);
                    }
                
                    protected int getRequestDelay() {
                        return Config.getInt("api.goofish.delay.between.requests", 2000);
                    }
                
                    protected boolean shouldStopOnError(Exception e) {
                        String msg = e.getMessage();
                        return msg != null && (msg.contains("403") || msg.contains("429") || msg.contains("blocked") ||
                                msg.contains("被挤爆啦") || msg.contains("FAIL_SYS_ILLEGAL_ACCESS"));
                    }
                
                    protected String cleanString(String str) {
                        if (str == null) return "";
                        return str.trim().replaceAll("\\s+", " ").replaceAll("[\\p{C}]", "");
                    }
                
                    protected double extractPrice(String priceStr) {
                        if (priceStr == null || priceStr.isEmpty()) return 0.0;
                        try {
                            String clean = priceStr.replaceAll("[^\\d.,]", "").replace(',', '.');
                            return Double.parseDouble(clean);
                        } catch (NumberFormatException e) {
                            return 0.0;
                        }
                    }
                
                    public ParserStats getStats() {
                        return new ParserStats(siteName, totalRequests, failedRequests,
                                totalRequests > 0 ? (double) (totalRequests - failedRequests) / totalRequests * 100 : 0,
                                totalRequests > 0 ? totalParseTime / totalRequests : 0);
                    }
                
                    public static class ParserStats {
                        public String siteName;
                        public int totalRequests;
                        public int failedRequests;
                        public double successRate;
                        public long avgParseTime;
                
                        public ParserStats(String siteName, int totalRequests, int failedRequests, double successRate, long avgParseTime) {
                            this.siteName = siteName;
                            this.totalRequests = totalRequests;
                            this.failedRequests = failedRequests;
                            this.successRate = successRate;
                            this.avgParseTime = avgParseTime;
                        }
                
                        @Override
                        public String toString() {
                            return String.format("ParserStats{site=%s, req=%d, failed=%d, success=%.1f%%, avgTime=%dms}",
                                    siteName, totalRequests, failedRequests, successRate, avgParseTime);
                        }
                    }
                }
                ----------------------------------------

              [FILE] SiteParser.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/SiteParser.java
                Размер: 1482 байт
                Дата изменения: 2026-01-19T09:31:29.771270378Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import com.parser.model.Product;
                import java.util.List;
                
                /**
                 * Интерфейс для всех парсеров сайтов
                 */
                public interface SiteParser {
                
                    /**
                     * Получение названия сайта
                     */
                    String getSiteName();
                
                    /**
                     * Поиск товаров по запросу
                     *
                     * @param query поисковый запрос
                     * @param maxPages максимальное количество страниц для парсинга
                     * @param rowsPerPage количество товаров на странице
                     * @param maxAgeMinutes максимальный возраст товаров в минутах
                     * @return список найденных товаров
                     */
                    List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes);
                
                    /**
                     * Поиск товаров с использованием настроек по умолчанию
                     */
                    default List<Product> search(String query) {
                        return search(query, 3, 100, 1440);
                    }
                
                    /**
                     * Проверка доступности сайта
                     */
                    default boolean isSiteAvailable() {
                        return true; // Базовая реализация, можно переопределить
                    }
                
                    /**
                     * Получение информации о парсере
                     */
                    default String getParserInfo() {
                        return "SiteParser for " + getSiteName();
                    }
                }
                ----------------------------------------
            [DIR] storage

              [FILE] WhitelistManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/WhitelistManager.java
                Размер: 5796 байт
                Дата изменения: 2026-01-28T18:53:30.285175611Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                
                /**
                 * Менеджер белого списка пользователей - ОПТИМИЗИРОВАННЫЙ
                 */
                public class WhitelistManager {
                    private static final Logger logger = LoggerFactory.getLogger(WhitelistManager.class);
                    /**
                     * ВАЖНО:
                     * FileStorage сам добавляет префикс storage.data.dir (по умолчанию ./data).
                     * Поэтому здесь НЕ должно быть "data/..." иначе получится ./data/data/...
                     *
                     * Для обратной совместимости поддерживаем старый путь.
                     */
                    private static final String WHITELIST_FILE = "whitelist.txt";
                    private static final String LEGACY_WHITELIST_FILE = "data/whitelist.txt";
                    private static final Set<Long> whitelist = Collections.synchronizedSet(new HashSet<>());
                    private static volatile boolean isInitialized = false;
                
                    static {
                        synchronized (WhitelistManager.class) {
                            if (!isInitialized) {
                                loadWhitelist();
                                isInitialized = true;
                            }
                        }
                    }
                
                    /**
                     * Загрузка белого списка из файла
                     */
                    private static void loadWhitelist() {
                        List<String> lines = FileStorage.readLines(WHITELIST_FILE);
                        boolean loadedFromLegacy = false;
                
                        // Если нового файла нет/пустой, но есть legacy — читаем legacy
                        if ((lines == null || lines.isEmpty()) && FileStorage.fileExists(LEGACY_WHITELIST_FILE)) {
                            lines = FileStorage.readLines(LEGACY_WHITELIST_FILE);
                            loadedFromLegacy = true;
                        }
                
                        logger.info("Loading whitelist from {}. Found {} lines",
                                loadedFromLegacy ? LEGACY_WHITELIST_FILE : WHITELIST_FILE,
                                lines != null ? lines.size() : 0);
                
                        for (String line : lines) {
                            try {
                                line = line.trim();
                                if (line.isEmpty() || line.startsWith("#")) {
                                    continue;
                                }
                
                                long userId = Long.parseLong(line);
                                if (userId > 0) {
                                    whitelist.add(userId);
                                } else {
                                    logger.warn("Invalid user ID in whitelist (must be > 0): {}", userId);
                                }
                            } catch (NumberFormatException e) {
                                logger.warn("Invalid user ID format in whitelist: '{}'. Error: {}", line, e.getMessage());
                            }
                        }
                
                        logger.info("✅ Loaded {} users from whitelist", whitelist.size());
                
                        // Мягкая миграция: если загрузили из legacy и новый файл отсутствует — сохраняем в новый путь
                        if (loadedFromLegacy && !FileStorage.fileExists(WHITELIST_FILE) && !whitelist.isEmpty()) {
                            logger.info("Migrating whitelist from legacy path to {}", WHITELIST_FILE);
                            saveWhitelist();
                        }
                    }
                
                    /**
                     * Сохранение белого списка в файл
                     */
                    private static void saveWhitelist() {
                        List<String> lines = new ArrayList<>();
                        lines.add("# Whitelist - authorized users");
                        lines.add("# Format: one user ID per line");
                        lines.add("# Created: " + new Date());
                        lines.add("");
                
                        List<Long> sortedUsers = new ArrayList<>(whitelist);
                        Collections.sort(sortedUsers);
                
                        for (Long userId : sortedUsers) {
                            lines.add(String.valueOf(userId));
                        }
                
                        try {
                            FileStorage.writeLines(WHITELIST_FILE, lines);
                            logger.info("✅ Whitelist saved: {} users", whitelist.size());
                        } catch (Exception e) {
                            logger.error("❌ Failed to save whitelist: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Проверка авторизации пользователя
                     */
                    public static boolean isUserAllowed(long userId) {
                        boolean allowed = whitelist.contains(userId);
                        if (!allowed) {
                            logger.warn("Unauthorized access attempt from user {}", userId);
                        }
                        return allowed;
                    }
                
                    /**
                     * Добавление пользователя
                     */
                    public static boolean addUser(long userId) {
                        if (userId <= 0) {
                            logger.warn("Invalid user ID: {}", userId);
                            return false;
                        }
                
                        if (whitelist.add(userId)) {
                            saveWhitelist();
                            logger.info("✅ User {} added to whitelist", userId);
                            return true;
                        }
                
                        return false;
                    }
                
                    /**
                     * Удаление пользователя
                     */
                    public static boolean removeUser(long userId) {
                        if (whitelist.remove(userId)) {
                            saveWhitelist();
                            logger.info("✅ User {} removed from whitelist", userId);
                            return true;
                        }
                        return false;
                    }
                
                    /**
                     * Получение всех пользователей
                     */
                    public static List<Long> getAllUsers() {
                        return new ArrayList<>(whitelist);
                    }
                
                    /**
                     * Количество пользователей
                     */
                    public static long getUserCount() {
                        return whitelist.size();
                    }
                
                    /**
                     * Проверка существования пользователя
                     */
                    public static boolean userExists(long userId) {
                        return whitelist.contains(userId);
                    }
                
                    /**
                     * Переинициализация (для тестов)
                     */
                    public static void reload() {
                        whitelist.clear();
                        loadWhitelist();
                        logger.info("Whitelist reloaded");
                    }
                }
                ----------------------------------------

              [FILE] ProductDuplicateFilter.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/ProductDuplicateFilter.java
                Размер: 3798 байт
                Дата изменения: 2026-01-28T18:56:14.357382489Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import com.parser.model.Product;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                
                /**
                 * Фильтр для предотвращения отправки дубликатов товаров
                 *
                 * NOTE:
                 * В актуальном потоке отправки уведомлений используется `UserSentProductsManager`
                 * (персистентная история отправленных товаров).
                 * Этот класс оставлен для обратной совместимости и может использоваться только
                 * как in-memory кэш “увиденных” товаров (без гарантии персистентности).
                 */
                public class ProductDuplicateFilter {
                    private static final Logger logger = LoggerFactory.getLogger(ProductDuplicateFilter.class);
                
                    // Кэш: userId -> Set<productId> (найденные товары)
                    private static final Map<Long, Set<String>> userFoundProducts = new ConcurrentHashMap<>();
                
                    /**
                     * Загрузить найденные товары пользователя
                     */
                    private static Set<String> loadUserProducts(long userId) {
                        List<Product> products = UserDataManager.getUserProducts(userId);
                        Set<String> ids = new HashSet<>();
                
                        for (Product p : products) {
                            ids.add(p.getId());
                        }
                
                        userFoundProducts.put(userId, ids);
                        logger.debug("Loaded {} products for user {}", ids.size(), userId);
                        return ids;
                    }
                
                    /**
                     * Получить новые товары (не отправленные ранее)
                     */
                    public static List<Product> filterNew(long userId, List<Product> products) {
                        if (products == null || products.isEmpty()) {
                            return new ArrayList<>();
                        }
                
                        Set<String> found = userFoundProducts.computeIfAbsent(userId,
                                k -> loadUserProducts(userId));
                
                        List<Product> newProducts = new ArrayList<>();
                
                        for (Product p : products) {
                            if (!found.contains(p.getId())) {
                                newProducts.add(p);
                                found.add(p.getId()); // Добавляем сразу, чтобы не отправить дважды
                            }
                        }
                
                        logger.info("Filter: {} total, {} new for user {}",
                                products.size(), newProducts.size(), userId);
                
                        return newProducts;
                    }
                
                    /**
                     * Добавить товары в кэш пользователя
                     */
                    public static void addProductsToCache(long userId, List<Product> products) {
                        Set<String> found = userFoundProducts.computeIfAbsent(userId,
                                k -> loadUserProducts(userId));
                
                        for (Product p : products) {
                            found.add(p.getId());
                        }
                
                        logger.debug("Added {} products to cache for user {}", products.size(), userId);
                    }
                
                    /**
                     * Очистить кэш пользователя (например, при удалении его товаров)
                     */
                    public static void clearUserCache(long userId) {
                        userFoundProducts.remove(userId);
                        logger.info("Cache cleared for user {}", userId);
                    }
                
                    /**
                     * Очистить весь кэш
                     */
                    public static void clearAllCache() {
                        userFoundProducts.clear();
                        logger.info("All cache cleared");
                    }
                
                    /**
                     * Проверить, был ли товар отправлен пользователю
                     */
                    public static boolean isProductSent(long userId, String productId) {
                        Set<String> found = userFoundProducts.computeIfAbsent(userId,
                                k -> loadUserProducts(userId));
                        return found.contains(productId);
                    }
                }
                ----------------------------------------

              [FILE] UserDataManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/UserDataManager.java
                Размер: 12980 байт
                Дата изменения: 2026-01-19T09:31:29.775386168Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import com.parser.model.Product;
                import com.parser.model.UserSettings;
                import com.fasterxml.jackson.databind.ObjectMapper;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.*;
                
                /**
                 * Менеджер для работы с данными пользователей
                 */
                public class UserDataManager {
                    private static final Logger logger = LoggerFactory.getLogger(UserDataManager.class);
                    private static final ObjectMapper objectMapper = new ObjectMapper();
                
                    /**
                     * Получение поисковых запросов пользователя
                     */
                    public static List<String> getUserQueries(long userId) {
                        String filename = "user_" + userId + "_queries.txt";
                        return FileStorage.readLines(filename);
                    }
                
                    /**
                     * Сохранение поисковых запросов пользователя
                     */
                    public static void saveUserQueries(long userId, List<String> queries) {
                        String filename = "user_" + userId + "_queries.txt";
                        FileStorage.writeLines(filename, queries);
                        logger.debug("Saved {} queries for user {}", queries.size(), userId);
                    }
                
                    /**
                     * Добавление поискового запроса
                     */
                    public static boolean addUserQuery(long userId, String query) {
                        if (query == null || query.trim().isEmpty()) {
                            logger.warn("Attempted to add empty query for user {}", userId);
                            return false;
                        }
                
                        String trimmedQuery = query.trim();
                        List<String> queries = getUserQueries(userId);
                
                        // Проверка на дубликаты
                        for (String existingQuery : queries) {
                            if (existingQuery.equalsIgnoreCase(trimmedQuery)) {
                                logger.debug("Query already exists for user {}: {}", userId, trimmedQuery);
                                return false;
                            }
                        }
                
                        // Ограничение на количество запросов
                        if (queries.size() >= 50) {
                            logger.warn("User {} reached query limit (50)", userId);
                            return false;
                        }
                
                        queries.add(trimmedQuery);
                        saveUserQueries(userId, queries);
                        logger.info("Query added for user {}: {}", userId, trimmedQuery);
                        return true;
                    }
                
                    /**
                     * Удаление поискового запроса
                     */
                    public static boolean removeUserQuery(long userId, String query) {
                        List<String> queries = getUserQueries(userId);
                        boolean removed = queries.remove(query);
                
                        if (removed) {
                            saveUserQueries(userId, queries);
                            logger.info("Query removed for user {}: {}", userId, query);
                        } else {
                            logger.debug("Query not found for user {}: {}", userId, query);
                        }
                
                        return removed;
                    }
                
                    /**
                     * Очистка всех поисковых запросов пользователя
                     */
                    public static void clearUserQueries(long userId) {
                        saveUserQueries(userId, new ArrayList<>());
                        logger.info("All queries cleared for user {}", userId);
                    }
                
                    /**
                     * Получение настроек пользователя
                     */
                    public static UserSettings getUserSettings(long userId) {
                        String filename = "user_settings/" + userId + ".json";
                        String json = FileStorage.readJson(filename);
                
                        try {
                            if (json == null || json.isEmpty() || json.equals("{}")) {
                                // Возвращаем настройки по умолчанию
                                UserSettings defaultSettings = new UserSettings();
                                saveUserSettings(userId, defaultSettings);
                                return defaultSettings;
                            }
                
                            return objectMapper.readValue(json, UserSettings.class);
                
                        } catch (Exception e) {
                            logger.error("Error parsing settings for user {}: {}", userId, e.getMessage());
                            return new UserSettings(); // Настройки по умолчанию при ошибке
                        }
                    }
                
                    /**
                     * Сохранение настроек пользователя
                     */
                    public static void saveUserSettings(long userId, UserSettings settings) {
                        String filename = "user_settings/" + userId + ".json";
                
                        try {
                            String json = objectMapper.writeValueAsString(settings);
                            FileStorage.writeJson(filename, json);
                            logger.debug("Settings saved for user {}", userId);
                
                        } catch (Exception e) {
                            logger.error("Error saving settings for user {}: {}", userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Получение сохраненных товаров пользователя
                     */
                    public static List<Product> getUserProducts(long userId) {
                        String filename = "user_products/" + userId + ".json";
                        String json = FileStorage.readJson(filename);
                
                        if (json == null || json.isEmpty() || json.equals("{}")) {
                            return new ArrayList<>();
                        }
                
                        try {
                            Product[] products = objectMapper.readValue(json, Product[].class);
                            return new ArrayList<>(Arrays.asList(products));
                
                        } catch (Exception e) {
                            logger.error("Error parsing products for user {}: {}", userId, e.getMessage());
                            return new ArrayList<>();
                        }
                    }
                
                    /**
                     * Сохранение товаров пользователя
                     */
                    public static void saveUserProducts(long userId, List<Product> products) {
                        String filename = "user_products/" + userId + ".json";
                
                        try {
                            String json = objectMapper.writeValueAsString(products);
                            FileStorage.writeJson(filename, json);
                            logger.debug("Saved {} products for user {}", products.size(), userId);
                
                        } catch (Exception e) {
                            logger.error("Error saving products for user {}: {}", userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Добавление товаров к существующим
                     */
                    public static void addUserProducts(long userId, List<Product> newProducts) {
                        if (newProducts == null || newProducts.isEmpty()) {
                            return;
                        }
                
                        List<Product> existingProducts = getUserProducts(userId);
                        Set<String> existingIds = new HashSet<>();
                
                        // Собираем ID существующих товаров
                        for (Product product : existingProducts) {
                            existingIds.add(product.getId());
                        }
                
                        // Добавляем только новые товары
                        for (Product product : newProducts) {
                            if (!existingIds.contains(product.getId())) {
                                existingProducts.add(product);
                                existingIds.add(product.getId());
                            }
                        }
                
                        // Ограничиваем количество хранимых товаров
                        if (existingProducts.size() > 1000) {
                            existingProducts = existingProducts.subList(
                                    existingProducts.size() - 1000, existingProducts.size());
                        }
                
                        saveUserProducts(userId, existingProducts);
                    }
                
                    /**
                     * Очистка товаров пользователя
                     */
                    public static void clearUserProducts(long userId) {
                        String filename = "user_products/" + userId + ".json";
                        FileStorage.writeJson(filename, "[]");
                        logger.info("Products cleared for user {}", userId);
                    }
                
                    /**
                     * Фильтрация новых товаров
                     */
                    public static List<Product> filterNewProducts(long userId, List<Product> products) {
                        if (products == null || products.isEmpty()) {
                            return new ArrayList<>();
                        }
                
                        List<Product> existingProducts = getUserProducts(userId);
                        Set<String> existingIds = new HashSet<>();
                
                        for (Product product : existingProducts) {
                            existingIds.add(product.getId());
                        }
                
                        List<Product> newProducts = new ArrayList<>();
                        for (Product product : products) {
                            if (!existingIds.contains(product.getId())) {
                                newProducts.add(product);
                            }
                        }
                
                        return newProducts;
                    }
                
                
                    /**
                     * Получение статистики пользователя
                     */
                    public static Map<String, Object> getUserStats(long userId) {
                        Map<String, Object> stats = new HashMap<>();
                
                        // Количество запросов
                        List<String> queries = getUserQueries(userId);
                        stats.put("queryCount", queries.size());
                
                        // Количество товаров
                        List<Product> products = getUserProducts(userId);
                        stats.put("productCount", products.size());
                
                        // Настройки
                        UserSettings settings = getUserSettings(userId);
                        stats.put("settings", settings.getSummary());
                
                        // Дата последнего изменения
                        String queriesFile = "user_" + userId + "_queries.txt";
                        String productsFile = "user_products/" + userId + ".json";
                        String settingsFile = "user_settings/" + userId + ".json";
                
                        stats.put("queriesLastModified", FileStorage.getLastModified(queriesFile));
                        stats.put("productsLastModified", FileStorage.getLastModified(productsFile));
                        stats.put("settingsLastModified", FileStorage.getLastModified(settingsFile));
                
                        return stats;
                    }
                
                    /**
                     * Удаление всех данных пользователя
                     */
                    public static boolean deleteUserData(long userId) {
                        try {
                            String queriesFile = "user_" + userId + "_queries.txt";
                            String productsFile = "user_products/" + userId + ".json";
                            String settingsFile = "user_settings/" + userId + ".json";
                
                            boolean deleted = true;
                            deleted &= FileStorage.deleteFile(queriesFile);
                            deleted &= FileStorage.deleteFile(productsFile);
                            deleted &= FileStorage.deleteFile(settingsFile);
                
                            if (deleted) {
                                logger.info("All data deleted for user {}", userId);
                            } else {
                                logger.warn("Some files could not be deleted for user {}", userId);
                            }
                
                            return deleted;
                
                        } catch (Exception e) {
                            logger.error("Error deleting data for user {}: {}", userId, e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Экспорт данных пользователя
                     */
                    public static boolean exportUserData(long userId, String exportFilename) {
                        try {
                            Map<String, Object> exportData = new HashMap<>();
                
                            exportData.put("userId", userId);
                            exportData.put("exportDate", new Date());
                
                            // Запросы
                            exportData.put("queries", getUserQueries(userId));
                
                            // Настройки
                            UserSettings settings = getUserSettings(userId);
                            exportData.put("settings", objectMapper.convertValue(settings, Map.class));
                
                            // Товары (только последние 100)
                            List<Product> products = getUserProducts(userId);
                            int startIndex = Math.max(0, products.size() - 100);
                            exportData.put("recentProducts", products.subList(startIndex, products.size()));
                
                            // Запись в файл
                            String json = objectMapper.writeValueAsString(exportData);
                            FileStorage.writeJson(exportFilename, json);
                
                            logger.info("Data exported for user {} to {}", userId, exportFilename);
                            return true;
                
                        } catch (Exception e) {
                            logger.error("Error exporting data for user {}: {}", userId, e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Поиск товаров пользователя по критериям
                     */
                    public static List<Product> searchUserProducts(long userId, String searchTerm,
                                                                   double minPrice, double maxPrice) {
                        List<Product> allProducts = getUserProducts(userId);
                        List<Product> results = new ArrayList<>();
                
                        String searchLower = searchTerm.toLowerCase();
                
                        for (Product product : allProducts) {
                            boolean matches = true;
                
                            // Поиск по тексту
                            if (searchTerm != null && !searchTerm.isEmpty()) {
                                String title = product.getTitle().toLowerCase();
                                String query = product.getQuery().toLowerCase();
                                matches = title.contains(searchLower) || query.contains(searchLower);
                            }
                
                            // Фильтр по цене
                            if (matches && minPrice > 0) {
                                matches = product.getPrice() >= minPrice;
                            }
                
                            if (matches && maxPrice > 0) {
                                matches = product.getPrice() <= maxPrice;
                            }
                
                            if (matches) {
                                results.add(product);
                            }
                        }
                
                        return results;
                    }
                }
                ----------------------------------------

              [FILE] AccessRequestManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/AccessRequestManager.java
                Размер: 2703 байт
                Дата изменения: 2026-01-28T18:58:26.507979648Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.text.SimpleDateFormat;
                import java.util.*;
                
                /**
                 * Хранит заявки на доступ к боту (когда пользователь без whitelist пытается воспользоваться ботом).
                 * Сделано максимально просто: запись в файл в data-dir через FileStorage.
                 */
                public class AccessRequestManager {
                    private static final Logger logger = LoggerFactory.getLogger(AccessRequestManager.class);
                
                    private static final String REQUESTS_FILE = "access_requests.txt";
                    private static final SimpleDateFormat TS = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                
                    /**
                     * Записать заявку (если для пользователя ещё нет записи).
                     */
                    public static void recordAccessRequest(long userId, String reason) {
                        if (userId <= 0) return;
                
                        try {
                            List<String> lines = FileStorage.readLines(REQUESTS_FILE);
                            for (String line : lines) {
                                if (line.startsWith(userId + "|")) {
                                    return; // уже есть заявка
                                }
                            }
                
                            String safeReason = reason == null ? "" : reason.replace("|", "/").trim();
                            String entry = userId + "|" + TS.format(new Date()) + "|" + safeReason;
                            lines.add(entry);
                            FileStorage.writeLines(REQUESTS_FILE, lines);
                            logger.info("Access request recorded for user {}", userId);
                        } catch (Exception e) {
                            logger.warn("Failed to record access request for {}: {}", userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Получить список заявок (сырьём).
                     */
                    public static List<String> getRequests() {
                        return FileStorage.readLines(REQUESTS_FILE);
                    }
                
                    /**
                     * Удалить заявку пользователя.
                     */
                    public static void removeRequest(long userId) {
                        try {
                            List<String> lines = FileStorage.readLines(REQUESTS_FILE);
                            List<String> updated = new ArrayList<>();
                            for (String line : lines) {
                                if (!line.startsWith(userId + "|")) {
                                    updated.add(line);
                                }
                            }
                            FileStorage.writeLines(REQUESTS_FILE, updated);
                        } catch (Exception e) {
                            logger.warn("Failed to remove access request for {}: {}", userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Очистить все заявки.
                     */
                    public static void clearAll() {
                        FileStorage.writeLines(REQUESTS_FILE, List.of());
                    }
                }
                ----------------------------------------

              [FILE] UserSentProductsManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/UserSentProductsManager.java
                Размер: 2296 байт
                Дата изменения: 2026-02-02T18:59:15.82722707Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                
                public class UserSentProductsManager {
                    private static final Logger logger = LoggerFactory.getLogger(UserSentProductsManager.class);
                
                    private static final Map<Long, Set<String>> userSentProducts = new ConcurrentHashMap<>();
                    private static final String SENT_PRODUCTS_DIR = "data/sent_products";
                
                    static {
                        FileStorage.createDirectory(SENT_PRODUCTS_DIR);
                    }
                
                    public static Set<String> getSentProductsForUser(long userId) {
                        return userSentProducts.computeIfAbsent(userId, k -> loadUserSentProducts(userId));
                    }
                
                    public static void markProductsAsSent(long userId, Set<String> productIds) {
                        Set<String> sentProducts = getSentProductsForUser(userId);
                        sentProducts.addAll(productIds);
                        saveUserSentProducts(userId, sentProducts);
                        logger.info("Добавлено {} товаров в историю отправленных для пользователя {}",
                                productIds.size(), userId);
                    }
                
                    public static void clearUserHistory(long userId) {
                        userSentProducts.remove(userId);
                        FileStorage.deleteFile(SENT_PRODUCTS_DIR + "/user_" + userId + ".txt");
                        logger.info("История отправленных товаров очищена для пользователя {}", userId);
                    }
                
                    private static Set<String> loadUserSentProducts(long userId) {
                        Set<String> products = new HashSet<>();
                        String filename = SENT_PRODUCTS_DIR + "/user_" + userId + ".txt";
                
                        for (String line : FileStorage.readLines(filename)) {
                            line = line.trim();
                            if (!line.isEmpty()) {
                                products.add(line);
                            }
                        }
                
                        logger.debug("Загружено {} отправленных товаров для пользователя {}",
                                products.size(), userId);
                        return products;
                    }
                
                    private static void saveUserSentProducts(long userId, Set<String> products) {
                        String filename = SENT_PRODUCTS_DIR + "/user_" + userId + ".txt";
                        List<String> lines = new ArrayList<>(products);
                        FileStorage.writeLines(filename, lines);
                    }
                }
                ----------------------------------------

              [FILE] FileStorage.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/FileStorage.java
                Размер: 18437 байт
                Дата изменения: 2026-01-28T19:06:12.423355901Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import com.parser.config.Config;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.*;
                import java.nio.charset.StandardCharsets;
                import java.nio.file.*;
                import java.util.*;
                import java.util.concurrent.locks.ReentrantLock;
                import java.util.zip.GZIPOutputStream;
                
                /**
                 * Утилита для работы с файловым хранилищем
                 */
                public class FileStorage {
                    private static final Logger logger = LoggerFactory.getLogger(FileStorage.class);
                
                    // Блокировки для предотвращения конкурентного доступа
                    private static final Map<String, ReentrantLock> fileLocks = new HashMap<>();
                
                    /**
                     * Получение блокировки для файла
                     */
                    private static synchronized ReentrantLock getFileLock(String filename) {
                        return fileLocks.computeIfAbsent(filename, k -> new ReentrantLock());
                    }
                
                    /**
                     * Создание директории для данных, если она не существует
                     */
                    public static void ensureDataDir() {
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        File dir = new File(dataDir);
                
                        if (!dir.exists()) {
                            logger.info("Создание директории данных: {}", dataDir);
                            if (dir.mkdirs()) {
                                logger.info("✅ Директория данных создана: {}", dataDir);
                
                                // Создание поддиректорий
                                createSubdirectory(dataDir, "user_settings");
                                createSubdirectory(dataDir, "user_products");
                                createSubdirectory(dataDir, "sent_products");
                                createSubdirectory(dataDir, "backups");
                                createSubdirectory(dataDir, "logs");
                
                            } else {
                                logger.error("❌ Не удалось создать директорию данных: {}", dataDir);
                                throw new RuntimeException("Failed to create data directory: " + dataDir);
                            }
                        } else {
                            logger.debug("Директория данных уже существует: {}", dataDir);
                            // На случай апгрейда/старых установок
                            createSubdirectory(dataDir, "user_settings");
                            createSubdirectory(dataDir, "user_products");
                            createSubdirectory(dataDir, "sent_products");
                            createSubdirectory(dataDir, "backups");
                            createSubdirectory(dataDir, "logs");
                        }
                    }
                
                    /**
                     * Создание поддиректории
                     */
                    private static void createSubdirectory(String parentDir, String subdirName) {
                        File subdir = new File(parentDir + "/" + subdirName);
                        if (!subdir.exists()) {
                            if (subdir.mkdirs()) {
                                logger.debug("✅ Создана поддиректория: {}", subdir.getAbsolutePath());
                            } else {
                                logger.warn("⚠️ Не удалось создать поддиректорию: {}", subdir.getAbsolutePath());
                            }
                        }
                    }
                
                    /**
                     * Получение пути к файлу
                     */
                    public static String getFilePath(String filename) {
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        return dataDir + "/" + filename;
                    }
                
                    /**
                     * Чтение строк из файла
                     */
                    public static List<String> readLines(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            if (!file.exists()) {
                                logger.debug("Файл не существует: {}", filename);
                                return new ArrayList<>();
                            }
                
                            List<String> lines = new ArrayList<>();
                            try (BufferedReader reader = new BufferedReader(
                                    new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {
                
                                String line;
                                int lineNumber = 0;
                                while ((line = reader.readLine()) != null) {
                                    lineNumber++;
                                    line = line.trim();
                                    if (!line.isEmpty()) {
                                        lines.add(line);
                                    }
                                }
                
                                logger.debug("Прочитано {} строк из {}", lines.size(), filename);
                                return lines;
                
                            } catch (IOException e) {
                                logger.error("Ошибка чтения файла {}: {}", filename, e.getMessage());
                                return new ArrayList<>();
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Запись строк в файл
                     */
                    public static void writeLines(String filename, List<String> lines) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            ensureDataDir();
                            File file = new File(getFilePath(filename));
                
                            // В проде эти логи слишком шумные — оставляем только в DEBUG.
                            if (logger.isDebugEnabled()) {
                                logger.debug("📝 Запись в файл: {} (абсолютный путь: {})",
                                        filename, file.getAbsolutePath());
                                logger.debug("   Файл существует перед записью: {}", file.exists());
                                logger.debug("   Родительская директория: {}", file.getParent());
                                logger.debug("   Количество строк для записи: {}", lines.size());
                            }
                
                            // Проверяем родительскую директорию
                            File parentDir = file.getParentFile();
                            if (parentDir != null && !parentDir.exists()) {
                                logger.debug("   Создание родительской директории: {}", parentDir.getAbsolutePath());
                                if (!parentDir.mkdirs()) {
                                    logger.error("❌ Не удалось создать родительскую директорию");
                                    throw new RuntimeException("Cannot create parent directory: " + parentDir.getAbsolutePath());
                                }
                            }
                
                            // Проверяем права на запись
                            if (file.exists() && !file.canWrite()) {
                                logger.error("❌ Нет прав на запись в файл: {}", file.getAbsolutePath());
                                throw new RuntimeException("No write permission for file: " + file.getAbsolutePath());
                            }
                
                            // Создание резервной копии, если файл существует
                            if (file.exists()) {
                                logger.debug("   Создание резервной копии...");
                                createBackup(filename);
                            }
                
                            try (BufferedWriter writer = new BufferedWriter(
                                    new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))) {
                
                                for (String line : lines) {
                                    writer.write(line);
                                    writer.newLine();
                                }
                
                                writer.flush();
                
                                if (logger.isDebugEnabled()) {
                                    logger.debug("✅ Успешно записано {} строк в {}", lines.size(), filename);
                                    logger.debug("   Файл существует после записи: {}", file.exists());
                                    logger.debug("   Размер файла после записи: {} байт", file.length());
                                }
                
                            } catch (IOException e) {
                                logger.error("❌ Ошибка записи файла {}: {}", filename, e.getMessage(), e);
                                throw new RuntimeException("Failed to write file: " + filename, e);
                            }
                
                        } catch (Exception e) {
                            logger.error("❌ Критическая ошибка в writeLines для {}: {}", filename, e.getMessage(), e);
                            // Пробрасываем исключение дальше
                            if (e instanceof RuntimeException) {
                                throw (RuntimeException) e;
                            } else {
                                throw new RuntimeException("Error in writeLines for " + filename, e);
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Добавление строки в конец файла
                     */
                    public static void appendLine(String filename, String line) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            ensureDataDir();
                            File file = new File(getFilePath(filename));
                
                            try (BufferedWriter writer = new BufferedWriter(
                                    new OutputStreamWriter(new FileOutputStream(file, true), StandardCharsets.UTF_8))) {
                
                                writer.write(line);
                                writer.newLine();
                
                                logger.debug("Appended line to {}", filename);
                
                            } catch (IOException e) {
                                logger.error("Error appending to file {}: {}", filename, e.getMessage());
                                throw new RuntimeException("Failed to append to file: " + filename, e);
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Чтение JSON объекта из файла
                     */
                    public static String readJson(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            if (!file.exists()) {
                                return "{}";
                            }
                
                            StringBuilder content = new StringBuilder();
                            try (BufferedReader reader = new BufferedReader(
                                    new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {
                
                                String line;
                                while ((line = reader.readLine()) != null) {
                                    content.append(line);
                                }
                
                                return content.toString();
                
                            } catch (IOException e) {
                                logger.error("Error reading JSON file {}: {}", filename, e.getMessage());
                                return "{}";
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Запись JSON объекта в файл
                     */
                    public static void writeJson(String filename, String json) {
                        writeLines(filename, List.of(json));
                    }
                
                    /**
                     * Проверка существования файла
                     */
                    public static boolean fileExists(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists();
                    }
                
                    /**
                     * Удаление файла
                     */
                    public static boolean deleteFile(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            boolean deleted = file.delete();
                
                            if (deleted) {
                                logger.debug("Deleted file: {}", filename);
                            } else {
                                logger.warn("Failed to delete file: {}", filename);
                            }
                
                            return deleted;
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Копирование файла
                     */
                    public static boolean copyFile(String sourceFilename, String destFilename) {
                        ReentrantLock sourceLock = getFileLock(sourceFilename);
                        ReentrantLock destLock = getFileLock(destFilename);
                
                        sourceLock.lock();
                        destLock.lock();
                
                        try {
                            Path source = Paths.get(getFilePath(sourceFilename));
                            Path destination = Paths.get(getFilePath(destFilename));
                
                            Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);
                            logger.debug("Copied {} to {}", sourceFilename, destFilename);
                            return true;
                
                        } catch (IOException e) {
                            logger.error("Error copying file {} to {}: {}",
                                    sourceFilename, destFilename, e.getMessage());
                            return false;
                        } finally {
                            destLock.unlock();
                            sourceLock.unlock();
                        }
                    }
                
                    /**
                     * Создание резервной копии файла
                     */
                    public static void createBackup(String filename) {
                        if (!Config.getBoolean("storage.backup.enabled", true)) {
                            return;
                        }
                
                        try {
                            String backupDir = "backups";
                            String timestamp = new java.text.SimpleDateFormat("yyyyMMdd_HHmmss")
                                    .format(new java.util.Date());
                
                            String backupFilename = String.format("%s/%s_%s.backup",
                                    backupDir, filename.replace("/", "_"), timestamp);
                
                            copyFile(filename, backupFilename);
                
                            // Сжатие резервной копии
                            compressFile(backupFilename);
                
                            // Очистка старых резервных копий
                            cleanupOldBackups(filename);
                
                        } catch (Exception e) {
                            logger.error("Error creating backup for {}: {}", filename, e.getMessage());
                        }
                    }
                
                    /**
                     * Сжатие файла с использованием GZIP
                     */
                    private static void compressFile(String filename) {
                        try {
                            File inputFile = new File(getFilePath(filename));
                            File outputFile = new File(getFilePath(filename + ".gz"));
                
                            try (FileInputStream fis = new FileInputStream(inputFile);
                                 FileOutputStream fos = new FileOutputStream(outputFile);
                                 GZIPOutputStream gzipOS = new GZIPOutputStream(fos)) {
                
                                byte[] buffer = new byte[1024];
                                int len;
                                while ((len = fis.read(buffer)) != -1) {
                                    gzipOS.write(buffer, 0, len);
                                }
                            }
                
                            // Удаление несжатого файла
                            inputFile.delete();
                            logger.debug("Compressed backup file: {}", outputFile.getName());
                
                        } catch (IOException e) {
                            logger.error("Error compressing file {}: {}", filename, e.getMessage());
                        }
                    }
                
                    /**
                     * Очистка старых резервных копий
                     */
                    private static void cleanupOldBackups(String originalFilename) {
                        try {
                            String backupDir = getFilePath("backups");
                            File dir = new File(backupDir);
                
                            if (!dir.exists()) {
                                return;
                            }
                
                            String baseName = originalFilename.replace("/", "_");
                            File[] backupFiles = dir.listFiles((d, name) ->
                                    name.startsWith(baseName + "_") && name.endsWith(".backup.gz"));
                
                            if (backupFiles == null || backupFiles.length <= 10) {
                                return; // Сохраняем последние 10 копий
                            }
                
                            // Сортировка по времени изменения (старые первыми)
                            Arrays.sort(backupFiles, Comparator.comparingLong(File::lastModified));
                
                            // Удаление старых копий
                            for (int i = 0; i < backupFiles.length - 10; i++) {
                                backupFiles[i].delete();
                                logger.debug("Deleted old backup: {}", backupFiles[i].getName());
                            }
                
                        } catch (Exception e) {
                            logger.error("Error cleaning up old backups: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение списка файлов в директории
                     */
                    public static List<String> listFiles(String directory) {
                        String dirPath = getFilePath(directory);
                        File dir = new File(dirPath);
                
                        if (!dir.exists() || !dir.isDirectory()) {
                            return new ArrayList<>();
                        }
                
                        File[] files = dir.listFiles();
                        if (files == null) {
                            return new ArrayList<>();
                        }
                
                        List<String> fileList = new ArrayList<>();
                        for (File file : files) {
                            if (file.isFile()) {
                                fileList.add(file.getName());
                            }
                        }
                
                        return fileList;
                    }
                
                    /**
                     * Получение размера файла в байтах
                     */
                    public static long getFileSize(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists() ? file.length() : 0;
                    }
                
                    /**
                     * Получение времени последнего изменения файла
                     */
                    public static long getLastModified(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists() ? file.lastModified() : 0;
                    }
                
                    /**
                     * Проверка, является ли файл пустым
                     */
                    public static boolean isEmpty(String filename) {
                        File file = new File(getFilePath(filename));
                        return !file.exists() || file.length() == 0;
                    }
                
                    /**
                     * Создание директории
                     */
                    public static boolean createDirectory(String directory) {
                        String dirPath = getFilePath(directory);
                        File dir = new File(dirPath);
                        return dir.mkdirs();
                    }
                
                    /**
                     * Получение статистики файлового хранилища
                     */
                    public static Map<String, Object> getStorageStats() {
                        Map<String, Object> stats = new HashMap<>();
                
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        File dir = new File(dataDir);
                
                        if (!dir.exists()) {
                            stats.put("status", "directory_not_exists");
                            return stats;
                        }
                
                        stats.put("directory", dataDir);
                        stats.put("exists", true);
                        stats.put("totalSpace", dir.getTotalSpace());
                        stats.put("freeSpace", dir.getFreeSpace());
                        stats.put("usableSpace", dir.getUsableSpace());
                
                        // Подсчет файлов
                        File[] files = dir.listFiles();
                        if (files != null) {
                            stats.put("totalFiles", files.length);
                
                            long totalSize = 0;
                            for (File file : files) {
                                totalSize += file.length();
                            }
                            stats.put("totalSizeBytes", totalSize);
                            stats.put("totalSizeMB", totalSize / (1024 * 1024));
                        }
                
                        return stats;
                    }
                }
                ----------------------------------------
            [DIR] telegram

              [FILE] TelegramNotificationService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/telegram/TelegramNotificationService.java
                Размер: 9465 байт
                Дата изменения: 2026-01-20T09:55:35.22051932Z
                Содержимое:
                ----------------------------------------
                package com.parser.telegram;
                
                import com.parser.config.Config;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
                import org.telegram.telegrambots.meta.api.methods.send.SendPhoto;
                import org.telegram.telegrambots.meta.api.objects.InputFile;
                import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
                
                import java.net.URL;
                import java.util.Date;
                
                /**
                 * Сервис для отправки уведомлений через Telegram
                 */
                public class TelegramNotificationService {
                    private static final Logger logger = LoggerFactory.getLogger(TelegramNotificationService.class);
                
                    private static TelegramBotService botInstance;
                
                    /**
                     * Установка экземпляра бота для отправки уведомлений
                     */
                    public static void setBotInstance(TelegramBotService bot) {
                        botInstance = bot;
                        logger.info("TelegramNotificationService initialized with bot instance");
                    }
                
                    /**
                     * Отправка простого текстового сообщения
                     */
                    public static boolean sendMessage(long userId, String text) {
                        return sendMessage(userId, text, false);
                    }
                
                    /**
                     * Отправка текстового сообщения с HTML форматированием
                     */
                    public static boolean sendHtmlMessage(long userId, String htmlText) {
                        return sendMessage(userId, htmlText, true);
                    }
                
                    /**
                     * Основной метод отправки сообщения
                     */
                    private static boolean sendMessage(long userId, String text, boolean useHtml) {
                        if (botInstance == null) {
                            logger.error("Bot instance not set for TelegramNotificationService");
                            return false;
                        }
                
                        if (text == null || text.trim().isEmpty()) {
                            logger.warn("Attempted to send empty message to user {}", userId);
                            return false;
                        }
                
                        try {
                            SendMessage message = new SendMessage();
                            message.setChatId(String.valueOf(userId));
                
                            if (useHtml) {
                                message.setText(text);
                                message.setParseMode("HTML");
                                message.disableWebPagePreview();
                            } else {
                                message.setText(text);
                            }
                
                            botInstance.execute(message);
                            logger.debug("Message sent to user {}", userId);
                            return true;
                
                        } catch (TelegramApiException e) {
                            logger.error("Error sending message to user {}: {}", userId, e.getMessage());
                
                            if (useHtml) {
                                logger.info("Retrying without HTML formatting...");
                                String plainText = stripHtml(text);
                                return sendMessage(userId, plainText, false);
                            }
                            return false;
                        }
                    }
                
                    /**
                     * Отправка фото с подписью (HTML форматирование)
                     */
                    public static boolean sendPhotoWithHtmlCaption(long userId, String photoUrl, String htmlCaption) {
                        if (botInstance == null) {
                            logger.error("Bot instance not set for TelegramNotificationService");
                            return false;
                        }
                
                        if (photoUrl == null || photoUrl.isEmpty()) {
                            logger.warn("Empty photo URL for user {}", userId);
                            return false;
                        }
                
                        try {
                            // Проверяем, является ли URL валидным
                            if (!isValidUrl(photoUrl)) {
                                logger.warn("Invalid photo URL: {}", photoUrl);
                                return sendHtmlMessage(userId, htmlCaption);
                            }
                
                            SendPhoto photo = new SendPhoto();
                            photo.setChatId(String.valueOf(userId));
                
                            // Используем URL напрямую
                            photo.setPhoto(new InputFile(photoUrl));
                
                            if (htmlCaption != null && !htmlCaption.isEmpty()) {
                                // Обрезаем подпись если она слишком длинная (макс 1024 символа для Telegram)
                                if (htmlCaption.length() > 1024) {
                                    htmlCaption = htmlCaption.substring(0, 1020) + "...";
                                }
                                photo.setCaption(htmlCaption);
                                photo.setParseMode("HTML");
                            }
                
                            botInstance.execute(photo);
                            logger.debug("Photo with caption sent to user {}", userId);
                            return true;
                
                        } catch (TelegramApiException e) {
                            logger.error("Error sending photo to user {}: {}", userId, e.getMessage());
                
                            // Если не удалось отправить фото, отправляем текстовое сообщение
                            if (htmlCaption != null && !htmlCaption.isEmpty()) {
                                String textMessage = "📸 " + stripHtml(htmlCaption);
                                return sendMessage(userId, textMessage);
                            }
                            return false;
                        } catch (Exception e) {
                            logger.error("Unexpected error sending photo to user {}: {}", userId, e.getMessage());
                            return sendHtmlMessage(userId, htmlCaption);
                        }
                    }
                
                    /**
                     * Проверка валидности URL
                     */
                    private static boolean isValidUrl(String url) {
                        try {
                            new URL(url).toURI();
                            return true;
                        } catch (Exception e) {
                            return false;
                        }
                    }
                
                    /**
                     * Удаление HTML тегов из текста
                     */
                    private static String stripHtml(String html) {
                        if (html == null) return "";
                        return html.replaceAll("<[^>]*>", "")
                                .replace("&amp;", "&")
                                .replace("&lt;", "<")
                                .replace("&gt;", ">")
                                .replace("&quot;", "\"")
                                .replace("&#39;", "'");
                    }
                
                    /**
                     * Экранирование для HTML
                     */
                    public static String escapeHtml(String text) {
                        if (text == null) return "";
                
                        return text.replace("&", "&amp;")
                                .replace("<", "&lt;")
                                .replace(">", "&gt;")
                                .replace("\"", "&quot;")
                                .replace("'", "&#39;");
                    }
                
                    /**
                     * Отправка тестового уведомления
                     */
                    public static boolean sendTestNotification(long userId) {
                        logger.info("Sending test notification to user {}", userId);
                
                        String message = "<b>✅ Test notification</b>\n\n" +
                                "Parser is working correctly!\n" +
                                "This is a test message to confirm that the notification system is functioning.\n\n" +
                                "<i>Time: " + new Date() + "</i>";
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления о найденных товарах
                     */
                    public static boolean sendProductsNotification(long userId, int count, String query) {
                        String message = String.format("<b>🛍️ Found products!</b>\n\n" +
                                "Query: %s\n" +
                                "Products found: %d\n\n" +
                                "<i>Sending details...</i>", escapeHtml(query), count);
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления об ошибке
                     */
                    public static boolean sendErrorNotification(long userId, String errorMessage) {
                        String message = String.format("<b>❌ Parser error</b>\n\n" +
                                        "An error occurred:\n" +
                                        "<code>%s</code>\n\n" +
                                        "<i>The parser will be restarted automatically.</i>",
                                escapeHtml(errorMessage));
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления о состоянии парсера
                     */
                    public static boolean sendStatusNotification(long userId, String status, String details) {
                        String emoji = "🟢";
                        if (status.contains("stopped")) emoji = "🔴";
                        if (status.contains("paused")) emoji = "⏸️";
                        if (status.contains("error")) emoji = "❌";
                
                        String message = String.format("%s <b>Parser status changed</b>\n\n" +
                                "New status: %s\n\n" +
                                "%s", emoji, status, escapeHtml(details));
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления администратору
                     */
                    public static boolean sendAdminNotification(String message) {
                        long adminId = Config.getTelegramAdminId();
                        if (adminId == 0) {
                            logger.warn("Admin ID not configured");
                            return false;
                        }
                
                        String adminMessage = String.format("<b>👑 Admin notification</b>\n\n" +
                                        "%s\n\n" +
                                        "<i>Time: %s</i>",
                                escapeHtml(message),
                                new Date());
                
                        return sendHtmlMessage(adminId, adminMessage);
                    }
                
                    /**
                     * Проверка доступности бота
                     */
                    public static boolean isBotAvailable() {
                        return botInstance != null;
                    }
                
                    /**
                     * Отправка фото с подписью (удобный метод для использования из других классов)
                     */
                    public static boolean sendPhotoWithCaption(long userId, String photoUrl, String caption) {
                        return sendPhotoWithHtmlCaption(userId, photoUrl, caption);
                    }
                }
                ----------------------------------------

              [FILE] TelegramBotService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/telegram/TelegramBotService.java
                Размер: 25999 байт
                Дата изменения: 2026-01-28T19:07:03.454460295Z
                Содержимое:
                ----------------------------------------
                package com.parser.telegram;
                
                import com.parser.config.Config;
                import com.parser.core.ThreadManager;
                import com.parser.model.UserSettings;
                import com.parser.service.CookieService;
                import com.parser.storage.AccessRequestManager;
                import com.parser.storage.UserSentProductsManager;
                import com.parser.storage.WhitelistManager;
                import com.parser.storage.UserDataManager;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import org.telegram.telegrambots.bots.TelegramLongPollingBot;
                import org.telegram.telegrambots.meta.api.methods.commands.SetMyCommands;
                import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
                import org.telegram.telegrambots.meta.api.objects.commands.BotCommand;
                import org.telegram.telegrambots.meta.api.objects.commands.scope.BotCommandScopeChat;
                import org.telegram.telegrambots.meta.api.objects.commands.scope.BotCommandScopeDefault;
                import org.telegram.telegrambots.meta.api.objects.Update;
                import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
                
                import java.util.*;
                
                /**
                 * Telegram бот сервис - рефакторированный и оптимизированный
                 */
                public class TelegramBotService extends TelegramLongPollingBot {
                    private static final Logger logger = LoggerFactory.getLogger(TelegramBotService.class);
                
                    private final ThreadManager threadManager;
                    private final long adminId;
                    private final Map<Long, String> userStates = new java.util.concurrent.ConcurrentHashMap<>();
                    private final Map<Long, Map<String, String>> userData = new java.util.concurrent.ConcurrentHashMap<>();
                
                    public TelegramBotService(String token, ThreadManager threadManager) {
                        super(token);
                        this.threadManager = threadManager;
                        this.adminId = Config.getTelegramAdminId();
                        logger.info("TelegramBotService initialized");
                    }
                
                    /**
                     * Настраивает меню команд (кнопка слева от поля ввода).
                     * Вызывать после старта/регистрации бота.
                     */
                    public void configureCommandMenu() {
                        try {
                            List<BotCommand> userCommands = List.of(
                                    new BotCommand("/start", "Запуск / проверка доступа"),
                                    new BotCommand("/help", "Справка"),
                                    new BotCommand("/getid", "Показать мой ID"),
                                    new BotCommand("/addquery", "Добавить запрос"),
                                    new BotCommand("/listqueries", "Список запросов"),
                                    new BotCommand("/removequery", "Удалить запрос"),
                                    new BotCommand("/clearqueries", "Очистить запросы"),
                                    new BotCommand("/settings", "Настройки"),
                                    new BotCommand("/start_parser", "Запустить парсер"),
                                    new BotCommand("/stop_parser", "Остановить парсер"),
                                    new BotCommand("/status", "Статус"),
                                    new BotCommand("/stats", "Статистика"),
                                    new BotCommand("/clearhistory", "Очистить историю отправленных")
                            );
                
                            execute(new SetMyCommands(userCommands, new BotCommandScopeDefault(), "ru"));
                            logger.info("✅ User command menu configured");
                
                            if (adminId != 0) {
                                List<BotCommand> adminCommands = new ArrayList<>(userCommands);
                                adminCommands.add(new BotCommand("/admin", "Админ-меню"));
                                adminCommands.add(new BotCommand("/cookies", "Cookies"));
                                adminCommands.add(new BotCommand("/help", "Справка (используй: /help admin)"));
                
                                execute(new SetMyCommands(adminCommands, new BotCommandScopeChat(String.valueOf(adminId)), "ru"));
                                logger.info("✅ Admin command menu configured for {}", adminId);
                            }
                        } catch (Exception e) {
                            logger.warn("Failed to configure command menu: {}", e.getMessage());
                        }
                    }
                
                    @Override
                    public void onUpdateReceived(Update update) {
                        try {
                            if (update.hasMessage() && update.getMessage().hasText()) {
                                handleMessage(update.getMessage());
                            } else if (update.hasCallbackQuery()) {
                                handleCallback(update.getCallbackQuery());
                            }
                        } catch (Exception e) {
                            logger.error("Error processing update: {}", e.getMessage());
                        }
                    }
                
                    private void handleMessage(org.telegram.telegrambots.meta.api.objects.Message msg) {
                        long userId = msg.getChatId();
                        String text = msg.getText();
                
                        logger.debug("Message from {}: {}", userId, text);
                
                        if (text.startsWith("/")) {
                            handleCommand(userId, text);
                        } else {
                            handleTextResponse(userId, text);
                        }
                    }
                
                    private void handleCommand(long userId, String command) {
                        String[] parts = command.split(" ", 2);
                        String cmd = parts[0].toLowerCase();
                        String args = parts.length > 1 ? parts[1] : "";
                
                        switch (cmd) {
                            case "/start":
                                handleStart(userId);
                                break;
                            case "/help":
                                handleHelpCommand(userId, args);
                                break;
                            case "/status":
                                if (requireAuthorized(userId)) {
                                    sendStatus(userId);
                                }
                                break;
                            case "/addquery":
                                handleAddQuery(userId, args);
                                break;
                            case "/listqueries":
                                handleListQueries(userId);
                                break;
                            case "/removequery":
                                handleRemoveQuery(userId, args);
                                break;
                            case "/settings":
                                handleSettingsCommand(userId, args);
                                break;
                            case "/clearqueries":
                                if (requireAuthorized(userId)) {
                                    UserDataManager.clearUserQueries(userId);
                                    sendMessage(userId, "✅ Запросы очищены. Добавить: /addquery");
                                }
                                break;
                            case "/clearhistory":
                                if (requireAuthorized(userId)) {
                                    UserSentProductsManager.clearUserHistory(userId);
                                    sendMessage(userId, "✅ История отправленных товаров очищена.");
                                }
                                break;
                            case "/start_parser":
                                if (requireAuthorized(userId)) {
                                    threadManager.startUserParser(userId);
                                }
                                break;
                            case "/stop_parser":
                                if (requireAuthorized(userId)) {
                                    threadManager.stopUserParser(userId);
                                }
                                break;
                            case "/stats":
                                if (requireAuthorized(userId)) {
                                    sendStats(userId);
                                }
                                break;
                            case "/cookies":
                                handleCookiesCommand(userId, args);
                                break;
                            case "/admin":
                                handleAdminCommand(userId, args);
                                break;
                            case "/getid":
                                sendMessage(userId, "Ваш ID: " + userId);
                                break;
                            default:
                                sendMessage(userId, "Неизвестная команда. Используй /help");
                        }
                    }
                
                    private void handleTextResponse(long userId, String text) {
                        String state = userStates.get(userId);
                        if (state == null) {
                            sendMessage(userId, "Используй команды. /help — список команд");
                            return;
                        }
                
                        switch (state) {
                            case "AWAITING_QUERY":
                                if (!requireAuthorized(userId)) {
                                    userStates.remove(userId);
                                    userData.remove(userId);
                                    return;
                                }
                                if (UserDataManager.addUserQuery(userId, text.trim())) {
                                    sendMessage(userId, "✅ Query added: " + text);
                                } else {
                                    sendMessage(userId, "⚠️ Query already exists");
                                }
                                userStates.remove(userId);
                                break;
                            case "AWAITING_SETTING_VALUE":
                                handleSettingUpdate(userId, text);
                                break;
                        }
                    }
                
                    private void handleCallback(org.telegram.telegrambots.meta.api.objects.CallbackQuery callback) {
                        long userId = callback.getMessage().getChatId();
                        String data = callback.getData();
                
                        logger.debug("Callback from {}: {}", userId, data);
                
                        try {
                            execute(new org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery(callback.getId()));
                        } catch (TelegramApiException e) {
                            logger.warn("Failed to answer callback: {}", e.getMessage());
                        }
                    }
                
                    private void handleStart(long userId) {
                        // ❗️Пользователи попадают в whitelist ТОЛЬКО через админа (см. /admin adduser)
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            AccessRequestManager.recordAccessRequest(userId, "/start");
                            String msg = "👋 Привет!\n\n" +
                                    "❌ У вас нет доступа к боту.\n" +
                                    "Отправьте администратору ваш ID: " + userId + "\n\n" +
                                    "Команда: /getid";
                            sendMessage(userId, msg);
                            return;
                        }
                
                        sendMessage(userId, "👋 Привет! Используй /help для списка команд.");
                    }
                
                    private void handleAddQuery(long userId, String query) {
                        if (!requireAuthorized(userId)) return;
                
                        if (query.trim().isEmpty()) {
                            userStates.put(userId, "AWAITING_QUERY");
                            sendMessage(userId, "Enter search query:");
                            return;
                        }
                
                        if (UserDataManager.addUserQuery(userId, query.trim())) {
                            sendMessage(userId, "✅ Query added: " + query);
                        } else {
                            sendMessage(userId, "⚠️ Query already exists or limit reached");
                        }
                    }
                
                    private void handleListQueries(long userId) {
                        if (!requireAuthorized(userId)) return;
                
                        List<String> queries = UserDataManager.getUserQueries(userId);
                        if (queries.isEmpty()) {
                            sendMessage(userId, "📭 Запросов нет. Добавь: /addquery");
                            return;
                        }
                
                        StringBuilder sb = new StringBuilder("📋 Ваши запросы:\n\n");
                        for (int i = 0; i < queries.size(); i++) {
                            sb.append(String.format("%d. %s\n", i + 1, queries.get(i)));
                        }
                
                        sendMessage(userId, sb.toString());
                    }
                
                    private void handleRemoveQuery(long userId, String arg) {
                        if (!requireAuthorized(userId)) return;
                
                        try {
                            if (arg.trim().isEmpty()) {
                                sendMessage(userId, "Использование: /removequery [номер]");
                                return;
                            }
                
                            int idx = Integer.parseInt(arg.trim()) - 1;
                            List<String> queries = UserDataManager.getUserQueries(userId);
                
                            if (idx < 0 || idx >= queries.size()) {
                                sendMessage(userId, "❌ Неверный номер");
                                return;
                            }
                
                            UserDataManager.removeUserQuery(userId, queries.get(idx));
                            sendMessage(userId, "✅ Запрос удалён");
                        } catch (NumberFormatException e) {
                            sendMessage(userId, "❌ Неверный формат. Использование: /removequery [номер]");
                        }
                    }
                
                
                    private void handleSettingUpdate(long userId, String value) {
                        try {
                            int intVal = Integer.parseInt(value.trim());
                            UserSettings settings = UserDataManager.getUserSettings(userId);
                            Map<String, String> data = userData.get(userId);
                
                            if (data != null && data.containsKey("setting_key")) {
                                String key = data.get("setting_key");
                                switch (key) {
                                    case "check_interval":
                                        settings.setCheckInterval(intVal);
                                        break;
                                    case "max_age":
                                        settings.setMaxAgeMinutes(intVal);
                                        break;
                                    case "max_pages":
                                        settings.setMaxPages(intVal);
                                        break;
                                    case "rows_per_page":
                                        settings.setRowsPerPage(intVal);
                                        break;
                                }
                                UserDataManager.saveUserSettings(userId, settings);
                                sendMessage(userId, "✅ Setting saved");
                            }
                        } catch (NumberFormatException e) {
                            sendMessage(userId, "❌ Invalid number");
                        } finally {
                            userStates.remove(userId);
                            userData.remove(userId);
                        }
                    }
                
                    private void handleHelpCommand(long userId, String args) {
                        String a = args == null ? "" : args.trim().toLowerCase(Locale.ROOT);
                        if ("admin".equals(a)) {
                            if (userId != adminId) {
                                sendMessage(userId, "❌ Только для администратора");
                                return;
                            }
                            sendAdminHelpMessage(userId);
                            return;
                        }
                        sendUserHelpMessage(userId);
                    }
                
                    private void sendUserHelpMessage(long userId) {
                        String help = """
                                📚 Команды пользователя:
                
                                ℹ️ Доступ:
                                /start - приветствие/проверка доступа
                                /getid - показать ваш ID (чтобы отправить админу)
                
                                🎯 Запросы:
                                /addquery [текст] - добавить запрос
                                /listqueries - список запросов
                                /removequery [номер] - удалить запрос
                                /clearqueries - очистить все запросы
                
                                ⚙️ Настройки:
                                /settings - показать настройки
                                /settings check_interval <сек>
                                /settings max_age <мин>
                                /settings max_pages <число>
                                /settings rows_per_page <число>
                
                                ▶️ Парсер:
                                /start_parser - запустить
                                /stop_parser - остановить
                                /status - статус
                                /stats - статистика
                
                                🧹 История:
                                /clearhistory - очистить историю отправленных товаров
                
                                👑 Админ:
                                /help admin - команды админа
                                """;
                        sendMessage(userId, help);
                    }
                
                    private void sendAdminHelpMessage(long userId) {
                        String help = """
                                👑 Команды админа:
                
                                ✅ Доступ:
                                /admin users - список пользователей whitelist
                                /admin adduser <id> - добавить пользователя
                                /admin removeuser <id> - удалить пользователя
                                /admin pending - заявки на доступ
                
                                🍪 Cookies:
                                /cookies - меню
                                /cookies status - статус
                                /cookies refresh - обновить
                                /cookies dynamic - включить/выключить динамические
                
                                ℹ️ Справка:
                                /help - команды пользователя
                                """;
                        sendMessage(userId, help);
                    }
                
                    private void sendSettingsMenu(long userId) {
                        UserSettings s = UserDataManager.getUserSettings(userId);
                        String msg = String.format("""
                                ⚙️ Settings:
                                • Interval: %d sec
                                • Max age: %d min
                                • Pages: %d
                                • Rows/page: %d
                                • Currency: %s
                                
                                Update with:
                                /settings check_interval <seconds>
                                /settings max_age <minutes>
                                /settings max_pages <number>
                                /settings rows_per_page <number>
                                """, s.getCheckInterval(), s.getMaxAgeMinutes(), s.getMaxPages(),
                                s.getRowsPerPage(), s.getPriceCurrency());
                        sendMessage(userId, msg);
                    }
                
                    private void handleSettingsCommand(long userId, String args) {
                        if (!requireAuthorized(userId)) {
                            return;
                        }
                
                        if (args == null || args.trim().isEmpty()) {
                            sendSettingsMenu(userId);
                            return;
                        }
                
                        String[] parts = args.trim().split("\\s+");
                        if (parts.length < 2) {
                            sendMessage(userId, "Использование: /settings <параметр> <значение>\nПример: /settings check_interval 300");
                            return;
                        }
                
                        String key = parts[0].toLowerCase(Locale.ROOT);
                        String value = parts[1];
                
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                        try {
                            int intVal = Integer.parseInt(value.trim());
                            switch (key) {
                                case "check_interval":
                                    settings.setCheckInterval(intVal);
                                    break;
                                case "max_age":
                                    settings.setMaxAgeMinutes(intVal);
                                    break;
                                case "max_pages":
                                    settings.setMaxPages(intVal);
                                    break;
                                case "rows_per_page":
                                    settings.setRowsPerPage(intVal);
                                    break;
                                default:
                                    sendMessage(userId, "❌ Неизвестная настройка: " + key + "\nОткрой меню: /settings");
                                    return;
                            }
                
                            UserDataManager.saveUserSettings(userId, settings);
                            sendMessage(userId, "✅ Настройка сохранена.\n" + settings.getSummary());
                        } catch (NumberFormatException e) {
                            sendMessage(userId, "❌ Неверное число: " + value);
                        }
                    }
                
                    private void sendStatus(long userId) {
                        Map<String, Object> status = threadManager.getUserStatus(userId);
                        if (status == null) {
                            sendMessage(userId, "🔴 Парсер не запущен");
                            return;
                        }
                
                        String msg = String.format(
                                "📊 Parser Status:\n\n" +
                                        "Status: %s\n" +
                                        "Products found: %d\n" +
                                        "Requests made: %d\n" +
                                        "Errors: %d\n" +
                                        "Uptime: %s",
                                status.get("status"),
                                status.get("totalProductsFound"),
                                status.get("requestsMade"),
                                status.get("errorsCount"),
                                status.getOrDefault("uptime", "N/A")
                        );
                
                        sendMessage(userId, msg);
                    }
                
                    private void sendStats(long userId) {
                        Map<String, Object> global = threadManager.getGlobalStatistics();
                        Map<String, Object> user = threadManager.getUserStatus(userId);
                
                        String msg = String.format("""
                                📊 Statistics:
                                
                                Global:
                                • Users: %d
                                • Products: %d
                                • Requests: %d
                                • Threads: %d
                                
                                Your parser: %s
                                """, global.get("totalUsers"), global.get("totalProductsFound"),
                                global.get("totalRequestsMade"), global.get("activeThreads"),
                                user == null ? "Not running" : "Running");
                        sendMessage(userId, msg);
                    }
                
                    private void handleCookiesCommand(long userId, String args) {
                        if (userId != adminId) {
                            sendMessage(userId, "❌ Только для администратора");
                            return;
                        }
                
                        if (args.isEmpty()) {
                            String msg = """
                                    🍪 Cookie Management:
                                    /cookies refresh - update cookies
                                    /cookies status - cookie status
                                    /cookies dynamic - toggle dynamic cookies
                                    """;
                            sendMessage(userId, msg);
                            return;
                        }
                
                        if (args.equals("refresh")) {
                            sendMessage(userId, "🔄 Updating cookies...");
                            try {
                                CookieService.refreshCookies("h5api.m.goofish.com");
                                sendMessage(userId, "✅ Cookies updated");
                            } catch (Exception e) {
                                sendMessage(userId, "❌ Error: " + e.getMessage());
                            }
                        } else if (args.equals("status")) {
                            Map<String, Object> stats = CookieService.getCacheStats();
                            String msg = "🍪 Cookie status:\n\n" +
                                    "Dynamic: " + Config.isDynamicCookiesEnabled() + "\n" +
                                    "Cached domains: " + stats.getOrDefault("cachedDomains", "N/A") + "\n" +
                                    "Last refresh: " + stats.getOrDefault("lastRefreshTime", "N/A") + "\n" +
                                    "TTL (min): " + stats.getOrDefault("cacheTTLMinutes", "N/A") + "\n";
                            sendMessage(userId, msg);
                        } else if (args.equals("dynamic")) {
                            boolean current = Config.isDynamicCookiesEnabled();
                            Config.setProperty("cookie.dynamic.enabled", String.valueOf(!current));
                            Config.saveConfig();
                            sendMessage(userId, "✅ Dynamic cookies: " + (!current ? "ON" : "OFF"));
                        } else {
                            sendMessage(userId, "Неизвестная команда cookies. Используй /cookies");
                        }
                    }
                
                    private void handleAdminCommand(long userId, String args) {
                        if (userId != adminId) {
                            sendMessage(userId, "❌ Только для администратора");
                            return;
                        }
                
                        if (args.isEmpty()) {
                            String menu = """
                                    👑 Admin:
                                    /admin stats - statistics
                                    /admin users - user list
                                    /admin adduser [id] - add user
                                    /admin removeuser [id] - remove user
                                    """;
                            sendMessage(userId, menu);
                            return;
                        }
                
                        String[] parts = args.split(" ", 2);
                        switch (parts[0]) {
                            case "stats":
                                sendStats(userId);
                                break;
                            case "users":
                                List<Long> users = WhitelistManager.getAllUsers();
                                Collections.sort(users);
                                StringBuilder sb = new StringBuilder("👥 Whitelist users: " + users.size() + "\n\n");
                                for (Long u : users) sb.append(u).append("\n");
                                sendMessage(userId, sb.toString());
                                break;
                            case "pending":
                                List<String> reqs = AccessRequestManager.getRequests();
                                if (reqs.isEmpty()) {
                                    sendMessage(userId, "📭 Заявок нет");
                                    break;
                                }
                                StringBuilder rsb = new StringBuilder("📨 Заявки на доступ:\n\n");
                                for (String line : reqs) {
                                    rsb.append(line).append("\n");
                                }
                                rsb.append("\nДобавить: /admin adduser <id>");
                                sendMessage(userId, rsb.toString());
                                break;
                            case "adduser":
                                if (parts.length > 1) {
                                    try {
                                        long uid = Long.parseLong(parts[1]);
                                        WhitelistManager.addUser(uid);
                                        AccessRequestManager.removeRequest(uid);
                                        sendMessage(userId, "✅ User added");
                                    } catch (NumberFormatException e) {
                                        sendMessage(userId, "❌ Invalid ID");
                                    }
                                } else {
                                    sendMessage(userId, "Use: /admin adduser [id]");
                                }
                                break;
                            case "removeuser":
                                if (parts.length > 1) {
                                    try {
                                        long uid = Long.parseLong(parts[1]);
                                        WhitelistManager.removeUser(uid);
                                        threadManager.stopUserParser(uid);
                                        sendMessage(userId, "✅ User removed");
                                    } catch (NumberFormatException e) {
                                        sendMessage(userId, "❌ Invalid ID");
                                    }
                                } else {
                                    sendMessage(userId, "Use: /admin removeuser [id]");
                                }
                                break;
                        }
                    }
                
                    private boolean requireAuthorized(long userId) {
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            AccessRequestManager.recordAccessRequest(userId, "unauthorized_command");
                            sendMessage(userId, "❌ Нет доступа. Отправь /getid администратору.");
                            return false;
                        }
                        return true;
                    }
                
                    protected void sendMessage(long userId, String text) {
                        SendMessage msg = new SendMessage(String.valueOf(userId), text);
                        // ВАЖНО: не используем Markdown, чтобы команды вида /start_parser не ломали entities.
                        msg.disableWebPagePreview();
                        try {
                            execute(msg);
                        } catch (TelegramApiException e) {
                            logger.error("Failed to send message: {}", e.getMessage());
                        }
                    }
                
                    @Override
                    public String getBotUsername() {
                        return Config.getTelegramBotUsername();
                    }
                }
                ----------------------------------------

            [FILE] Main.java
              Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/Main.java
              Размер: 7349 байт
              Дата изменения: 2026-02-02T19:10:39.229655534Z
              Содержимое:
              ----------------------------------------
              package com.parser;
              
              import com.parser.config.Config;
              import com.parser.core.ThreadManager;
              import com.parser.service.AutoCleanupService;
              import com.parser.service.CookieService;
              import com.parser.storage.FileStorage;
              import com.parser.storage.WhitelistManager;
              import com.parser.telegram.TelegramBotService;
              import com.parser.telegram.TelegramNotificationService;
              import org.slf4j.Logger;
              import org.slf4j.LoggerFactory;
              import org.telegram.telegrambots.meta.TelegramBotsApi;
              import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
              import org.telegram.telegrambots.updatesreceivers.DefaultBotSession;
              
              /**
               * Главный класс приложения - точка входа
               */
              public class Main {
                  private static final Logger logger = LoggerFactory.getLogger(Main.class);
                  private static ThreadManager threadManager;
                  private static TelegramBotService botService;
              
                  public static void main(String[] args) {
                      try {
                          logger.info("=".repeat(60));
                          logger.info("Product Parser with Real-Time Cookies");
                          logger.info("=".repeat(60));
              
                          // Проверка конфигурации
                          String botToken = Config.getTelegramBotToken();
                          String botUsername = Config.getTelegramBotUsername();
              
                          if (botToken.isEmpty() || botToken.equals("ВАШ_ТОКЕН_БОТА")) {
                              logger.error("❌ Bot token not configured!");
                              System.exit(1);
                          }
              
                          logger.info("✅ Configuration:");
                          logger.info("   Token: {}...", botToken.substring(0, Math.min(10, botToken.length())));
                          logger.info("   Username: @{}", botUsername);
                          logger.info("   Admin ID: {}", Config.getTelegramAdminId());
              
                          // Инициализация хранилища
                          FileStorage.ensureDataDir();
                          logger.info("✅ Data directory ready");
              
                          // Запуск сервиса автоочистки
                          AutoCleanupService.start();
                          logger.info("✅ Auto cleanup service started");
              
                          // 🔴 ВАЖНО: Инициализация и проверка cookies перед запуском парсера
                          logger.info("🍪 Инициализация системы cookies...");
                          CookieService.initialize();
              
                          // 🔴 ПРОВЕРКА COOKIES: Не запускаем парсер без валидных cookies
                          logger.info("🧪 Проверка cookies перед запуском...");
                          if (!CookieService.testCookies()) {
                              logger.error("❌ КРИТИЧЕСКАЯ ОШИБКА: Cookies недействительны!");
                              logger.error("   Пожалуйста, обновите cookies через /cookies refresh");
              
                              // Отправляем уведомление админу
                              if (Config.getTelegramAdminId() != 0) {
                                  TelegramNotificationService.setBotInstance(new TelegramBotService(botToken, null));
                                  TelegramNotificationService.sendAdminNotification(
                                          "⚠️ Парсер не запущен: cookies недействительны!\n" +
                                                  "Используйте /cookies refresh для обновления."
                                  );
                              }
              
                              // Ждем несколько секунд перед выходом
                              Thread.sleep(5000);
                              System.exit(1);
                          }
              
                          logger.info("✅ Cookies работают корректно");
              
                          // Инициализация менеджера потоков
                          threadManager = new ThreadManager();
                          logger.info("✅ ThreadManager initialized");
              
                          // Инициализация Telegram бота
                          initializeTelegramBot(botToken);
              
                          logger.info("=".repeat(60));
                          logger.info("✅ Application started successfully!");
                          logger.info("👑 Admin ID: {}", Config.getTelegramAdminId());
                          logger.info("🍪 Dynamic cookies: {}", Config.isDynamicCookiesEnabled());
                          logger.info("📋 Users: {}", WhitelistManager.getUserCount());
                          logger.info("=".repeat(60));
              
                          // Добавляем shutdown hook
                          Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                              logger.info("🛑 Получен сигнал завершения...");
                              shutdown();
                          }));
              
                          keepApplicationRunning();
              
                      } catch (Exception e) {
                          logger.error("❌ Startup error: {}", e.getMessage(), e);
                          shutdown();
                          System.exit(1);
                      }
                  }
              
                  private static void initializeTelegramBot(String botToken) throws TelegramApiException {
                      logger.info("🤖 Initializing Telegram bot...");
              
                      botService = new TelegramBotService(botToken, threadManager);
                      TelegramNotificationService.setBotInstance(botService);
              
                      TelegramBotsApi botsApi = new TelegramBotsApi(DefaultBotSession.class);
                      botsApi.registerBot(botService);
              
                      // Меню команд (кнопка слева от ввода в Telegram)
                      botService.configureCommandMenu();
              
                      logger.info("✅ Telegram bot registered and running");
                  }
              
                  private static void keepApplicationRunning() {
                      try {
                          logger.info("⏳ Application is running...");
              
                          long lastStatusLog = System.currentTimeMillis();
                          long lastCookieCheck = System.currentTimeMillis();
              
                          while (true) {
                              Thread.sleep(30000); // Проверка каждые 30 секунд
              
                              long now = System.currentTimeMillis();
              
                              // Логирование статуса каждые 5 минут
                              if (now - lastStatusLog > 5 * 60 * 1000) {
                                  if (threadManager.getActiveUsers().size() > 0) {
                                      logger.info("📊 Active users: {}", threadManager.getActiveUsers().size());
                                  }
                                  lastStatusLog = now;
                              }
              
                              // Проверка cookies каждые 30 минут
                              if (now - lastCookieCheck > 30 * 60 * 1000) {
                                  logger.info("🔄 Проверка состояния cookies...");
                                  if (!CookieService.hasValidCookies()) {
                                      logger.warn("⚠️ Cookies недействительны, обновление...");
                                      CookieService.refreshCookies("www.goofish.com");
                                  }
                                  lastCookieCheck = now;
                              }
                          }
                      } catch (InterruptedException e) {
                          Thread.currentThread().interrupt();
                          logger.info("Application interrupted");
                      }
                  }
              
                  private static void shutdown() {
                      logger.info("🛑 Shutting down...");
              
                      if (threadManager != null) {
                          threadManager.shutdown();
                      }
              
                      // Останавливаем сервис автоочистки
                      AutoCleanupService.shutdown();
              
                      // Останавливаем CookieService
                      CookieService.shutdown();
              
                      logger.info("✅ Shutdown complete");
                  }
              }
              ----------------------------------------
            [DIR] model

              [FILE] Product.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/model/Product.java
                Размер: 7450 байт
                Дата изменения: 2026-01-28T21:02:25.22849093Z
                Содержимое:
                ----------------------------------------
                package com.parser.model;
                
                import com.fasterxml.jackson.annotation.JsonIgnore;
                import com.fasterxml.jackson.annotation.JsonProperty;
                import com.parser.config.ParserSettings;
                import java.util.ArrayList;
                import java.util.List;
                
                /**
                 * Класс, представляющий товар
                 */
                public class Product {
                    private String id;
                    private String title;
                    private double price;
                    private String url;
                    private String site;
                    private String location;
                    private int ageMinutes;
                    private String query;
                    private List<String> images;
                    private String seller;
                    private String sellerRating;
                    private String category;
                    private boolean isNew;
                    private long foundTimestamp;
                
                    public Product() {
                        this.images = new ArrayList<>();
                        this.isNew = true;
                        this.foundTimestamp = System.currentTimeMillis();
                    }
                
                    public Product(String id, String title, double price, String url, String site,
                                   String location, int ageMinutes, String query) {
                        this();
                        this.id = id;
                        this.title = title;
                        this.price = price;
                        this.url = url;
                        this.site = site;
                        this.location = location;
                        this.ageMinutes = ageMinutes;
                        this.query = query;
                    }
                
                    // Геттеры и сеттеры
                
                    @JsonProperty("id")
                    public String getId() {
                        return id;
                    }
                
                    public void setId(String id) {
                        this.id = id;
                    }
                
                    @JsonProperty("title")
                    public String getTitle() {
                        return title;
                    }
                
                    public void setTitle(String title) {
                        if (title == null) {
                            this.title = "Без названия";
                        } else if (title.length() > 200) {
                            this.title = title.substring(0, 197) + "...";
                        } else {
                            this.title = title.trim();
                        }
                    }
                
                    @JsonProperty("price")
                    public double getPrice() {
                        return price;
                    }
                
                    public void setPrice(double price) {
                        this.price = Math.max(0, price);
                    }
                
                    @JsonProperty("url")
                    public String getUrl() {
                        return url;
                    }
                
                    public void setUrl(String url) {
                        this.url = url;
                    }
                
                    @JsonProperty("site")
                    public String getSite() {
                        return site;
                    }
                
                    public void setSite(String site) {
                        this.site = site;
                    }
                
                    @JsonProperty("location")
                    public String getLocation() {
                        return location;
                    }
                
                    public void setLocation(String location) {
                        this.location = location;
                    }
                
                    @JsonProperty("ageMinutes")
                    public int getAgeMinutes() {
                        return ageMinutes;
                    }
                
                    public void setAgeMinutes(int ageMinutes) {
                        this.ageMinutes = Math.max(0, ageMinutes);
                    }
                
                    @JsonProperty("query")
                    public String getQuery() {
                        return query;
                    }
                
                    public void setQuery(String query) {
                        this.query = query;
                    }
                
                    @JsonProperty("images")
                    public List<String> getImages() {
                        return new ArrayList<>(images);
                    }
                
                    public void setImages(List<String> images) {
                        this.images = new ArrayList<>(images);
                    }
                
                    public void addImage(String image) {
                        if (image != null && !image.trim().isEmpty()) {
                            this.images.add(image.trim());
                        }
                    }
                
                    @JsonProperty("seller")
                    public String getSeller() {
                        return seller;
                    }
                
                    public void setSeller(String seller) {
                        this.seller = seller;
                    }
                
                    @JsonProperty("sellerRating")
                    public String getSellerRating() {
                        return sellerRating;
                    }
                
                    public void setSellerRating(String sellerRating) {
                        this.sellerRating = sellerRating;
                    }
                
                    @JsonProperty("category")
                    public String getCategory() {
                        return category;
                    }
                
                    public void setCategory(String category) {
                        this.category = category;
                    }
                
                    @JsonProperty("isNew")
                    public boolean isNew() {
                        return isNew;
                    }
                
                    public void setNew(boolean isNew) {
                        this.isNew = isNew;
                    }
                
                    @JsonProperty("foundTimestamp")
                    public long getFoundTimestamp() {
                        return foundTimestamp;
                    }
                
                    public void setFoundTimestamp(long foundTimestamp) {
                        this.foundTimestamp = foundTimestamp;
                    }
                
                    // Методы для конвертации цены
                
                    @JsonIgnore
                    public double getPriceRubles() {
                        return Math.round(price * ParserSettings.getCurrencyRate(
                                ParserSettings.CURRENCY_YUAN, ParserSettings.CURRENCY_RUBLES) * 100.0) / 100.0;
                    }
                
                    @JsonIgnore
                    public String getPriceDisplay() {
                        return String.format("%.2f ¥", price);
                    }
                
                    @JsonIgnore
                    public String getPriceDisplayRub() {
                        return String.format("%.2f руб.", getPriceRubles());
                    }
                
                    @JsonIgnore
                    public String getFormattedPrice(String currency) {
                        if (ParserSettings.CURRENCY_RUBLES.equals(currency)) {
                            return getPriceDisplayRub();
                        } else {
                            return getPriceDisplay();
                        }
                    }
                
                    // Методы для удобства
                
                    @JsonIgnore
                    public String getShortTitle() {
                        if (title == null || title.isEmpty() || "No title".equals(title)) {
                            return "Товар #" + id;
                        }
                
                        if (title.length() <= 80) { // Уменьшаем лимит для более аккуратного отображения
                            return title;
                        }
                        return title.substring(0, 77) + "...";
                    }
                
                    @JsonIgnore
                    public String getAgeDisplay() {
                        if (ageMinutes < 60) {
                            return ageMinutes + " мин";
                        } else if (ageMinutes < 1440) {
                            return (ageMinutes / 60) + " ч";
                        } else {
                            return (ageMinutes / 1440) + " дн";
                        }
                    }
                
                    @JsonIgnore
                    public boolean hasImages() {
                        return !images.isEmpty();
                    }
                
                    @JsonIgnore
                    public String getMainImage() {
                        return images.isEmpty() ? null : images.get(0);
                    }
                
                    // НОВЫЙ МЕТОД: Получение URL обложки (первого изображения)
                    @JsonIgnore
                    public String getCoverImageUrl() {
                        if (images != null && !images.isEmpty()) {
                            return images.get(0);
                        }
                        return null;
                    }
                
                    // НОВЫЙ МЕТОД: Проверка наличия обложки
                    @JsonIgnore
                    public boolean hasCoverImage() {
                        return getCoverImageUrl() != null;
                    }
                
                    // Методы для сериализации
                
                    @JsonIgnore
                    public String toJsonString() {
                        return String.format(
                                "{\"id\":\"%s\",\"title\":\"%s\",\"price\":%.2f,\"url\":\"%s\",\"age\":%d}",
                                id, title.replace("\"", "\\\""), price, url, ageMinutes
                        );
                    }
                
                    @JsonIgnore
                    public String toCsvString() {
                        return String.format("%s,\"%s\",%.2f,%s,%s,%d",
                                id, title.replace("\"", "\"\""), price, url, location, ageMinutes);
                    }
                
                    @Override
                    public String toString() {
                        return String.format("Product{id='%s', title='%s', price=%.2f¥, age=%dmin, location=%s}",
                                id, getShortTitle(), price, ageMinutes, location);
                    }
                
                    @Override
                    public boolean equals(Object obj) {
                        if (this == obj) return true;
                        if (obj == null || getClass() != obj.getClass()) return false;
                        Product product = (Product) obj;
                        return id != null && id.equals(product.id);
                    }
                
                    @Override
                    public int hashCode() {
                        return id != null ? id.hashCode() : 0;
                    }
                }
                ----------------------------------------

              [FILE] UserSettings.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/model/UserSettings.java
                Размер: 8886 байт
                Дата изменения: 2026-01-28T19:39:40.586085721Z
                Содержимое:
                ----------------------------------------
                package com.parser.model;
                
                import com.fasterxml.jackson.annotation.JsonIgnore;
                import com.fasterxml.jackson.annotation.JsonProperty;
                import com.parser.config.Config;
                import com.parser.config.ParserSettings;
                import java.io.Serializable;
                
                /**
                 * Класс настроек пользователя для парсера
                 */
                public class UserSettings implements Serializable {
                    private static final long serialVersionUID = 1L;
                
                    // Основные настройки
                    private int checkInterval = 300; // секунды
                    private int maxAgeMinutes = 1440; // 24 часа
                    private int maxPages = 3;
                    private int rowsPerPage = 100;
                
                    // Валютные настройки
                    private String priceCurrency = ParserSettings.CURRENCY_RUBLES;
                
                    // Настройки уведомлений
                    private boolean notifyNewOnly = true;
                    private boolean notifyTelegram = true;
                    private boolean notifyEmail = false;
                    private boolean notifySound = true;
                
                    // Настройки фильтрации
                    private double minPrice = 0;
                    private double maxPrice = 0; // 0 = без ограничения
                    private String[] locations = {};
                    private String[] excludedKeywords = {};
                
                    // Расширенные настройки
                    private boolean enableProxy = false;
                    private String proxyAddress = "";
                    private int proxyPort = 0;
                    private int requestDelay = 2000; // мс
                    private int maxRetries = 3;
                
                    public UserSettings() {
                        // Дефолты берём из config.properties (чтобы совпадало с тем, что тестируется в браузере)
                        setCheckInterval(Config.getDefaultCheckInterval());
                        setMaxAgeMinutes(Config.getDefaultMaxAgeMinutes());
                        setMaxPages(Config.getDefaultMaxPages());
                        setRowsPerPage(Config.getDefaultRowsPerPage());
                    }
                
                    // Геттеры и сеттеры с валидацией
                
                    @JsonProperty("checkInterval")
                    public int getCheckInterval() {
                        return checkInterval;
                    }
                
                    public void setCheckInterval(int checkInterval) {
                        this.checkInterval = ParserSettings.normalizeCheckInterval(checkInterval);
                    }
                
                    @JsonProperty("maxAgeMinutes")
                    public int getMaxAgeMinutes() {
                        return maxAgeMinutes;
                    }
                
                    public void setMaxAgeMinutes(int maxAgeMinutes) {
                        this.maxAgeMinutes = ParserSettings.normalizeMaxAge(maxAgeMinutes);
                    }
                
                    @JsonProperty("maxPages")
                    public int getMaxPages() {
                        return maxPages;
                    }
                
                    public void setMaxPages(int maxPages) {
                        this.maxPages = Math.max(ParserSettings.MIN_MAX_PAGES,
                                Math.min(maxPages, ParserSettings.MAX_MAX_PAGES));
                    }
                
                    @JsonProperty("rowsPerPage")
                    public int getRowsPerPage() {
                        return rowsPerPage;
                    }
                
                    public void setRowsPerPage(int rowsPerPage) {
                        this.rowsPerPage = Math.max(ParserSettings.MIN_ROWS_PER_PAGE,
                                Math.min(rowsPerPage, ParserSettings.MAX_ROWS_PER_PAGE));
                    }
                
                    @JsonProperty("priceCurrency")
                    public String getPriceCurrency() {
                        return priceCurrency;
                    }
                
                    public void setPriceCurrency(String priceCurrency) {
                        if (ParserSettings.CURRENCY_YUAN.equals(priceCurrency) ||
                                ParserSettings.CURRENCY_RUBLES.equals(priceCurrency)) {
                            this.priceCurrency = priceCurrency;
                        }
                    }
                
                    @JsonProperty("notifyNewOnly")
                    public boolean isNotifyNewOnly() {
                        return notifyNewOnly;
                    }
                
                    public void setNotifyNewOnly(boolean notifyNewOnly) {
                        this.notifyNewOnly = notifyNewOnly;
                    }
                
                    @JsonProperty("notifyTelegram")
                    public boolean isNotifyTelegram() {
                        return notifyTelegram;
                    }
                
                    public void setNotifyTelegram(boolean notifyTelegram) {
                        this.notifyTelegram = notifyTelegram;
                    }
                
                    @JsonProperty("notifyEmail")
                    public boolean isNotifyEmail() {
                        return notifyEmail;
                    }
                
                    public void setNotifyEmail(boolean notifyEmail) {
                        this.notifyEmail = notifyEmail;
                    }
                
                    @JsonProperty("notifySound")
                    public boolean isNotifySound() {
                        return notifySound;
                    }
                
                    public void setNotifySound(boolean notifySound) {
                        this.notifySound = notifySound;
                    }
                
                    @JsonProperty("minPrice")
                    public double getMinPrice() {
                        return minPrice;
                    }
                
                    public void setMinPrice(double minPrice) {
                        this.minPrice = Math.max(0, minPrice);
                    }
                
                    @JsonProperty("maxPrice")
                    public double getMaxPrice() {
                        return maxPrice;
                    }
                
                    public void setMaxPrice(double maxPrice) {
                        this.maxPrice = maxPrice < 0 ? 0 : maxPrice;
                    }
                
                    @JsonProperty("locations")
                    public String[] getLocations() {
                        return locations != null ? locations.clone() : new String[0];
                    }
                
                    public void setLocations(String[] locations) {
                        this.locations = locations != null ? locations.clone() : new String[0];
                    }
                
                    @JsonProperty("excludedKeywords")
                    public String[] getExcludedKeywords() {
                        return excludedKeywords != null ? excludedKeywords.clone() : new String[0];
                    }
                
                    public void setExcludedKeywords(String[] excludedKeywords) {
                        this.excludedKeywords = excludedKeywords != null ? excludedKeywords.clone() : new String[0];
                    }
                
                    @JsonProperty("enableProxy")
                    public boolean isEnableProxy() {
                        return enableProxy;
                    }
                
                    public void setEnableProxy(boolean enableProxy) {
                        this.enableProxy = enableProxy;
                    }
                
                    @JsonProperty("proxyAddress")
                    public String getProxyAddress() {
                        return proxyAddress;
                    }
                
                    public void setProxyAddress(String proxyAddress) {
                        this.proxyAddress = proxyAddress != null ? proxyAddress.trim() : "";
                    }
                
                    @JsonProperty("proxyPort")
                    public int getProxyPort() {
                        return proxyPort;
                    }
                
                    public void setProxyPort(int proxyPort) {
                        this.proxyPort = Math.max(0, Math.min(proxyPort, 65535));
                    }
                
                    @JsonProperty("requestDelay")
                    public int getRequestDelay() {
                        return requestDelay;
                    }
                
                    public void setRequestDelay(int requestDelay) {
                        this.requestDelay = Math.max(500, Math.min(requestDelay, 10000));
                    }
                
                    @JsonProperty("maxRetries")
                    public int getMaxRetries() {
                        return maxRetries;
                    }
                
                    public void setMaxRetries(int maxRetries) {
                        this.maxRetries = Math.max(0, Math.min(maxRetries, 10));
                    }
                
                    // Методы для удобства
                
                    @JsonIgnore
                    public boolean hasPriceFilter() {
                        return maxPrice > 0 && maxPrice > minPrice;
                    }
                
                    @JsonIgnore
                    public boolean hasLocationFilter() {
                        return locations != null && locations.length > 0;
                    }
                
                    @JsonIgnore
                    public boolean hasKeywordFilter() {
                        return excludedKeywords != null && excludedKeywords.length > 0;
                    }
                
                    @JsonIgnore
                    public boolean isPriceInRange(double price) {
                        if (minPrice > 0 && price < minPrice) {
                            return false;
                        }
                        if (maxPrice > 0 && price > maxPrice) {
                            return false;
                        }
                        return true;
                    }
                
                    @JsonIgnore
                    public boolean isLocationAllowed(String location) {
                        if (!hasLocationFilter()) {
                            return true;
                        }
                
                        if (location == null || location.trim().isEmpty()) {
                            return false;
                        }
                
                        String locationLower = location.toLowerCase();
                        for (String allowedLocation : locations) {
                            if (locationLower.contains(allowedLocation.toLowerCase())) {
                                return true;
                            }
                        }
                
                        return false;
                    }
                
                    @JsonIgnore
                    public boolean isKeywordAllowed(String text) {
                        if (!hasKeywordFilter() || text == null) {
                            return true;
                        }
                
                        String textLower = text.toLowerCase();
                        for (String keyword : excludedKeywords) {
                            if (keyword != null && !keyword.trim().isEmpty() &&
                                    textLower.contains(keyword.toLowerCase())) {
                                return false;
                            }
                        }
                
                        return true;
                    }
                
                    @JsonIgnore
                    public boolean isValid() {
                        return ParserSettings.isValidCheckInterval(checkInterval) &&
                                ParserSettings.isValidMaxAge(maxAgeMinutes) &&
                                maxPages >= ParserSettings.MIN_MAX_PAGES &&
                                rowsPerPage >= ParserSettings.MIN_ROWS_PER_PAGE;
                    }
                
                    @JsonIgnore
                    public String getSummary() {
                        return String.format(
                                "Интервал: %d сек, Возраст: %d мин, Страниц: %d, Товаров на странице: %d",
                                checkInterval, maxAgeMinutes, maxPages, rowsPerPage
                        );
                    }
                
                    @Override
                    public String toString() {
                        return String.format(
                                "UserSettings{checkInterval=%d, maxAge=%d, maxPages=%d, rowsPerPage=%d}",
                                checkInterval, maxAgeMinutes, maxPages, rowsPerPage
                        );
                    }
                }
                ----------------------------------------
            [DIR] service

              [FILE] CookieService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/CookieService.java
                Размер: 18448 байт
                Дата изменения: 2026-02-02T19:24:42.366217107Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import com.parser.config.Config;
                import com.parser.config.CookieConfig;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.io.FileOutputStream;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                import java.util.concurrent.Executors;
                import java.util.concurrent.ScheduledExecutorService;
                import java.util.concurrent.TimeUnit;
                
                /**
                 * Сервис для работы с cookies через Selenium
                 */
                public class CookieService {
                    private static final Logger logger = LoggerFactory.getLogger(CookieService.class);
                
                    // Кэш cookies для доменов
                    private static final Map<String, Map<String, String>> cookieCache = new ConcurrentHashMap<>();
                    private static final Map<String, Long> cacheTimestamp = new ConcurrentHashMap<>();
                    private static final long CACHE_TTL = 30 * 60 * 1000; // 30 минут
                
                    private static long lastRefreshTime = 0;
                    private static final long REFRESH_INTERVAL = 120 * 60 * 1000; // 2 часа
                
                    private static ScheduledExecutorService scheduler;
                
                    // Основные домены для Goofish
                    private static final String PRIMARY_DOMAIN = "www.goofish.com";
                    private static final String API_DOMAIN = "h5api.m.goofish.com";
                    private static final String M_DOMAIN = "m.goofish.com";
                
                    /**
                     * Инициализация сервиса
                     */
                    public static synchronized void initialize() {
                        if (scheduler != null && !scheduler.isShutdown()) {
                            return;
                        }
                
                        logger.info("🍪 Инициализация CookieService...");
                
                        // Создаем планировщик для автообновления
                        scheduler = Executors.newScheduledThreadPool(1);
                
                        // Автообновление cookies каждые 2 часа
                        if (Config.getBoolean("cookie.auto.update", true)) {
                            int interval = Config.getInt("cookie.update.interval.minutes", 120);
                            scheduler.scheduleAtFixedRate(() -> {
                                try {
                                    logger.info("🔄 Автообновление cookies...");
                                    if (refreshCookies(PRIMARY_DOMAIN)) {
                                        logger.info("✅ Cookies успешно обновлены");
                                    } else {
                                        logger.warn("⚠️ Автообновление cookies не удалось");
                                    }
                                } catch (Exception e) {
                                    logger.error("❌ Ошибка при автообновлении cookies: {}", e.getMessage());
                                }
                            }, interval, interval, TimeUnit.MINUTES);
                
                            logger.info("✅ Автообновление настроено: каждые {} минут", interval);
                        }
                
                        // Предварительная загрузка cookies
                        try {
                            logger.info("🔄 Предварительная загрузка cookies...");
                            getFreshCookies(PRIMARY_DOMAIN);
                        } catch (Exception e) {
                            logger.error("❌ Ошибка предварительной загрузки cookies: {}", e.getMessage());
                        }
                
                        logger.info("✅ CookieService инициализирован");
                    }
                
                    /**
                     * Получение свежих cookies для домена
                     */
                    public static Map<String, String> getFreshCookies(String domain) {
                        if (!Config.isDynamicCookiesEnabled()) {
                            logger.debug("🍪 Динамические cookies отключены, используем статические");
                            return getCookiesFromConfig(domain);
                        }
                
                        // Проверяем кэш
                        if (cookieCache.containsKey(domain) && cacheTimestamp.containsKey(domain)) {
                            long cacheAge = System.currentTimeMillis() - cacheTimestamp.get(domain);
                            if (cacheAge < CACHE_TTL) {
                                logger.debug("🍪 Используем кэшированные cookies для {} (возраст: {} мин)",
                                        domain, cacheAge / (60 * 1000));
                                return new HashMap<>(cookieCache.get(domain));
                            } else {
                                logger.debug("🍪 Кэш cookies для {} устарел (возраст: {} мин)",
                                        domain, cacheAge / (60 * 1000));
                            }
                        }
                
                        logger.info("🔄 Получение свежих cookies для {}", domain);
                
                        // Получаем куки из конфига как fallback
                        Map<String, String> configCookies = getCookiesFromConfig(domain);
                
                        try {
                            // Получаем свежие cookies через Selenium
                            Map<String, String> freshCookies = SeleniumCookieFetcher.getFreshCookies();
                
                            if (SeleniumCookieFetcher.validateCookies(freshCookies)) {
                                // Сохраняем для всех доменов Goofish
                                updateCookieConfigForAllDomains(freshCookies);
                
                                // Обновляем кэш
                                cookieCache.put(PRIMARY_DOMAIN, new HashMap<>(freshCookies));
                                cookieCache.put(API_DOMAIN, new HashMap<>(freshCookies));
                                cookieCache.put(M_DOMAIN, new HashMap<>(freshCookies));
                
                                cacheTimestamp.put(PRIMARY_DOMAIN, System.currentTimeMillis());
                                cacheTimestamp.put(API_DOMAIN, System.currentTimeMillis());
                                cacheTimestamp.put(M_DOMAIN, System.currentTimeMillis());
                
                                lastRefreshTime = System.currentTimeMillis();
                
                                logger.info("✅ Получены свежие cookies, {} элементов", freshCookies.size());
                                return freshCookies;
                            } else {
                                logger.warn("⚠️ Валидация свежих cookies не пройдена, используем кэшированные");
                                if (!configCookies.isEmpty()) {
                                    return configCookies;
                                }
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка получения свежих cookies: {}", e.getMessage());
                            if (!configCookies.isEmpty()) {
                                logger.info("🍪 Используем cookies из конфига");
                                return configCookies;
                            }
                        }
                
                        logger.warn("⚠️ Не удалось получить cookies, возвращаем пустые");
                        return new HashMap<>();
                    }
                
                    /**
                     * Принудительное обновление cookies
                     */
                    public static boolean refreshCookies(String domain) {
                        logger.info("🔄 Принудительное обновление cookies для: {}", domain);
                
                        try {
                            Map<String, String> freshCookies = SeleniumCookieFetcher.getFreshCookies();
                
                            if (SeleniumCookieFetcher.validateCookies(freshCookies)) {
                                updateCookieConfigForAllDomains(freshCookies);
                
                                // Обновляем кэш
                                cookieCache.put(PRIMARY_DOMAIN, new HashMap<>(freshCookies));
                                cookieCache.put(API_DOMAIN, new HashMap<>(freshCookies));
                                cookieCache.put(M_DOMAIN, new HashMap<>(freshCookies));
                
                                cacheTimestamp.put(PRIMARY_DOMAIN, System.currentTimeMillis());
                                cacheTimestamp.put(API_DOMAIN, System.currentTimeMillis());
                                cacheTimestamp.put(M_DOMAIN, System.currentTimeMillis());
                
                                lastRefreshTime = System.currentTimeMillis();
                
                                logger.info("✅ Cookies успешно обновлены, {} элементов", freshCookies.size());
                                return true;
                            } else {
                                logger.error("❌ Валидация cookies не пройдена");
                                return false;
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка обновления cookies: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Обновление cookies через GUI (для отладки)
                     */
                    public static boolean refreshCookiesWithGUI(String domain) {
                        logger.info("🔄 Обновление cookies через GUI для: {}", domain);
                
                        try {
                            Map<String, String> freshCookies = SeleniumCookieFetcher.getFreshCookiesWithGUI();
                
                            if (SeleniumCookieFetcher.validateCookies(freshCookies)) {
                                updateCookieConfigForAllDomains(freshCookies);
                                lastRefreshTime = System.currentTimeMillis();
                                logger.info("✅ Cookies обновлены через GUI");
                                return true;
                            } else {
                                logger.error("❌ Валидация не пройдена");
                                return false;
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка обновления cookies через GUI: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Получение строки cookies для HTTP заголовка
                     */
                    public static String getCookieHeader(String domain) {
                        Map<String, String> cookies = getFreshCookies(domain);
                        return cookiesToHeaderString(cookies);
                    }
                
                    /**
                     * Очистка кэша
                     */
                    public static void clearCache() {
                        cookieCache.clear();
                        cacheTimestamp.clear();
                        lastRefreshTime = 0;
                        logger.info("🧹 Кэш cookies очищен");
                    }
                
                    /**
                     * Получение статистики
                     */
                    public static Map<String, Object> getCacheStats() {
                        Map<String, Object> stats = new HashMap<>();
                        stats.put("lastRefreshTime", new Date(lastRefreshTime));
                        stats.put("refreshIntervalMinutes", REFRESH_INTERVAL / 60000);
                        stats.put("cacheTTLMinutes", CACHE_TTL / 60000);
                        stats.put("cachedDomains", cookieCache.size());
                        stats.put("dynamicCookiesEnabled", Config.isDynamicCookiesEnabled());
                
                        List<String> cachedDomains = new ArrayList<>();
                        for (Map.Entry<String, Long> entry : cacheTimestamp.entrySet()) {
                            long age = System.currentTimeMillis() - entry.getValue();
                            cachedDomains.add(String.format("%s (возраст: %d мин)",
                                    entry.getKey(), age / (60 * 1000)));
                        }
                        stats.put("cachedDomainsInfo", cachedDomains);
                
                        return stats;
                    }
                
                    /**
                     * Тестирование cookies
                     */
                    public static boolean testCookies() {
                        int maxRetries = 3;
                
                        for (int attempt = 1; attempt <= maxRetries; attempt++) {
                            try {
                                logger.info("🧪 Тестирование cookies (попытка {}/{})...", attempt, maxRetries);
                
                                String cookieHeader = getCookieHeader(PRIMARY_DOMAIN);
                
                                if (cookieHeader == null || cookieHeader.isEmpty()) {
                                    logger.error("❌ Cookies пусты");
                
                                    if (attempt < maxRetries) {
                                        logger.info("🔄 Попытка обновления cookies...");
                                        refreshCookies(PRIMARY_DOMAIN);
                                        Thread.sleep(5000);
                                        continue;
                                    }
                                    return false;
                                }
                
                                logger.info("✅ Cookies доступны, длина: {} символов", cookieHeader.length());
                
                                Map<String, String> cookies = getFreshCookies(PRIMARY_DOMAIN);
                                logger.info("📊 Ключевые cookies:");
                
                                // Проверяем ключевые cookies
                                String[] keyNames = {"_m_h5_tk", "_tb_token_", "cna", "cookie2", "t"};
                                int validCount = 0;
                
                                for (String key : keyNames) {
                                    if (cookies.containsKey(key)) {
                                        String value = cookies.get(key);
                                        logger.info("   ✅ {}: {}", key,
                                                value.length() > 30 ? value.substring(0, 27) + "..." : value);
                                        validCount++;
                                    } else {
                                        logger.warn("   ❌ Отсутствует: {}", key);
                                    }
                                }
                
                                // Проверяем _m_h5_tk
                                if (cookies.containsKey("_m_h5_tk")) {
                                    String mh5tk = cookies.get("_m_h5_tk");
                                    if (mh5tk.contains("_")) {
                                        String[] parts = mh5tk.split("_", 2);
                                        logger.info("📊 Анализ _m_h5_tk:");
                                        logger.info("   Токен: {}",
                                                parts[0].length() > 20 ? parts[0].substring(0, 17) + "..." : parts[0]);
                                        logger.info("   Время: {}", parts[1]);
                                    }
                                }
                
                                // 🔴 МЕНЬШЕ СТРОГАЯ ПРОВЕРКА: достаточно 3 из 5 ключевых cookies
                                boolean isValid = validCount >= 3;
                                logger.info("📊 Итог тестирования: {} (найдено {}/{} ключевых cookies)",
                                        isValid ? "✅ УСПЕХ" : "❌ ОШИБКА", validCount, keyNames.length);
                
                                if (isValid) {
                                    return true;
                                }
                
                                if (attempt < maxRetries) {
                                    logger.info("🔄 Попытка получения новых cookies...");
                                    refreshCookies(PRIMARY_DOMAIN);
                                    Thread.sleep(5000);
                                }
                
                            } catch (Exception e) {
                                logger.error("❌ Ошибка тестирования cookies (попытка {}): {}", attempt, e.getMessage());
                
                                if (attempt < maxRetries) {
                                    try {
                                        Thread.sleep(5000);
                                    } catch (InterruptedException ie) {
                                        Thread.currentThread().interrupt();
                                        break;
                                    }
                                }
                            }
                        }
                
                        return false;
                    }
                
                    /**
                     * Завершение работы сервиса
                     */
                    public static void shutdown() {
                        if (scheduler != null) {
                            scheduler.shutdown();
                            try {
                                if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                                    scheduler.shutdownNow();
                                }
                            } catch (InterruptedException e) {
                                scheduler.shutdownNow();
                                Thread.currentThread().interrupt();
                            }
                            logger.info("🛑 CookieService остановлен");
                        }
                    }
                
                    /**
                     * Обновление конфигурации для всех доменов Goofish
                     */
                    private static void updateCookieConfigForAllDomains(Map<String, String> cookies) {
                        String cookieString = cookiesToHeaderString(cookies);
                
                        // Обновляем для всех доменов
                        CookieConfig.setCookiesForDomain(PRIMARY_DOMAIN, cookieString);
                        CookieConfig.setCookiesForDomain(API_DOMAIN, cookieString);
                        CookieConfig.setCookiesForDomain(M_DOMAIN, cookieString);
                
                        saveCookiesToProperties(cookies);
                        logger.debug("Обновлены cookies для всех доменов Goofish");
                    }
                
                    /**
                     * Сохранение cookies в файл properties
                     */
                    private static void saveCookiesToProperties(Map<String, String> cookies) {
                        try {
                            Properties props = new Properties();
                
                            String cookieString = cookiesToHeaderString(cookies);
                
                            // Сохраняем для всех доменов
                            props.setProperty("www.goofish.com.cookies", cookieString);
                            props.setProperty("h5api.m.goofish.com.cookies", cookieString);
                            props.setProperty("m.goofish.com.cookies", cookieString);
                
                            try (FileOutputStream fos = new FileOutputStream("cookies.properties")) {
                                props.store(fos, "Cookies for HTTP requests\nAuto-generated file");
                                logger.info("💾 Cookies сохранены в: cookies.properties");
                            }
                
                        } catch (Exception e) {
                            logger.error("❌ Ошибка сохранения cookies: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение cookies из конфига
                     */
                    private static Map<String, String> getCookiesFromConfig(String domain) {
                        // Пробуем основной домен, если не найдены
                        String cookieString = CookieConfig.getCookiesForDomain(domain);
                        if (cookieString == null || cookieString.isEmpty()) {
                            cookieString = CookieConfig.getCookiesForDomain(PRIMARY_DOMAIN);
                        }
                
                        Map<String, String> cookies = new HashMap<>();
                
                        if (cookieString != null && !cookieString.trim().isEmpty()) {
                            String[] cookiePairs = cookieString.split("; ");
                            for (String pair : cookiePairs) {
                                String[] parts = pair.split("=", 2);
                                if (parts.length == 2) {
                                    cookies.put(parts[0].trim(), parts[1].trim());
                                }
                            }
                        }
                
                        return cookies;
                    }
                
                    /**
                     * Преобразование Map cookies в строку для заголовка
                     */
                    private static String cookiesToHeaderString(Map<String, String> cookies) {
                        if (cookies == null || cookies.isEmpty()) {
                            return "";
                        }
                
                        StringBuilder header = new StringBuilder();
                        for (Map.Entry<String, String> entry : cookies.entrySet()) {
                            if (header.length() > 0) {
                                header.append("; ");
                            }
                            header.append(entry.getKey()).append("=").append(entry.getValue());
                        }
                        return header.toString();
                    }
                
                    /**
                     * Получение конкретного cookie
                     */
                    public static String getCookie(String domain, String cookieName) {
                        Map<String, String> cookies = getFreshCookies(domain);
                        return cookies.getOrDefault(cookieName, "");
                    }
                
                    /**
                     * Проверка, доступны ли cookies
                     */
                    public static boolean hasValidCookies() {
                        try {
                            String cookieHeader = getCookieHeader(PRIMARY_DOMAIN);
                            return cookieHeader != null && !cookieHeader.isEmpty();
                        } catch (Exception e) {
                            return false;
                        }
                    }
                }
                ----------------------------------------

              [FILE] RealTimeCookieService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/RealTimeCookieService.java
                Размер: 6976 байт
                Дата изменения: 2026-01-19T22:42:45.81948993Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import com.parser.config.Config;
                import com.parser.config.CookieConfig;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.io.FileOutputStream;
                import java.util.*;
                import java.util.concurrent.ConcurrentHashMap;
                
                /**
                 * Сервис для управления cookies в реальном времени
                 */
                public class RealTimeCookieService {
                    private static final Logger logger = LoggerFactory.getLogger(RealTimeCookieService.class);
                
                    private static final Map<String, String> currentCookies = new ConcurrentHashMap<>();
                    private static long lastUpdateTime = 0;
                    private static final long UPDATE_INTERVAL = 60 * 60 * 1000; // 1 час
                
                    // Основные домены
                    private static final String[] GOOFISH_DOMAINS = {
                            "www.goofish.com",
                            "h5api.m.goofish.com",
                            "m.goofish.com"
                    };
                
                    /**
                     * Инициализация cookies
                     */
                    public static synchronized void initialize() {
                        if (currentCookies.isEmpty() || isExpired()) {
                            refreshCookies();
                        }
                    }
                
                    /**
                     * Проверка истечения срока cookies
                     */
                    private static boolean isExpired() {
                        long now = System.currentTimeMillis();
                        return (now - lastUpdateTime) > UPDATE_INTERVAL;
                    }
                
                    /**
                     * Обновление cookies
                     */
                    public static synchronized boolean refreshCookies() {
                        logger.info("🔄 Обновление cookies через Selenium...");
                
                        try {
                            Map<String, String> freshCookies = SeleniumCookieFetcher.getFreshCookies();
                
                            if (SeleniumCookieFetcher.validateCookies(freshCookies)) {
                                currentCookies.clear();
                                currentCookies.putAll(freshCookies);
                                lastUpdateTime = System.currentTimeMillis();
                
                                // Сохраняем в конфиг
                                updateAllDomains();
                
                                // Сохраняем в файл для отладки
                                saveToJsonFile();
                
                                logger.info("✅ Cookies успешно обновлены");
                                return true;
                            } else {
                                logger.error("❌ Валидация cookies не пройдена");
                                return false;
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка обновления cookies: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Обновление конфигурации для всех доменов
                     */
                    private static void updateAllDomains() {
                        String cookieString = mapToString(currentCookies);
                
                        for (String domain : GOOFISH_DOMAINS) {
                            CookieConfig.setCookiesForDomain(domain, cookieString);
                            logger.debug("Обновлены cookies для домена: {}", domain);
                        }
                
                        // Также сохраняем в cookies.properties
                        saveToPropertiesFile();
                    }
                
                    /**
                     * Получение строки cookies для заголовка
                     */
                    public static String getCookieHeader(String domain) {
                        if (currentCookies.isEmpty() || isExpired()) {
                            refreshCookies();
                        }
                        return mapToString(currentCookies);
                    }
                
                    /**
                     * Получение конкретного cookie
                     */
                    public static String getCookie(String name) {
                        if (currentCookies.isEmpty() || isExpired()) {
                            refreshCookies();
                        }
                        return currentCookies.getOrDefault(name, "");
                    }
                
                    /**
                     * Преобразование Map в строку cookies
                     */
                    private static String mapToString(Map<String, String> cookies) {
                        if (cookies == null || cookies.isEmpty()) {
                            return "";
                        }
                
                        StringBuilder sb = new StringBuilder();
                        for (Map.Entry<String, String> entry : cookies.entrySet()) {
                            if (sb.length() > 0) {
                                sb.append("; ");
                            }
                            sb.append(entry.getKey()).append("=").append(entry.getValue());
                        }
                
                        return sb.toString();
                    }
                
                    /**
                     * Сохранение cookies в properties файл
                     */
                    private static void saveToPropertiesFile() {
                        try {
                            Properties props = new Properties();
                
                            String cookieString = mapToString(currentCookies);
                
                            // Сохраняем для всех доменов
                            for (String domain : GOOFISH_DOMAINS) {
                                props.setProperty(domain + ".cookies", cookieString);
                            }
                
                            try (FileOutputStream fos = new FileOutputStream("cookies.properties")) {
                                props.store(fos, "Auto-generated cookies for Goofish\n" + new Date());
                                logger.info("💾 Cookies сохранены в cookies.properties");
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка сохранения cookies: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Сохранение cookies в JSON файл
                     */
                    private static void saveToJsonFile() {
                        try {
                            Map<String, Object> data = new HashMap<>();
                            data.put("last_updated", new Date().toString());
                            data.put("source", "real_fetch");
                            data.put("cookies", currentCookies);
                            data.put("timestamp", System.currentTimeMillis());
                
                            String json = new com.fasterxml.jackson.databind.ObjectMapper()
                                    .writerWithDefaultPrettyPrinter()
                                    .writeValueAsString(data);
                
                            try (java.io.FileWriter fw = new java.io.FileWriter("real_cookies.json")) {
                                fw.write(json);
                                logger.info("💾 Cookies сохранены в real_cookies.json");
                            }
                        } catch (Exception e) {
                            logger.error("❌ Ошибка сохранения JSON cookies: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение информации о cookies
                     */
                    public static Map<String, Object> getCookieInfo() {
                        Map<String, Object> info = new HashMap<>();
                        info.put("last_update", new Date(lastUpdateTime));
                        info.put("cookie_count", currentCookies.size());
                        info.put("key_cookies", getKeyCookiesInfo());
                        info.put("domains", Arrays.asList(GOOFISH_DOMAINS));
                
                        return info;
                    }
                
                    /**
                     * Получение информации о ключевых cookies
                     */
                    private static Map<String, String> getKeyCookiesInfo() {
                        Map<String, String> keyCookies = new HashMap<>();
                
                        String[] keys = {"_m_h5_tk", "_tb_token_", "cna", "cookie2", "t"};
                        for (String key : keys) {
                            if (currentCookies.containsKey(key)) {
                                String value = currentCookies.get(key);
                                keyCookies.put(key, value.length() > 50 ? value.substring(0, 47) + "..." : value);
                            }
                        }
                
                        return keyCookies;
                    }
                }
                ----------------------------------------

              [FILE] SeleniumCookieFetcher.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/SeleniumCookieFetcher.java
                Размер: 20468 байт
                Дата изменения: 2026-02-02T19:23:46.240791077Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import io.github.bonigarcia.wdm.WebDriverManager;
                import org.openqa.selenium.*;
                import org.openqa.selenium.chrome.ChromeDriver;
                import org.openqa.selenium.chrome.ChromeOptions;
                import org.openqa.selenium.support.ui.ExpectedConditions;
                import org.openqa.selenium.support.ui.WebDriverWait;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.time.Duration;
                import java.util.*;
                import java.util.concurrent.TimeUnit;
                
                /**
                 * Сервис для получения cookies через Selenium - ИСПРАВЛЕННЫЙ ДЛЯ HEADLESS
                 */
                public class SeleniumCookieFetcher {
                    private static final Logger logger = LoggerFactory.getLogger(SeleniumCookieFetcher.class);
                
                    /**
                     * Основной метод получения cookies для Goofish - ИСПРАВЛЕННЫЙ ДЛЯ HEADLESS
                     */
                    public static Map<String, String> fetchGoofishCookies(boolean headless) {
                        logger.info("🔄 Запуск Selenium для получения cookies Goofish");
                        System.out.println("=".repeat(60));
                        System.out.println("🔄 АВТОМАТИЧЕСКОЕ ПОЛУЧЕНИЕ COOKIES GOOFISH");
                        System.out.println("=".repeat(60));
                
                        WebDriver driver = null;
                        try {
                            // 1. Настройка WebDriver
                            WebDriverManager.chromedriver().setup();
                            logger.info("✅ ChromeDriver настроен");
                
                            // 2. Конфигурация Chrome - ОПТИМИЗИРОВАННАЯ ДЛЯ HEADLESS
                            ChromeOptions options = new ChromeOptions();
                
                            // 🔴 ОСНОВНОЕ ИСПРАВЛЕНИЕ: Настройки для обхода детекции headless
                            if (headless) {
                                // Современный headless режим с обходом детекции
                                options.addArguments("--headless=new"); // Новый headless режим Chrome
                                options.addArguments("--no-sandbox");
                                options.addArguments("--disable-dev-shm-usage");
                                options.addArguments("--disable-gpu");
                                options.addArguments("--window-size=1920,1080");
                                options.addArguments("--start-maximized");
                                logger.info("🌐 Режим: Headless (оптимизированный)");
                            } else {
                                logger.info("🌐 Режим: С GUI");
                            }
                
                            // 🔴 КЛЮЧЕВЫЕ АРГУМЕНТЫ ДЛЯ ОБХОДА ДЕТЕКЦИИ
                            options.addArguments("--disable-blink-features=AutomationControlled");
                            options.addArguments("--disable-features=VizDisplayCompositor");
                            options.addArguments("--disable-software-rasterizer");
                            options.addArguments("--disable-extensions");
                            options.addArguments("--disable-logging");
                            options.addArguments("--log-level=3");
                            options.addArguments("--disable-web-security");
                            options.addArguments("--allow-running-insecure-content");
                            options.addArguments("--ignore-certificate-errors");
                            options.addArguments("--disable-popup-blocking");
                            options.addArguments("--disable-notifications");
                            options.addArguments("--disable-save-password-bubble");
                            options.addArguments("--disable-translate");
                            options.addArguments("--disable-background-timer-throttling");
                            options.addArguments("--disable-renderer-backgrounding");
                            options.addArguments("--disable-backgrounding-occluded-windows");
                
                            // 🔴 USER-AGENT ДЛЯ ОБХОДА ДЕТЕКЦИИ
                            String userAgent = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36";
                            options.addArguments("--user-agent=" + userAgent);
                
                            // 🔴 ЭКСПЕРИМЕНТАЛЬНЫЕ ОПЦИИ ДЛЯ ОБХОДА ДЕТЕКЦИИ
                            options.setExperimentalOption("excludeSwitches", Arrays.asList(
                                    "enable-automation",
                                    "enable-logging"
                            ));
                            options.setExperimentalOption("useAutomationExtension", false);
                
                            Map<String, Object> prefs = new HashMap<>();
                            prefs.put("credentials_enable_service", false);
                            prefs.put("profile.password_manager_enabled", false);
                            prefs.put("profile.default_content_setting_values.notifications", 2); // Блокировать уведомления
                            prefs.put("profile.default_content_setting_values.popups", 2); // Блокировать popups
                            options.setExperimentalOption("prefs", prefs);
                
                            // 3. Запуск браузера с увеличенными таймаутами
                            driver = new ChromeDriver(options);
                
                            // 🔴 УВЕЛИЧИВАЕМ ТАЙМАУТЫ ДЛЯ МЕДЛЕННЫХ СЕТЕЙ
                            driver.manage().timeouts().pageLoadTimeout(Duration.ofSeconds(60)); // 60 секунд вместо 30
                            driver.manage().timeouts().implicitlyWait(Duration.ofSeconds(30)); // 30 секунд вместо 15
                            driver.manage().timeouts().scriptTimeout(Duration.ofSeconds(30));
                
                            logger.info("✅ Браузер запущен с увеличенными таймаутами");
                
                            // 🔴 4. ПЕРВОНАЧАЛЬНЫЙ ПЕРЕХОД НА GOOGLE (для инициализации cookies)
                            try {
                                logger.info("🌐 Первоначальный переход на Google для инициализации...");
                                driver.get("https://www.google.com");
                                Thread.sleep(2000);
                            } catch (Exception e) {
                                logger.warn("⚠️ Не удалось загрузить Google: {}", e.getMessage());
                            }
                
                            // 🔴 5. ПЕРЕХОД НА GOOFISH С РЕТРАЯМИ ПРИ ТАЙМАУТЕ
                            String url = "https://www.goofish.com";
                            logger.info("🌐 Переход на: {}", url);
                
                            int maxRetries = 3;
                            boolean pageLoaded = false;
                
                            for (int retry = 1; retry <= maxRetries; retry++) {
                                try {
                                    driver.get(url);
                
                                    // 🔴 ЖДЕМ ЗАГРУЗКИ СТРАНИЦЫ С ПОМОЩЬЮ JAVASCRIPT
                                    new WebDriverWait(driver, Duration.ofSeconds(30)).until(
                                            webDriver -> ((JavascriptExecutor) webDriver)
                                                    .executeScript("return document.readyState").equals("complete")
                                    );
                
                                    logger.info("✅ Страница успешно загружена (попытка {})", retry);
                                    pageLoaded = true;
                                    break;
                
                                } catch (TimeoutException e) {
                                    logger.warn("⚠️ Таймаут при загрузке страницы (попытка {}), пробуем снова...", retry);
                
                                    if (retry < maxRetries) {
                                        Thread.sleep(3000);
                
                                        // Пробуем альтернативный URL
                                        if (retry == 2) {
                                            url = "https://m.goofish.com";
                                            logger.info("🔄 Пробуем мобильную версию: {}", url);
                                        }
                                    }
                                }
                            }
                
                            if (!pageLoaded) {
                                throw new TimeoutException("Не удалось загрузить страницу после " + maxRetries + " попыток");
                            }
                
                            // 🔴 6. ДОБАВЛЯЕМ ДОПОЛНИТЕЛЬНУЮ ЗАДЕРЖКУ И ВЗАИМОДЕЙСТВИЕ
                            logger.info("⏳ Ожидание генерации cookies (10 секунд)...");
                            Thread.sleep(10000);
                
                            // 🔴 7. ВЫПОЛНЯЕМ JAVASCRIPT ДЛЯ ИНИЦИАЛИЗАЦИИ СТРАНИЦЫ
                            try {
                                JavascriptExecutor js = (JavascriptExecutor) driver;
                
                                // Прокручиваем страницу для инициализации
                                js.executeScript("window.scrollTo(0, document.body.scrollHeight * 0.3);");
                                Thread.sleep(2000);
                                js.executeScript("window.scrollTo(0, document.body.scrollHeight * 0.6);");
                                Thread.sleep(2000);
                
                                // Кликаем на body для активации
                                WebElement body = driver.findElement(By.tagName("body"));
                                body.click();
                                Thread.sleep(1000);
                
                            } catch (Exception e) {
                                logger.debug("Не удалось взаимодействовать со страницей: {}", e.getMessage());
                            }
                
                            // 🔴 8. ПОЛУЧАЕМ COOKIES С ГЛАВНОЙ СТРАНИЦЫ
                            logger.info("🍪 Получение cookies с главной страницы...");
                            Set<Cookie> allCookies = driver.manage().getCookies();
                            logger.info("📦 Найдено cookies на главной: {}", allCookies.size());
                
                            // 🔴 9. ПЕРЕХОД НА СТРАНИЦУ ПОИСКА ДЛЯ ДОПОЛНИТЕЛЬНЫХ COOKIES
                            String searchUrl = "https://www.goofish.com/search?q=test";
                            logger.info("🔍 Переход на страницу поиска: {}", searchUrl);
                
                            try {
                                driver.get(searchUrl);
                                Thread.sleep(5000);
                
                                // Ждем загрузки
                                new WebDriverWait(driver, Duration.ofSeconds(30)).until(
                                        webDriver -> ((JavascriptExecutor) webDriver)
                                                .executeScript("return document.readyState").equals("complete")
                                );
                
                            } catch (Exception e) {
                                logger.warn("⚠️ Не удалось загрузить страницу поиска: {}", e.getMessage());
                            }
                
                            // 🔴 10. ПОЛУЧАЕМ ВСЕ COOKIES
                            logger.info("🍪 Получение всех cookies после взаимодействия...");
                            allCookies = driver.manage().getCookies();
                
                            // 🔴 11. СОБИРАЕМ И ФИЛЬТРУЕМ COOKIES
                            Map<String, String> goofishCookies = new LinkedHashMap<>();
                
                            // Ключевые cookies для Goofish
                            String[] importantKeys = {
                                    "_m_h5_tk", "_m_h5_tk_enc", "_samesite_flag_", "_tb_token_",
                                    "cna", "cookie2", "mtop_partitioned_detect", "t",
                                    "tfstk", "xlly_s", "x5secdata", "isg", "unb", "lgc"
                            };
                
                            for (Cookie cookie : allCookies) {
                                String name = cookie.getName();
                                String value = cookie.getValue();
                                goofishCookies.put(name, value);
                
                                // Логируем важные cookies
                                if (Arrays.asList(importantKeys).contains(name)) {
                                    logger.debug("✅ Важный cookie: {} = {}", name,
                                            value.length() > 50 ? value.substring(0, 47) + "..." : value);
                                }
                            }
                
                            // 🔴 12. ДОПОЛНИТЕЛЬНАЯ ПРОВЕРКА ДЛЯ CNA
                            if (!goofishCookies.containsKey("cna")) {
                                logger.warn("⚠️ Cookie 'cna' не найден, пробуем альтернативный метод...");
                
                                try {
                                    // Пробуем получить cna через JavaScript
                                    JavascriptExecutor js = (JavascriptExecutor) driver;
                                    Object cnaValue = js.executeScript(
                                            "return document.cookie.split('; ').find(c => c.startsWith('cna='));"
                                    );
                
                                    if (cnaValue != null) {
                                        String cnaStr = cnaValue.toString();
                                        if (cnaStr.startsWith("cna=")) {
                                            String cna = cnaStr.substring(4);
                                            goofishCookies.put("cna", cna);
                                            logger.info("✅ Получен cna через JavaScript: {}",
                                                    cna.length() > 30 ? cna.substring(0, 27) + "..." : cna);
                                        }
                                    }
                                } catch (Exception e) {
                                    logger.warn("⚠️ Не удалось получить cna через JavaScript: {}", e.getMessage());
                                }
                            }
                
                            // Вывод результатов
                            logger.info("📊 Результаты получения cookies:");
                            logger.info("📦 Всего cookies: {}", allCookies.size());
                            logger.info("🔑 Важных cookies: {}", goofishCookies.size());
                
                            if (!goofishCookies.isEmpty()) {
                                logger.info("🎯 Ключевые cookies:");
                                for (String key : importantKeys) {
                                    if (goofishCookies.containsKey(key)) {
                                        String val = goofishCookies.get(key);
                                        logger.info("   {}: {}",
                                                String.format("%-25s", key),
                                                val.length() > 50 ? val.substring(0, 47) + "..." : val);
                                    }
                                }
                            }
                
                            return goofishCookies;
                
                        } catch (Exception e) {
                            logger.error("❌ Ошибка при получении cookies через Selenium: {}", e.getMessage());
                
                            // 🔴 ВОЗВРАЩАЕМ КЭШИРОВАННЫЕ COOKIES ПРИ ОШИБКЕ
                            logger.info("🔄 Возвращаем кэшированные cookies...");
                            return getCachedCookies();
                
                        } finally {
                            // Закрытие браузера
                            if (driver != null) {
                                try {
                                    driver.quit();
                                    logger.info("✅ Браузер закрыт");
                                } catch (Exception e) {
                                    logger.error("⚠️ Ошибка при закрытии браузера: {}", e.getMessage());
                                }
                            }
                        }
                    }
                
                    /**
                     * Получение свежих cookies (публичный метод) с использованием headless
                     */
                    public static Map<String, String> getFreshCookies() {
                        return fetchGoofishCookies(true); // 🔴 ИСПОЛЬЗУЕМ HEADLESS ДЛЯ ПРОДАКШЕНА
                    }
                
                    /**
                     * Получение cookies с GUI для отладки
                     */
                    public static Map<String, String> getFreshCookiesWithGUI() {
                        return fetchGoofishCookies(false);
                    }
                
                    /**
                     * Возвращает кэшированные cookies при ошибке
                     */
                    private static Map<String, String> getCachedCookies() {
                        try {
                            // Пробуем прочитать cookies из файла
                            java.util.Properties props = new java.util.Properties();
                            try (java.io.FileInputStream fis = new java.io.FileInputStream("cookies.properties")) {
                                props.load(fis);
                
                                String cookieStr = props.getProperty("www.goofish.com.cookies", "");
                                if (!cookieStr.isEmpty()) {
                                    Map<String, String> cookies = new HashMap<>();
                                    String[] pairs = cookieStr.split("; ");
                                    for (String pair : pairs) {
                                        String[] parts = pair.split("=", 2);
                                        if (parts.length == 2) {
                                            cookies.put(parts[0].trim(), parts[1].trim());
                                        }
                                    }
                
                                    if (!cookies.isEmpty()) {
                                        logger.info("✅ Используем кэшированные cookies из файла");
                                        return cookies;
                                    }
                                }
                            }
                        } catch (Exception e) {
                            logger.warn("⚠️ Не удалось загрузить кэшированные cookies: {}", e.getMessage());
                        }
                
                        return Collections.emptyMap();
                    }
                
                    /**
                     * Валидация полученных cookies - ОПТИМИЗИРОВАННАЯ
                     */
                    public static boolean validateCookies(Map<String, String> cookies) {
                        if (cookies == null || cookies.isEmpty()) {
                            logger.error("❌ Cookies пусты или null");
                            return false;
                        }
                
                        // 🔴 МЕНЬШЕ СТРОГАЯ ВАЛИДАЦИЯ ДЛЯ HEADLESS
                        String[] requiredKeys = {"_m_h5_tk", "cna", "t"};
                        int foundCount = 0;
                
                        for (String key : requiredKeys) {
                            if (cookies.containsKey(key)) {
                                foundCount++;
                                String value = cookies.get(key);
                                logger.debug("✅ Найден {}: {}", key,
                                        value.length() > 30 ? value.substring(0, 27) + "..." : value);
                            } else {
                                logger.warn("⚠️ Отсутствует ключевой cookie: {}", key);
                            }
                        }
                
                        // 🔴 ГЕНЕРИРУЕМ ОТСУТСТВУЮЩИЕ COOKIES
                        if (!cookies.containsKey("cna")) {
                            logger.warn("⚠️ Cookie 'cna' отсутствует, генерируем временный...");
                            String fakeCna = generateFakeCna();
                            cookies.put("cna", fakeCna);
                            foundCount++;
                            logger.info("✅ Сгенерирован временный cna: {}", fakeCna);
                        }
                
                        if (!cookies.containsKey("_tb_token_")) {
                            logger.warn("⚠️ Cookie '_tb_token_' отсутствует, генерируем временный...");
                            cookies.put("_tb_token_", generateRandomToken());
                            logger.info("✅ Сгенерирован временный _tb_token_");
                        }
                
                        // Проверяем _m_h5_tk
                        if (cookies.containsKey("_m_h5_tk")) {
                            String mh5tk = cookies.get("_m_h5_tk");
                            if (mh5tk.contains("_")) {
                                String[] parts = mh5tk.split("_", 2);
                                logger.info("📊 Анализ _m_h5_tk:");
                                logger.info("   Токен: {}",
                                        parts[0].length() > 20 ? parts[0].substring(0, 17) + "..." : parts[0]);
                                logger.info("   Время: {}", parts[1]);
                
                                try {
                                    long tokenTime = Long.parseLong(parts[1]);
                                    long currentTime = System.currentTimeMillis();
                                    long age = currentTime - tokenTime;
                
                                    if (age > 24 * 60 * 60 * 1000) { // 24 часа
                                        logger.warn("⚠️ Token _m_h5_tk устарел (возраст: {} часов)", age / (60 * 60 * 1000));
                                    }
                                } catch (NumberFormatException e) {
                                    logger.warn("⚠️ Неверный формат времени в _m_h5_tk");
                                }
                            } else {
                                logger.warn("⚠️ _m_h5_tk не содержит timestamp");
                            }
                        }
                
                        // 🔴 МЕНЬШЕ СТРОГАЯ ВАЛИДАЦИЯ: достаточно 2 из 3 ключевых cookies
                        boolean isValid = foundCount >= 2;
                        logger.info("📊 Валидация cookies: {} (найдено {}/{} ключевых)",
                                isValid ? "✅ УСПЕХ" : "❌ ОШИБКА", foundCount, requiredKeys.length);
                
                        return isValid;
                    }
                
                    /**
                     * Генерация временного cna cookie
                     */
                    private static String generateFakeCna() {
                        String chars = "abcdefghijklmnopqrstuvwxyz0123456789";
                        Random random = new Random();
                        StringBuilder cna = new StringBuilder();
                        for (int i = 0; i < 16; i++) {
                            cna.append(chars.charAt(random.nextInt(chars.length())));
                        }
                        return cna.toString();
                    }
                
                    /**
                     * Генерация случайного токена
                     */
                    private static String generateRandomToken() {
                        String chars = "abcdefghijklmnopqrstuvwxyz0123456789";
                        Random random = new Random();
                        StringBuilder token = new StringBuilder();
                        for (int i = 0; i < 13; i++) {
                            token.append(chars.charAt(random.nextInt(chars.length())));
                        }
                        return token.toString();
                    }
                }
                ----------------------------------------

              [FILE] AutoCleanupService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/AutoCleanupService.java
                Размер: 3452 байт
                Дата изменения: 2026-02-02T18:59:36.569379479Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import com.parser.config.Config;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.File;
                import java.nio.file.*;
                import java.util.concurrent.Executors;
                import java.util.concurrent.ScheduledExecutorService;
                import java.util.concurrent.TimeUnit;
                
                public class AutoCleanupService {
                    private static final Logger logger = LoggerFactory.getLogger(AutoCleanupService.class);
                    private static ScheduledExecutorService scheduler;
                
                    public static void start() {
                        scheduler = Executors.newScheduledThreadPool(1);
                
                        // Очистка старых логов каждые 24 часа
                        scheduler.scheduleAtFixedRate(() -> {
                            try {
                                cleanupOldLogs();
                                cleanupTempFiles();
                                cleanupOldBackups();
                            } catch (Exception e) {
                                logger.error("Ошибка при очистке файлов: {}", e.getMessage());
                            }
                        }, 1, 24, TimeUnit.HOURS); // Запуск через 1 час, затем каждые 24 часа
                
                        logger.info("Сервис автоочистки запущен");
                    }
                
                    private static void cleanupOldLogs() {
                        String logDir = "logs";
                        File dir = new File(logDir);
                        if (!dir.exists()) return;
                
                        long cutoffTime = System.currentTimeMillis() - (30L * 24 * 60 * 60 * 1000); // 30 дней
                
                        for (File file : dir.listFiles()) {
                            if (file.isFile() && file.lastModified() < cutoffTime) {
                                if (file.delete()) {
                                    logger.debug("Удален старый лог: {}", file.getName());
                                }
                            }
                        }
                    }
                
                    private static void cleanupTempFiles() {
                        // Удаляем старые debug файлы кук
                        File currentDir = new File(".");
                        long cutoffTime = System.currentTimeMillis() - (7L * 24 * 60 * 60 * 1000); // 7 дней
                
                        for (File file : currentDir.listFiles()) {
                            String name = file.getName();
                            if (name.startsWith("cookies_debug_") && name.endsWith(".properties") &&
                                    file.isFile() && file.lastModified() < cutoffTime) {
                                if (file.delete()) {
                                    logger.debug("Удален debug файл кук: {}", name);
                                }
                            }
                        }
                    }
                
                    private static void cleanupOldBackups() {
                        String backupDir = "data/backups";
                        File dir = new File(backupDir);
                        if (!dir.exists()) return;
                
                        long cutoffTime = System.currentTimeMillis() - (14L * 24 * 60 * 60 * 1000); // 14 дней
                
                        for (File file : dir.listFiles()) {
                            if (file.isFile() && file.lastModified() < cutoffTime) {
                                if (file.delete()) {
                                    logger.debug("Удалена старая резервная копия: {}", file.getName());
                                }
                            }
                        }
                    }
                
                    public static void shutdown() {
                        if (scheduler != null) {
                            scheduler.shutdown();
                            try {
                                if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                                    scheduler.shutdownNow();
                                }
                            } catch (InterruptedException e) {
                                scheduler.shutdownNow();
                                Thread.currentThread().interrupt();
                            }
                            logger.info("Сервис автоочистки остановлен");
                        }
                    }
                }
                ----------------------------------------

              [FILE] NotificationService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/NotificationService.java
                Размер: 6359 байт
                Дата изменения: 2026-01-19T09:31:29.773206169Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import com.parser.model.Product;
                import com.parser.telegram.TelegramNotificationService;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.List;
                import java.util.Map;
                
                /**
                 * Сервис для отправки уведомлений различными способами
                 */
                public class NotificationService {
                    private static final Logger logger = LoggerFactory.getLogger(NotificationService.class);
                
                    /**
                     * Отправка уведомления о найденных товарах
                     */
                    public static void sendProductNotification(int userId, List<Product> products, String query) {
                        if (products == null || products.isEmpty()) {
                            logger.debug("No products to notify for user {}", userId);
                            return;
                        }
                
                        logger.info("Sending product notification for user {}, query: {}, products: {}",
                                userId, query, products.size());
                
                        // Отправка через Telegram
                        sendTelegramProductNotification(userId, products, query);
                
                        // Здесь можно добавить другие способы отправки:
                        // - Email
                        // - Webhook
                        // - Discord/Slack
                        // - SMS
                    }
                
                    /**
                     * Отправка уведомления через Telegram
                     */
                    private static void sendTelegramProductNotification(int userId, List<Product> products, String query) {
                        if (products.isEmpty()) {
                            return;
                        }
                
                        try {
                            // Отправляем основное уведомление
                            TelegramNotificationService.sendProductsNotification(userId, products.size(), query);
                
                            // Отправляем детали по товарам (первые 5)
                            StringBuilder message = new StringBuilder();
                            message.append("🛍️ **Детали найденных товаров**\n\n");
                            message.append("Запрос: ").append(query).append("\n\n");
                
                            for (int i = 0; i < Math.min(products.size(), 5); i++) {
                                Product p = products.get(i);
                                message.append(i + 1).append(". ").append(p.getTitle()).append("\n");
                                message.append("   💰 ").append(p.getPriceDisplay()).append("\n");
                                message.append("   📍 ").append(p.getLocation()).append("\n");
                                message.append("   ⏳ ").append(p.getAgeMinutes()).append(" мин\n");
                                message.append("   🔗 ").append(p.getUrl()).append("\n\n");
                            }
                
                            if (products.size() > 5) {
                                message.append("... и еще ").append(products.size() - 5).append(" товаров\n");
                            }
                
                            TelegramNotificationService.sendMessage(userId, message.toString());
                
                            // Отправляем изображения первых 3 товаров
                            for (int i = 0; i < Math.min(products.size(), 3); i++) {
                                Product p = products.get(i);
                                if (p.getImages() != null && !p.getImages().isEmpty()) {
                                    // Используем метод sendPhotoWithCaption вместо sendPhoto
                                    TelegramNotificationService.sendPhotoWithCaption(userId,
                                            p.getImages().get(0),
                                            "📸 " + p.getTitle());
                                }
                            }
                
                        } catch (Exception e) {
                            logger.error("Error sending Telegram notification for user {}: {}",
                                    userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Отправка уведомления об ошибке
                     */
                    public static void sendErrorNotification(int userId, String errorMessage) {
                        logger.error("Sending error notification to user {}: {}", userId, errorMessage);
                
                        // Отправка через Telegram
                        TelegramNotificationService.sendErrorNotification(userId, errorMessage);
                
                        // Здесь можно добавить логирование ошибки в файл или систему мониторинга
                        logErrorToFile(userId, errorMessage);
                    }
                
                    /**
                     * Отправка уведомления о состоянии системы
                     */
                    public static void sendStatusNotification(int userId, String status, String details) {
                        logger.info("Sending status notification to user {}: {}", userId, status);
                
                        TelegramNotificationService.sendStatusNotification(userId, status, details);
                    }
                
                    /**
                     * Отправка административного уведомления
                     */
                    public static void sendAdminNotification(String message) {
                        logger.info("Sending admin notification: {}", message);
                
                        TelegramNotificationService.sendAdminNotification(message);
                    }
                
                    /**
                     * Отправка тестового уведомления
                     */
                    public static boolean sendTestNotification(int userId) {
                        logger.info("Sending test notification to user {}", userId);
                
                        return TelegramNotificationService.sendTestNotification(userId);
                    }
                
                    /**
                     * Логирование ошибки в файл
                     */
                    private static void logErrorToFile(int userId, String errorMessage) {
                        // В реальном проекте здесь будет запись в лог-файл
                        String logEntry = String.format("[%s] User %d: %s",
                                new java.util.Date(), userId, errorMessage);
                
                        // Пример записи в лог
                        logger.error("User error: {}", logEntry);
                    }
                
                    /**
                     * Проверка доступности служб уведомлений
                     */
                    public static Map<String, Boolean> checkNotificationServices() {
                        Map<String, Boolean> status = new java.util.HashMap<>();
                
                        status.put("telegram", TelegramNotificationService.isBotAvailable());
                        // Здесь можно добавить проверку других сервисов
                
                        return status;
                    }
                
                    /**
                     * Получение статистики уведомлений
                     */
                    public static String getNotificationStats() {
                        // В реальном проекте здесь можно вести статистику отправленных уведомлений
                        return "Notification service is operational";
                    }
                }
                ----------------------------------------

            [FILE] ProjectStructureExporter.java
              Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/ProjectStructureExporter.java
              Размер: 5639 байт
              Дата изменения: 2026-01-18T19:50:03.384565602Z
              Содержимое:
              ----------------------------------------
              package com.parser;
              
              import java.io.*;
              import java.nio.file.*;
              import java.nio.file.attribute.BasicFileAttributes;
              
              public class ProjectStructureExporter {
                  private static final String OUTPUT_FILE = "project_structure.txt";
                  private static final String[] IGNORED_DIRS = {".git", ".idea", "target", "build", "node_modules", "out", "bin"};
                  private static final int MAX_FILE_SIZE = 1024 * 1024 * 1024; // 1MB - максимальный размер файла для чтения
              
                  public static void main(String[] args) throws IOException {
                      Path currentDir = Paths.get(".").toAbsolutePath().normalize();
                      System.out.println("Сканирую директорию: " + currentDir);
              
                      try (PrintWriter writer = new PrintWriter(new FileWriter(OUTPUT_FILE))) {
                          writer.println("СТРУКТУРА ПРОЕКТА");
                          writer.println("=================");
                          writer.println("Директория: " + currentDir);
                          writer.println("Дата создания отчета: " + java.time.LocalDateTime.now());
                          writer.println("\n" + "=".repeat(80) + "\n");
              
                          Files.walkFileTree(currentDir, new SimpleFileVisitor<Path>() {
                              private int depth = 0;
              
                              @Override
                              public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                                  // Пропускаем игнорируемые директории
                                  for (String ignored : IGNORED_DIRS) {
                                      if (dir.toString().contains(File.separator + ignored)) {
                                          return FileVisitResult.SKIP_SUBTREE;
                                      }
                                  }
              
                                  // Печатаем структуру директорий
                                  String indent = "  ".repeat(depth);
                                  writer.println(indent + "[DIR] " + dir.getFileName());
                                  depth++;
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                                  String indent = "  ".repeat(depth);
                                  String fileName = file.getFileName().toString();
              
                                  // Пропускаем сам файл отчета
                                  if (fileName.equals(OUTPUT_FILE)) {
                                      return FileVisitResult.CONTINUE;
                                  }
              
                                  writer.println("\n" + indent + "[FILE] " + fileName);
                                  writer.println(indent + "  Путь: " + file);
                                  writer.println(indent + "  Размер: " + attrs.size() + " байт");
                                  writer.println(indent + "  Дата изменения: " + attrs.lastModifiedTime());
              
                                  // Читаем содержимое текстовых файлов
                                  if (isTextFile(fileName) && attrs.size() <= MAX_FILE_SIZE) {
                                      writer.println(indent + "  Содержимое:");
                                      writer.println(indent + "  " + "-".repeat(40));
                                      try {
                                          String content = Files.readString(file);
                                          String[] lines = content.split("\n");
                                          for (int i = 0; i < Math.min(lines.length, 10000); i++) { // Ограничиваем 100 строками
                                              writer.println(indent + "  " + lines[i]);
                                          }
                                          if (lines.length > 10000) {
                                              writer.println(indent + "  ... (файл усечен, показано 100 из " + lines.length + " строк)");
                                          }
                                      } catch (IOException e) {
                                          writer.println(indent + "  Невозможно прочитать файл (возможно, бинарный)");
                                      }
                                      writer.println(indent + "  " + "-".repeat(40));
                                  } else {
                                      writer.println(indent + "  [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]");
                                  }
              
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
                                  depth--;
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult visitFileFailed(Path file, IOException exc) {
                                  writer.println("\nОшибка при доступе к файлу: " + file);
                                  return FileVisitResult.CONTINUE;
                              }
                          });
              
                          writer.println("\n" + "=".repeat(80));
                          writer.println("Отчет успешно создан!");
                      }
              
                      System.out.println("Отчет сохранен в файл: " + OUTPUT_FILE);
                  }
              
                  private static boolean isTextFile(String fileName) {
                      String[] textExtensions = {
                              ".java", ".txt", ".xml", ".html", ".htm", ".css", ".js", ".json",
                              ".properties", ".yml", ".yaml", ".md", ".gradle", ".kt", ".py",
                              ".cpp", ".c", ".h", ".hpp", ".sql", ".sh", ".bat", ".cfg", ".ini"
                      };
              
                      String lowerName = fileName.toLowerCase();
                      for (String ext : textExtensions) {
                          if (lowerName.endsWith(ext)) {
                              return true;
                          }
                      }
                      return false;
                  }
              }
              ----------------------------------------

================================================================================
Отчет успешно создан!
