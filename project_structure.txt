СТРУКТУРА ПРОЕКТА
=================
Директория: /Users/yanmore/IdeaProjects/multiParser
Дата создания отчета: 2026-01-19T11:30:02.382076

================================================================================

[DIR] multiParser

  [FILE] cookies_debug_20260119_111051.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_debug_20260119_111051.properties
    Размер: 707 байт
    Дата изменения: 2026-01-19T08:10:51.547108795Z
    Содержимое:
    ----------------------------------------
    #Debug cookies from Selenium
    #Mon Jan 19 11:10:51 MSK 2026
    _m_h5_tk=b12d2a731e6520d120e8161ce5fe04b9_1768819591926
    _m_h5_tk_enc=249a48b09dd379e555bcfb051f1bcd97
    _samesite_flag_=true
    _tb_token_=f9e88355b71e3
    cna=/NT0IfVnoCECAZH5bfmSUNgE
    cookie2=1e0d1a49c3fe5c7836bd5bc4c9285c87
    mtop_partitioned_detect=1
    t=d09c844f0516a76e622a53cf60c5c174
    tfstk=gz1nfMbBrhiblCnai0RQLxvSAiwTdBOWAghJ2QKzQh-62ytpvaSlrZJPvBdKE7bPYL5p9wIGZMIOJksJ90VljhI-wwClCbbfP6UBwyOCRQOzDoFAZw_BNDIjhkqO7z8WZe-n8GC5RQOzDaBi9lQCvGjOqQRzSC8k80RrTQzi_UtZTUlezczMPhRrTXlEQN8p-XlyLg7aSUtw4QJF4CzMPh-yaQ7wgu-h4iCa2fSpf0bwW1YHKn7UsbllsjpH0w-iamfM-u-V8hcrZnWq5v_P4ucJgtsGZK-G4TDZ3qZINFzRsYMWLFTMDGwoA-6vlsk_SPD0Rp86WIUgSYgHLFTMzP4ihJ9e5eEA.
    xlly_s=1
    ----------------------------------------

  [FILE] cookies_backup.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_backup.json
    Размер: 234 байт
    Дата изменения: 2026-01-15T21:52:33.371178586Z
    Содержимое:
    ----------------------------------------
    {"cookie2":"5a79ddd35987b6f0","t":"1768513953364","cna":"494076cb8fea546e6cf5b1ce","_m_h5_tk_enc":"dd9f12d7ed319f2cd4f8f1ff2f0e9078","isg":"BO559b452585b8aa255d6fc31daab814","_m_h5_tk":"e9da8ac727806d44dbb99febdd72dbd9_1768513953364"}
    ----------------------------------------

  [FILE] cookies.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies.properties
    Размер: 790 байт
    Дата изменения: 2026-01-19T08:10:51.548085918Z
    Содержимое:
    ----------------------------------------
    #Auto-generated by CookieService
    #Mon Jan 19 11:10:51 MSK 2026
    goofish.cookies=t\=d09c844f0516a76e622a53cf60c5c174; cna\=/NT0IfVnoCECAZH5bfmSUNgE; _m_h5_tk_enc\=249a48b09dd379e555bcfb051f1bcd97; _samesite_flag_\=true; tfstk\=gz1nfMbBrhiblCnai0RQLxvSAiwTdBOWAghJ2QKzQh-62ytpvaSlrZJPvBdKE7bPYL5p9wIGZMIOJksJ90VljhI-wwClCbbfP6UBwyOCRQOzDoFAZw_BNDIjhkqO7z8WZe-n8GC5RQOzDaBi9lQCvGjOqQRzSC8k80RrTQzi_UtZTUlezczMPhRrTXlEQN8p-XlyLg7aSUtw4QJF4CzMPh-yaQ7wgu-h4iCa2fSpf0bwW1YHKn7UsbllsjpH0w-iamfM-u-V8hcrZnWq5v_P4ucJgtsGZK-G4TDZ3qZINFzRsYMWLFTMDGwoA-6vlsk_SPD0Rp86WIUgSYgHLFTMzP4ihJ9e5eEA.; mtop_partitioned_detect\=1; _m_h5_tk\=b12d2a731e6520d120e8161ce5fe04b9_1768819591926; _tb_token_\=f9e88355b71e3; xlly_s\=1; cookie2\=1e0d1a49c3fe5c7836bd5bc4c9285c87
    last.updated=Mon Jan 19 11\:10\:51 MSK 2026
    ----------------------------------------

  [FILE] cookies_debug_20260119_110719.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_debug_20260119_110719.properties
    Размер: 707 байт
    Дата изменения: 2026-01-19T08:07:19.924885946Z
    Содержимое:
    ----------------------------------------
    #Debug cookies from Selenium
    #Mon Jan 19 11:07:19 MSK 2026
    _m_h5_tk=a2fb5ecd01473606f2bfd7945c52c0be_1768817939872
    _m_h5_tk_enc=44dce6002c231414b419f226d3965ae8
    _samesite_flag_=true
    _tb_token_=3087353eee3f7
    cna=J9T0IXmu2XgCAZH5bfkjRUxx
    cookie2=1403bde346bb58557e386148aeba44a0
    mtop_partitioned_detect=1
    t=64133aecceeb26e02f50523e13365762
    tfstk=gShIfFtqa0hZA08p2M8NfPxg6mNWuFRqvaa-o4CFyWFKy7g-rurUUuk1VcniU2rEaAZSXcZLLvuyNcoijDuEz4Q7ycPLEvrzYuNSrmTw0IRq-2Vu9n-2ghVGckFu2QPJQ5n37M260IRq-LOEoBxqL2SQWz48wyeRwGL_kzFR9yn8XRUYuMF8w0L_Br4C9wCRpNCT8lE8w7n-WFazXyF8w0395zbwRKa6RuuBu-MZWAA472E1w_h6dJZjJT5RwfaQd7uLf2gI1ywQc8G805Gjk2h0PbYAFuaC4YC4cY5VFNwcwPZ25F6lE657l0PfA60_pP4i7FT1Ha2LSPaJ5F6lRJUgRR865MHl.
    xlly_s=1
    ----------------------------------------

  [FILE] cookies_debug_20260119_110644.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_debug_20260119_110644.properties
    Размер: 914 байт
    Дата изменения: 2026-01-19T08:06:44.215926548Z
    Содержимое:
    ----------------------------------------
    #Debug cookies from Selenium
    #Mon Jan 19 11:06:44 MSK 2026
    _m_h5_tk=7d68b9a8674a1132b8409fa14f718b8d_1768820435299
    _m_h5_tk_enc=483c9281f86a55476fbbad9e30330cd1
    _samesite_flag_=true
    _tb_token_=f7334330313bf
    cna=DdT0IfMdNC4CAZH5bflo0D4h
    cookie2=1e2b09a51b2586a50f3677fbb24e450a
    mtop_partitioned_detect=1
    t=f2a9ba561f3ed1eec3a8f82a1ee30ebb
    tfstk=gZPKdb1c4NLdNjf1DBXGqIVdfg_GIO4UKkzXZ0mHFlETlr-nFWc32LE3zuD5YXV8XzZA84jUZeyamrO3t9lkwXlrNijcisYU8blSPpECDDz_74_iRCylTacrNijGis4U8brKK-DKdP_tr4vWRuMBChiZueGSAYt6CqisVbZSFf9szqvWADi75N3rf0GSNuG1W4msVbG7VP_N5QnWdDR8K9aPkoTSVQO762HdGyi6NVPtJvnbRXRWNEgKpmaIfMdfYqD8vvFG9nuLCrnf4nF0MQZ2mm3kdNQ9ULkI7hJCkUI0QsUIWmbw0LJrLAutmNIeULkIvVncJ_pyUA7N.
    x5secdata=xg009017cece8e3989jaee31abb12c2ae6ec2a9abdbb212344cb1768809997a-717315356a1781995901abaad3eaa33b4c7594061890541dfbd6da8ac0c001efxianyuSpace_default__bx__h5api.m.goofish.com\:443/h5/mtop.taobao.idlemtopsearch.pc.search/1.0
    ----------------------------------------

  [FILE] pom.xml
    Путь: /Users/yanmore/IdeaProjects/multiParser/pom.xml
    Размер: 5181 байт
    Дата изменения: 2026-01-18T22:20:06.202218902Z
    Содержимое:
    ----------------------------------------
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
             http://maven.apache.org/xsd/maven-4.0.0.xsd">
        <modelVersion>4.0.0</modelVersion>
    
        <groupId>com.parser</groupId>
        <artifactId>multi-parser</artifactId>
        <version>2.0.0</version>
        <packaging>jar</packaging>
    
        <properties>
            <maven.compiler.source>17</maven.compiler.source>
            <maven.compiler.target>17</maven.compiler.target>
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
            <selenium.version>4.20.0</selenium.version>
        </properties>
    
        <dependencies>
            <!-- HTTP клиент -->
            <dependency>
                <groupId>org.apache.httpcomponents</groupId>
                <artifactId>httpclient</artifactId>
                <version>4.5.14</version>
            </dependency>
    
            <!-- JSON -->
            <dependency>
                <groupId>org.json</groupId>
                <artifactId>json</artifactId>
                <version>20231013</version>
            </dependency>
    
            <!-- Telegram -->
            <dependency>
                <groupId>org.telegram</groupId>
                <artifactId>telegrambots</artifactId>
                <version>6.8.0</version>
            </dependency>
    
            <!-- Logging -->
            <dependency>
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>1.4.11</version>
            </dependency>
    
            <!-- Jackson -->
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.15.3</version>
            </dependency>
    
            <!-- Selenium -->
            <dependency>
                <groupId>org.seleniumhq.selenium</groupId>
                <artifactId>selenium-java</artifactId>
                <version>${selenium.version}</version>
            </dependency>
    
            <!-- WebDriverManager -->
            <dependency>
                <groupId>io.github.bonigarcia</groupId>
                <artifactId>webdrivermanager</artifactId>
                <version>5.8.0</version>
            </dependency>
    
            <!-- Apache Commons -->
            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>3.14.0</version>
            </dependency>
    
            <!-- SLF4J API -->
            <dependency>
                <groupId>org.slf4j</groupId>
                <artifactId>slf4j-api</artifactId>
                <version>2.0.9</version>
            </dependency>
    
            <!-- Guava для утилит -->
            <dependency>
                <groupId>com.google.guava</groupId>
                <artifactId>guava</artifactId>
                <version>32.1.3-jre</version>
            </dependency>
        </dependencies>
    
        <build>
            <plugins>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <version>3.11.0</version>
                    <configuration>
                        <source>17</source>
                        <target>17</target>
                        <encoding>UTF-8</encoding>
                    </configuration>
                </plugin>
    
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-shade-plugin</artifactId>
                    <version>3.5.0</version>
                    <executions>
                        <execution>
                            <phase>package</phase>
                            <goals>
                                <goal>shade</goal>
                            </goals>
                            <configuration>
                                <transformers>
                                    <transformer implementation="org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                                        <mainClass>com.parser.Main</mainClass>
                                    </transformer>
                                </transformers>
                                <filters>
                                    <filter>
                                        <artifact>*:*</artifact>
                                        <excludes>
                                            <exclude>META-INF/*.SF</exclude>
                                            <exclude>META-INF/*.DSA</exclude>
                                            <exclude>META-INF/*.RSA</exclude>
                                            <exclude>META-INF/*.EC</exclude>
                                            <exclude>META-INF/NOTICE*</exclude>
                                            <exclude>META-INF/LICENSE*</exclude>
                                            <exclude>META-INF/versions/*</exclude>
                                            <exclude>META-INF/maven/**</exclude>
                                        </excludes>
                                    </filter>
                                </filters>
                            </configuration>
                        </execution>
                    </executions>
                </plugin>
            </plugins>
        </build>
    </project>
    ----------------------------------------

  [FILE] real_cookies.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/real_cookies.json
    Размер: 441 байт
    Дата изменения: 2026-01-16T08:19:01.367306132Z
    Содержимое:
    ----------------------------------------
    {
      "last_updated" : "Fri Jan 16 11:19:01 MSK 2026",
      "source" : "real_fetch",
      "cookies" : {
        "t" : "1768551541334",
        "cna" : "fun9mzovhxzth4rldf2656m3",
        "_m_h5_tk_enc" : "7rd0clwyamrrfzasobpgl5fzyiug6xgj",
        "isg" : "BObzsa6rgms0ke9k0mi619ntc5h9nivx",
        "_m_h5_tk" : "p2075mgals5mmin8jc4llglr3daov5ng_1768551541334",
        "_tb_token_" : "ou76zszav01n",
        "cookie2" : "u4vgb35oy9kuwy17"
      },
      "timestamp" : 1768551541334
    }
    ----------------------------------------
  [DIR] logs

    [FILE] parser.2026-01-17.log
      Путь: /Users/yanmore/IdeaProjects/multiParser/logs/parser.2026-01-17.log
      Размер: 1519066 байт
      Дата изменения: 2026-01-18T21:05:07.36289578Z
      [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]

    [FILE] parser.2026-01-16.log
      Путь: /Users/yanmore/IdeaProjects/multiParser/logs/parser.2026-01-16.log
      Размер: 209937 байт
      Дата изменения: 2026-01-18T21:05:07.308888299Z
      [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]

    [FILE] parser.log
      Путь: /Users/yanmore/IdeaProjects/multiParser/logs/parser.log
      Размер: 308294 байт
      Дата изменения: 2026-01-19T08:28:22.880093673Z
      [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]

  [FILE] api_response.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/api_response.json
    Размер: 3028 байт
    Дата изменения: 2026-01-16T20:06:11.352475191Z
    Содержимое:
    ----------------------------------------
    {"api":"mtop.taobao.idlemtopsearch.pc.search","v":"1.0", "ret": ["RGV587_ERROR::SM::哎哟喂,被挤爆啦,请稍后重试!"],"data": { "url": "https://passport.goofish.com/mini_login.htm?lang=zh_cn&appName=xianyu&appEntrance=baxia&redirectType=iframeRedirect&styleType=vertical&bizParams=&notLoadSsoView=true&notKeepLogin=false&isMobile=false&qrCodeFirst=false&rnd=0.7405678221745524&returnUrl=https%3a%2f%2fh5api.m.goofish.com:443/h5/mtop.taobao.idlemtopsearch.pc.search/1.0%2F_____tmd_____%2Fpage%2Fmtoph5_close_iframe_page%3Frand%3DS3WxGHAgAt756EpznwfNzJq2AFA2qBNla3j6EINUS8We9dazM_iKElp8DwVSHZUevpC41Bx7RzivXIj9RnZgdg%26uuid%3D0c554ce36815acdfa722dafce91d8863%26_lgt_%3D0c554ce36815acdfa722dafce91d8863___305220___d57171f5eb6e272202b5487a483d5dfa___eaebc79cac1eb5d2f7d8b4595e00ec73344a42d5a0b8cf56539c823cd24ac06c092f67171550cb6cbbc4aaaa937e5ef4f60277010dffec5689671a57f915809888d25ef3220a7c2464a290cff32056669f3d6a459ad2c296ee8cbb5a8d67c1a029af9254ddea98f951f5ea79ca6d68afacb857c81ed97566c7ec74b7eb613fa519b4c3107e712c0b12b48606e859d16ccbd4fb8cf17cff382cca796b27b42f93bdd660982d155ad900bd3837f5da3e57ca78869e9450dde1ca0616ecc84d1bef86a07297d351a5f1954e205f0907ed8ab9518cbf4cff63eb12033451f3cce3ec58715d624adb927aaa033fb788a8928b84bbc28e79d0d752ddcd10ee29db7b904fd08591e292b488a8748becc81d31ed20f50715c332ef14fe2906c58135278f61177841a36789ac8d0efdb86bbd42388e984c4f3c9f78190b7d525276218f543735df556116b6b4f0c837e6021fa5473cd742cc3b4bcbc79f2b2b1dda4ba31835c41fe5998c210b7575bb4bc702aebacd5c40286fce09dcb3d11fd149fb1e363d4a43213597d5e2249ec2536825bd75918316a8d62033b9ebf7b284e2a36b48", "h5url": "https://passport.goofish.com/mini_login.htm?appName=xianyu&appEntrance=baxia&isMobile=true&redirectType=iframeRedirect&returnUrl=https%3a%2f%2fh5api.m.goofish.com:443/h5/mtop.taobao.idlemtopsearch.pc.search/1.0%2F_____tmd_____%2Fpage%2Fmtoph5_close_iframe_page%3Frand%3DS3WxGHAgAt756EpznwfNzJq2AFA2qBNla3j6EINUS8We9dazM_iKElp8DwVSHZUevpC41Bx7RzivXIj9RnZgdg%26uuid%3D0c554ce36815acdfa722dafce91d8863%26_lgt_%3D0c554ce36815acdfa722dafce91d8863___305220___d57171f5eb6e272202b5487a483d5dfa___eaebc79cac1eb5d2f7d8b4595e00ec73344a42d5a0b8cf56539c823cd24ac06c092f67171550cb6cbbc4aaaa937e5ef4f60277010dffec5689671a57f915809888d25ef3220a7c2464a290cff32056669f3d6a459ad2c296ee8cbb5a8d67c1a029af9254ddea98f951f5ea79ca6d68afacb857c81ed97566c7ec74b7eb613fa519b4c3107e712c0b12b48606e859d16ccbd4fb8cf17cff382cca796b27b42f93bdd660982d155ad900bd3837f5da3e57ca78869e9450dde1ca0616ecc84d1bef86a07297d351a5f1954e205f0907ed8ab9518cbf4cff63eb12033451f3cce3ec58715d624adb927aaa033fb788a8928b84bbc28e79d0d752ddcd10ee29db7b904fd08591e292b488a8748becc81d31ed20f50715c332ef14fe2906c58135278f61177841a36789ac8d0efdb86bbd42388e984c4f3c9f78190b7d525276218f543735df556116b6b4f0c837e6021fa5473cd742cc3b4bcbc79f2b2b1dda4ba31835c41fe5998c210b7575bb4bc702aebacd5c40286fce09dcb3d11fd149fb1e363d4a43213597d5e2249ec2536825bd75918316a8d62033b9ebf7b284e2a36b48", "dialogSize": {"width": "856px", "height": "454px"}}, "dialogSize": {"width": "856px", "height": "454px"}}
    ----------------------------------------

  [FILE] dependency-reduced-pom.xml
    Путь: /Users/yanmore/IdeaProjects/multiParser/dependency-reduced-pom.xml
    Размер: 2214 байт
    Дата изменения: 2026-01-19T08:22:56.628685987Z
    Содержимое:
    ----------------------------------------
    <?xml version="1.0" encoding="UTF-8"?>
    <project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
      <modelVersion>4.0.0</modelVersion>
      <groupId>com.parser</groupId>
      <artifactId>multi-parser</artifactId>
      <version>2.0.0</version>
      <build>
        <plugins>
          <plugin>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.11.0</version>
            <configuration>
              <source>17</source>
              <target>17</target>
              <encoding>UTF-8</encoding>
            </configuration>
          </plugin>
          <plugin>
            <artifactId>maven-shade-plugin</artifactId>
            <version>3.5.0</version>
            <executions>
              <execution>
                <phase>package</phase>
                <goals>
                  <goal>shade</goal>
                </goals>
                <configuration>
                  <transformers>
                    <transformer>
                      <mainClass>com.parser.Main</mainClass>
                    </transformer>
                  </transformers>
                  <filters>
                    <filter>
                      <artifact>*:*</artifact>
                      <excludes>
                        <exclude>META-INF/*.SF</exclude>
                        <exclude>META-INF/*.DSA</exclude>
                        <exclude>META-INF/*.RSA</exclude>
                        <exclude>META-INF/*.EC</exclude>
                        <exclude>META-INF/NOTICE*</exclude>
                        <exclude>META-INF/LICENSE*</exclude>
                        <exclude>META-INF/versions/*</exclude>
                        <exclude>META-INF/maven/**</exclude>
                      </excludes>
                    </filter>
                  </filters>
                </configuration>
              </execution>
            </executions>
          </plugin>
        </plugins>
      </build>
      <properties>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        <maven.compiler.target>17</maven.compiler.target>
        <selenium.version>4.20.0</selenium.version>
        <maven.compiler.source>17</maven.compiler.source>
      </properties>
    </project>
    ----------------------------------------

  [FILE] .gitignore
    Путь: /Users/yanmore/IdeaProjects/multiParser/.gitignore
    Размер: 0 байт
    Дата изменения: 2026-01-17T12:50:01.802474294Z
    [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]
  [DIR] .mvn

  [FILE] cookies.json
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies.json
    Размер: 419 байт
    Дата изменения: 2026-01-16T07:59:20.60810124Z
    Содержимое:
    ----------------------------------------
    {
      "last_updated" : "Fri Jan 16 10:59:20 MSK 2026",
      "cookies" : {
        "t" : "1768550339826",
        "cna" : "yf3PXI6YB2MCAXE5zQoJABCD",
        "_m_h5_tk_enc" : "f83c9d0d8b3a2e1c4f7d8e06a2cbd5e6",
        "isg" : "BOB4X6Y7Z8A9B0C1D2E3F4G5H6I7J8K9L",
        "_m_h5_tk" : "06a2cbd5e6f83c9d0d8b3a2e1c4f7d8e_1768550339826",
        "_tb_token_" : "e3f4g5h6i7j8k9l0m1n2o3p4q5r6s7t",
        "cookie2" : "179e5ac7f7b2c4d8e9f0a1b2c3d4e5f6"
      }
    }
    ----------------------------------------
  [DIR] data

    [FILE] whitelist.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/whitelist.txt
      Размер: 244 байт
      Дата изменения: 2026-01-18T21:29:51.958777491Z
      Содержимое:
      ----------------------------------------
      # Whitelist - список авторизованных пользователей
      # Формат: один ID пользователя на строке
      # Создан: Mon Jan 19 00:29:51 MSK 2026
      
      1080595280
      1652510924
      5328022266
      6937423668
      ----------------------------------------
    [DIR] user_queries

      [FILE] 1080595280.txt
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_queries/1080595280.txt
        Размер: 22 байт
        Дата изменения: 2026-01-19T07:36:06.709025027Z
        Содержимое:
        ----------------------------------------
        stone island
        cav empt
        ----------------------------------------

      [FILE] 5328022266.txt
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_queries/5328022266.txt
        Размер: 23 байт
        Дата изменения: 2026-01-19T07:42:44.706382918Z
        Содержимое:
        ----------------------------------------
        number nine
        raf simons
        ----------------------------------------
    [DIR] user_products

      [FILE] 6937423668.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_products/6937423668.json
        Размер: 3664 байт
        Дата изменения: 2026-01-17T21:21:02.695697176Z
        Содержимое:
        ----------------------------------------
        [{"id":"1014278121369","title":"Stone Island/石头岛美式翻领夹克外套 【面料】外层面料采用了加厚加密的锦纶斜纹面料，兼具耐穿性和耐久防水功能。现代感时尚廓型剪裁，帅气百搭。内部采用柔软里布，螺纹全部面料对色定染定织！两个外口袋设计，内里竖口袋设计，收纳方便、走线的细节全部打套节处理，飞行员军工风上身帅气十足，非常适合日常休闲穿搭！胳膊上的袖章的刺绣工艺流程采用日本进口机器进行作业 字母图案清晰立体，有质感 ！-...","price":159.0,"url":"https://www.goofish.com/item?id=1014278121369","site":"goofish","location":"江苏","ageMinutes":781,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i3/2220983028576/O1CN01Gan7hi2DDrmJykcEF_!!4611686018427382624-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862681,"isNew":true},{"id":"1014956044370","title":"【STONE ISLAND石头岛经典徽章羊羔毛棉服外套】 定制主标 辅料 水洗齐全 原版一致徽章 纽扣开模订做宽松版型 甄选优质麂皮防风面料 内里填充高克重羽绒棉 舒适温暖羊羔毛领 亲肤柔软立体剪裁 防风保暖 随性时髦可搭配任意下装 轻松凹造型 显瘦显高 男女均可完美驾驭！color：黑色/咖色size：M.L.XL.2XL.3XLM胸围120 肩宽51 衣长66   L 胸围124 肩宽5...","price":252.0,"url":"https://www.goofish.com/item?id=1014956044370","site":"goofish","location":"山东","ageMinutes":1115,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i4/2219863640002/O1CN01mTD99V1BsxuVPC5Gj_!!4611686018427381698-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862681,"isNew":true},{"id":"1014277989994","title":"石头岛哈灵顿夹克 非正 高版本 L码能穿到180 150斤能刀","price":250.0,"url":"https://www.goofish.com/item?id=1014277989994","site":"goofish","location":"北京","ageMinutes":780,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i1/2214700202885/O1CN01y3cIr71XBNlgmzqyb_!!4611686018427386757-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862682,"isNew":true},{"id":"1013439486344","title":"STONE ISLAND石头岛 FW23 圆领基础套头Log o卫衣 男款 灰色在意大利佛罗伦萨市中心石头岛专卖店折扣价购买268欧元约2200人民币保证正品已经购买一年，有洗过，低价出售L码175-185都可以穿","price":629.0,"url":"https://www.goofish.com/item?id=1013439486344","site":"goofish","location":"浙江","ageMinutes":677,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i1/2212676127444/O1CN01TMCJCx24rPQpeM3hc_!!4611686018427382484-0-xy_item.jpg"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862682,"isNew":true},{"id":"1012740567979","title":"【捡漏】STONE ISLAND x  New Balanc e New Balance x TDS 联名系列 舒适耐磨 低帮跑步鞋 男款 米白色断码库存、图中就是实拍，价格已是低价、不议价！！尺码：39～45  正码正拍 断码清仓拍前私信客服有无码数！！！售后:非偏远包邮、质量问题支持退换，七天无理由","price":89.0,"url":"https://www.goofish.com/item?id=1012740567979","site":"goofish","location":"山西","ageMinutes":910,"query":"stone island","images":["http://img.alicdn.com/bao/uploaded/i4/2219176448221/O1CN01hz843X2AbHAus1wva_!!4611686018427384029-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684862683,"isNew":true}]
        ----------------------------------------

      [FILE] 1080595280.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_products/1080595280.json
        Размер: 2726 байт
        Дата изменения: 2026-01-17T21:22:24.294716014Z
        Содержимое:
        ----------------------------------------
        [{"id":"1015019244484","title":"Cav Empt蓝骨头卫衣不是原版，M码，几乎全新，保存很好 ，没啥明显痕迹。宽松连帽，袖子有小标，质量不错，穿着舒服，春秋都能穿。包邮，同城可自提，价格可聊，喜欢直接拍，细节私聊～","price":250.0,"url":"https://www.goofish.com/item?id=1015019244484","site":"goofish","location":"上海","ageMinutes":836,"query":"cav empt","images":["http://img.alicdn.com/bao/uploaded/i4/O1CN01ishmDu1R0x3Lr9j2n~livephoto~_!!4611686018427385426-53-fleamarket.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684937689,"isNew":true},{"id":"1014997792247","title":"cav empt中古做旧卫衣 size:s 有污渍，美国带回来时候就这样保正内标掉了一半要重新缝低价出了","price":480.0,"url":"https://www.goofish.com/item?id=1014997792247","site":"goofish","location":"上海","ageMinutes":919,"query":"cav empt","images":["http://img.alicdn.com/bao/uploaded/i4/2856765447/O1CN01js44ER1q6mULyBrj6_!!4611686018427381767-53-xy_item.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684937691,"isNew":true},{"id":"1014186209654","title":"C.E 犀 CAV EMPT 尼龙连帽衫 L 免日本代购费 ——以下为煤炉原商品信息的中文翻译，供参考——【商品描述】C.E的登山夹克。【品牌】C.E（犀伊）【颜色】浅白色【尺寸】尺寸：L衣长:74cm身幅:63cm袖长: 76厘米※ 由于是个人测量，可能存在误差，敬请谅解。【材质】尼龙100% 【注意事项】※ 事先敬请知悉：因由个人保管，敬请理解。※ 由于拍摄环境不同，实物与照片在颜色上可...","price":2249.0,"url":"https://www.goofish.com/item?id=1014186209654","site":"goofish","location":"北京","ageMinutes":1187,"query":"cav empt","images":["http://img.alicdn.com/bao/uploaded/i4/O1CN01zBqs7y1Q3rxcbrjYJ_!!4611686018427382625-0-fleamarket.jpg"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684937691,"isNew":true},{"id":"1014261629666","title":"cav empt jog pant ce水洗做旧线圈卫裤，裤 子质感很好，内里线圈 整体摸起来比较厚实，腰部和裤脚都有氧化泛红（水洗款通病），图片实拍尺码：L  颜色：水洗灰腰围78-94 大腿33 裤长96售出除假货以外均不退换，支持鉴定","price":459.0,"url":"https://www.goofish.com/item?id=1014261629666","site":"goofish","location":"四川","ageMinutes":841,"query":"cav empt","images":["http://img.alicdn.com/bao/uploaded/i3/O1CN01heZDHc2E7k687jyZO_!!4611686018427384538-53-fleamarket.heic"],"seller":null,"sellerRating":null,"category":null,"foundTimestamp":1768684937691,"isNew":true}]
        ----------------------------------------
    [DIR] user_settings

      [FILE] 6937423668.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/6937423668.json
        Размер: 334 байт
        Дата изменения: 2026-01-17T21:22:17.000818167Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":20,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":500,"priceCurrency":"rubles","notifyNewOnly":true,"notifyTelegram":true,"notifyEmail":false,"notifySound":true,"minPrice":0.0,"maxPrice":0.0,"locations":[],"excludedKeywords":[],"enableProxy":false,"proxyAddress":"","proxyPort":0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

      [FILE] 5328022266.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/5328022266.json
        Размер: 227 байт
        Дата изменения: 2026-01-19T07:43:10.908043946Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":300,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":100,"priceCurrency":"rubles","notifyNewOnly":true,"notifyTelegram":true,"notifyEmail":false,"minPrice":0.0,"maxPrice":0.0,"requestDelay":2000,"maxRetries":3}
        ----------------------------------------

      [FILE] 1080595280.json
        Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_settings/1080595280.json
        Размер: 226 байт
        Дата изменения: 2026-01-19T07:32:15.486914057Z
        Содержимое:
        ----------------------------------------
        {"checkInterval":20,"maxAgeMinutes":1440,"maxPages":3,"rowsPerPage":500,"priceCurrency":"rubles","notifyNewOnly":true,"notifyTelegram":true,"notifyEmail":false,"minPrice":0.0,"maxPrice":0.0,"requestDelay":5000,"maxRetries":3}
        ----------------------------------------

    [FILE] user_6937423668_queries.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_6937423668_queries.txt
      Размер: 13 байт
      Дата изменения: 2026-01-17T15:22:23.938396657Z
      Содержимое:
      ----------------------------------------
      stone island
      ----------------------------------------

    [FILE] user_1080595280_queries.txt
      Путь: /Users/yanmore/IdeaProjects/multiParser/data/user_1080595280_queries.txt
      Размер: 61 байт
      Дата изменения: 2026-01-17T11:15:03.285860364Z
      Содержимое:
      ----------------------------------------
      stone island
      cav empt
      adidas
      iphone
      macbook
      samsung
      cat
      puma
      ----------------------------------------

  [FILE] cookies_debug_20260119_110601.properties
    Путь: /Users/yanmore/IdeaProjects/multiParser/cookies_debug_20260119_110601.properties
    Размер: 707 байт
    Дата изменения: 2026-01-19T08:06:01.137442836Z
    Содержимое:
    ----------------------------------------
    #Debug cookies from Selenium
    #Mon Jan 19 11:06:01 MSK 2026
    _m_h5_tk=03ffba78ff01b19a143f62da64ed7518_1768819991518
    _m_h5_tk_enc=fbbdfeddb5169b78b9cd607444edc4b4
    _samesite_flag_=true
    _tb_token_=30534765ade34
    cna=vNP0ITpe7B4CAZH5bfmZYBFQ
    cookie2=14d4fe13fa81de8fa73e38ce3ce3eb9a
    mtop_partitioned_detect=1
    t=9bbd9ee8e9bdd9d9ebbebb787f244820
    tfstk=gvcjfutE_chyRdYvXi8PVzAkW4VsMUREDNat-VCVWSFxW5gtSlr4Qlk5f0noQqrq_YZs20ZY3xuw10ooqmuq7VQ_W0PYIxra0lNsSDTyYBREoqVgMH-eTqnZJ2PgXCP9U7n0zi2WYBREoKU0_4KE3qWfcP4T6reO6aL7JPFODRnT28UL8iFT6cL7eP4QWZCYDuE8RuET65ntyUaa2rFT6c3JPPbCQpaWlluX8JM85X9Hkqr561h7lEZKluaurbabhkHuV13jNrwbvqGpVjd85vhQnDKP3oHQhgrhTkMNTO_7K1U7YUT5IOfV1yiaVC_E1-Uur48WP9QgHz47WUT5IZwYrrwyPUsxI
    xlly_s=1
    ----------------------------------------
  [DIR] src
    [DIR] test
      [DIR] java
    [DIR] main
      [DIR] resources

        [FILE] logback.xml
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/logback.xml
          Размер: 1358 байт
          Дата изменения: 2026-01-16T19:18:24.207912756Z
          Содержимое:
          ----------------------------------------
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
              <property name="LOG_DIR" value="./logs" />
              <property name="LOG_FILE" value="parser" />
          
              <!-- Консольный аппендер -->
              <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
                  <encoder>
                      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <!-- Файловый аппендер -->
              <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
                  <file>${LOG_DIR}/${LOG_FILE}.log</file>
                  <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
                      <fileNamePattern>${LOG_DIR}/${LOG_FILE}.%d{yyyy-MM-dd}.log</fileNamePattern>
                      <maxHistory>30</maxHistory>
                      <totalSizeCap>1GB</totalSizeCap>
                  </rollingPolicy>
                  <encoder>
                      <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <!-- Логирование Selenium -->
              <logger name="org.openqa.selenium" level="WARN" />
              <logger name="io.github.bonigarcia" level="WARN" />
          
              <!-- Корневой логгер -->
              <root level="INFO">
                  <appender-ref ref="CONSOLE" />
                  <appender-ref ref="FILE" />
              </root>
          </configuration>
          ----------------------------------------

        [FILE] cookie.properties
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/cookie.properties
          Размер: 440 байт
          Дата изменения: 2026-01-19T08:08:42.035323004Z
          Содержимое:
          ----------------------------------------
          #Auto-generated manually
          #Sun Jan 19 10:59:15 MSK 2026
          goofish.cookies=t=480fc9024b2f5827ba196b998741cd4c; cna=PdL0Ib0VcRwCAZH5bfnhBmlQ; _m_h5_tk_enc=bf705b75b61e615fd53ec313cefe0c31; _samesite_flag_=true; tfstk=g5EmdhwjIbOILSRPxCofueqXdqQ-lmz0Zq2emTHdCAfCIeQ8hZfD7j_xNwe5cFVk.; mtop_partitioned_detect=1; _tb_token_=f7f34bb85ee67; _m_h5_tk=a6e9a17aa6960058aa5d72a1ea9e6e38_1768809555675; xlly_s=1; cookie2=1ee830356c4ef843758f940a7e0b682b
          ----------------------------------------

        [FILE] logback-debug.xml
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/logback-debug.xml
          Размер: 363 байт
          Дата изменения: 2026-01-16T19:22:31.341841447Z
          Содержимое:
          ----------------------------------------
          <?xml version="1.0" encoding="UTF-8"?>
          <configuration>
              <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
                  <encoder>
                      <pattern>%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
                  </encoder>
              </appender>
          
              <root level="DEBUG">
                  <appender-ref ref="CONSOLE" />
              </root>
          </configuration>
          ----------------------------------------

        [FILE] config.properties
          Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/resources/config.properties
          Размер: 1590 байт
          Дата изменения: 2026-01-18T21:10:20.879957963Z
          Содержимое:
          ----------------------------------------
          # ======================
          # Telegram Bot Settings
          # ======================
          telegram.bot.token=8404858867:AAF6AkEToZgCktCdZsPV62jgEqK1vul_QFg
          telegram.bot.username=goofishparse_bot
          telegram.admin.id=1080595280
          
          # ======================
          # Parser Configuration
          # ======================
          parser.default.check_interval=300
          parser.default.max_age_minutes=1440
          parser.default.max_pages=3
          parser.default.rows_per_page=100
          parser.default.notify_new_only=true
          
          # ======================
          # Thread Pool Configuration
          # ======================
          thread.pool.core.size=5
          thread.pool.max.size=20
          thread.pool.queue.capacity=100
          thread.pool.keepalive.seconds=60
          
          # ======================
          # Storage Configuration
          # ======================
          storage.data.dir=./data
          storage.backup.enabled=true
          
          # ======================
          # HTTP Configuration
          # ======================
          http.connect.timeout=10000
          http.read.timeout=15000
          http.user.agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
          http.max.retries=3
          
          # ======================
          # Cookie Configuration
          # ======================
          cookie.update.interval.hours=6
          cookie.auto.update=true
          cookie.selenium.headless=true
          
          # ======================
          # Logging Configuration
          # ======================
          logging.level=INFO
          logging.file=parser.log
          
          # ======================
          # Supported Sites Configuration
          # ======================
          sites.supported=goofish
          site.goofish.name=Goofish
          site.goofish.base_url=https://h5api.m.goofish.com
          site.goofish.search_endpoint=/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/
          site.goofish.app_key=34839810
          site.goofish.delay_between_requests=2000
          ----------------------------------------
      [DIR] java
        [DIR] com
          [DIR] parser
            [DIR] core

              [FILE] UserSession.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/core/UserSession.java
                Размер: 6419 байт
                Дата изменения: 2026-01-18T21:08:39.441499048Z
                Содержимое:
                ----------------------------------------
                package com.parser.core;
                
                import com.parser.config.ParserSettings;
                import com.parser.model.UserSettings;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.util.*;
                
                /**
                 * Класс, представляющий сессию парсера для пользователя
                 */
                public class UserSession {
                    private static final Logger logger = LoggerFactory.getLogger(UserSession.class);
                
                    private final long userId;
                    private final List<String> queries;
                    private final UserSettings settings;
                
                    // Состояние
                    private volatile boolean running;
                    private volatile boolean paused;
                    private String status;
                    private String lastError;
                
                    // Статистика
                    private int totalProductsFound;
                    private int requestsMade;
                    private int errorsCount;
                
                    // Временные метки
                    private Date startTime;
                    private Date endTime;
                    private Date lastIterationTime;
                    private Date lastProductFoundTime;
                
                    public UserSession(long userId, List<String> queries, UserSettings settings) {
                        this.userId = userId;
                        this.queries = new ArrayList<>(queries);
                        this.settings = settings;
                        this.running = false;
                        this.paused = false;
                        this.status = ParserSettings.STATUS_STOPPED;
                        this.totalProductsFound = 0;
                        this.requestsMade = 0;
                        this.errorsCount = 0;
                    }
                
                    // Геттеры
                    public long getUserId() { return userId; }
                    public List<String> getQueries() { return new ArrayList<>(queries); }
                    public UserSettings getSettings() { return settings; }
                    public boolean isRunning() { return running; }
                    public boolean isPaused() { return paused; }
                    public String getStatus() { return status; }
                    public String getLastError() { return lastError; }
                    public int getTotalProductsFound() { return totalProductsFound; }
                    public int getRequestsMade() { return requestsMade; }
                    public int getErrorsCount() { return errorsCount; }
                    public Date getStartTime() { return startTime; }
                    public Date getEndTime() { return endTime; }
                    public Date getLastIterationTime() { return lastIterationTime; }
                    public Date getLastProductFoundTime() { return lastProductFoundTime; }
                
                    // Сеттеры
                    public void setRunning(boolean running) {
                        this.running = running;
                        this.status = running ? ParserSettings.STATUS_RUNNING : ParserSettings.STATUS_STOPPED;
                        if (running) {
                            this.startTime = new Date();
                        } else {
                            this.endTime = new Date();
                        }
                    }
                
                    public void setPaused(boolean paused) {
                        this.paused = paused;
                        this.status = paused ? ParserSettings.STATUS_PAUSED :
                                (running ? ParserSettings.STATUS_RUNNING : ParserSettings.STATUS_STOPPED);
                    }
                
                    public void setStatus(String status) { this.status = status; }
                    public void setLastError(String lastError) { this.lastError = lastError; }
                    public void setStartTime(Date startTime) { this.startTime = startTime; }
                    public void setEndTime(Date endTime) { this.endTime = endTime; }
                    public void setLastIterationTime(Date lastIterationTime) { this.lastIterationTime = lastIterationTime; }
                    public void setLastProductFoundTime(Date lastProductFoundTime) { this.lastProductFoundTime = lastProductFoundTime; }
                
                    // Методы для работы со статистикой
                    public void addProductsFound(int count) {
                        this.totalProductsFound += count;
                        this.lastProductFoundTime = new Date();
                    }
                
                    public void incrementRequestsMade() { this.requestsMade++; }
                    public void incrementErrors() { this.errorsCount++; }
                
                    /**
                     * Получение подробного статуса сессии
                     */
                    public Map<String, Object> getDetailedStatus() {
                        Map<String, Object> status = new HashMap<>();
                
                        status.put("userId", userId);
                        status.put("running", running);
                        status.put("paused", paused);
                        status.put("status", this.status);
                        status.put("queriesCount", queries.size());
                        status.put("totalProductsFound", totalProductsFound);
                        status.put("requestsMade", requestsMade);
                        status.put("errorsCount", errorsCount);
                        status.put("lastError", lastError);
                
                        // Временные метки
                        status.put("startTime", startTime != null ? startTime.getTime() : null);
                        status.put("endTime", endTime != null ? endTime.getTime() : null);
                        status.put("lastIterationTime", lastIterationTime != null ? lastIterationTime.getTime() : null);
                        status.put("lastProductFoundTime", lastProductFoundTime != null ? lastProductFoundTime.getTime() : null);
                
                        // Uptime
                        if (startTime != null) {
                            long uptime = System.currentTimeMillis() - startTime.getTime();
                            status.put("uptime", formatUptime(uptime));
                        }
                
                        // Настройки
                        if (settings != null) {
                            Map<String, Object> settingsMap = new HashMap<>();
                            settingsMap.put("checkInterval", settings.getCheckInterval());
                            settingsMap.put("maxAgeMinutes", settings.getMaxAgeMinutes());
                            settingsMap.put("maxPages", settings.getMaxPages());
                            settingsMap.put("rowsPerPage", settings.getRowsPerPage());
                            settingsMap.put("priceCurrency", settings.getPriceCurrency());
                            settingsMap.put("notifyNewOnly", settings.isNotifyNewOnly());
                            status.put("settings", settingsMap);
                        }
                
                        return status;
                    }
                
                    /**
                     * Форматирование времени работы
                     */
                    private String formatUptime(long millis) {
                        long seconds = millis / 1000;
                        long minutes = seconds / 60;
                        long hours = minutes / 60;
                        long days = hours / 24;
                
                        if (days > 0) {
                            return String.format("%dд %dч %dм", days, hours % 24, minutes % 60);
                        } else if (hours > 0) {
                            return String.format("%dч %dм %dс", hours, minutes % 60, seconds % 60);
                        } else if (minutes > 0) {
                            return String.format("%dм %dс", minutes, seconds % 60);
                        } else {
                            return String.format("%dс", seconds);
                        }
                    }
                
                    @Override
                    public String toString() {
                        return String.format("UserSession{userId=%d, running=%s, queries=%d, found=%d}",
                                userId, running, queries.size(), totalProductsFound);
                    }
                }
                ----------------------------------------

              [FILE] ThreadManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/core/ThreadManager.java
                Размер: 17603 байт
                Дата изменения: 2026-01-18T21:08:22.889055738Z
                Содержимое:
                ----------------------------------------
                package com.parser.core;
                
                import com.parser.config.Config;
                import com.parser.model.Product;
                import com.parser.model.UserSettings;
                import com.parser.parser.ParserFactory;
                import com.parser.parser.SiteParser;
                import com.parser.service.CookieService;
                import com.parser.storage.UserDataManager;
                import com.parser.storage.WhitelistManager;
                import com.parser.telegram.TelegramNotificationService;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.util.*;
                import java.util.concurrent.*;
                
                /**
                 * Менеджер потоков для управления парсерами пользователей
                 */
                public class ThreadManager {
                    private static final Logger logger = LoggerFactory.getLogger(ThreadManager.class);
                
                    private final Map<Long, UserSession> userSessions = new ConcurrentHashMap<>();
                    private final ThreadPoolExecutor threadPool;
                    private final ScheduledExecutorService scheduler;
                
                    // Статистика
                    private int totalProductsFound = 0;
                    private int totalRequestsMade = 0;
                    private final Date startTime = new Date();
                
                    public ThreadManager() {
                        int corePoolSize = Config.getThreadPoolCoreSize();
                        int maxPoolSize = Config.getThreadPoolMaxSize();
                        int keepAliveTime = Config.getThreadPoolKeepAlive();
                        int queueCapacity = Config.getThreadPoolQueueCapacity();
                
                        // Создание пула потоков
                        BlockingQueue<Runnable> workQueue = new LinkedBlockingQueue<>(queueCapacity);
                        threadPool = new ThreadPoolExecutor(
                                corePoolSize,
                                maxPoolSize,
                                keepAliveTime,
                                TimeUnit.SECONDS,
                                workQueue,
                                new ThreadPoolExecutor.CallerRunsPolicy()
                        );
                
                        // Создание планировщика
                        scheduler = Executors.newScheduledThreadPool(2);
                
                        // Запуск задачи для логирования статистики
                        scheduler.scheduleAtFixedRate(this::logStatistics, 5, 5, TimeUnit.MINUTES);
                
                        logger.info("ThreadManager initialized. Pool: {}-{} threads, queue: {}",
                                corePoolSize, maxPoolSize, queueCapacity);
                    }
                
                    /**
                     * Запуск парсера для пользователя
                     */
                    public boolean startUserParser(long userId) {
                        logger.info("Attempting to start parser for user {}", userId);
                
                        // Проверка whitelist
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            logger.warn("User {} NOT in whitelist", userId);
                            TelegramNotificationService.sendMessage(userId,
                                    "⛔ Вы не авторизованы для использования парсера.\n" +
                                            "Используйте команду /start для регистрации");
                            return false;
                        }
                
                        if (userSessions.containsKey(userId)) {
                            UserSession session = userSessions.get(userId);
                            if (session.isRunning()) {
                                logger.warn("Parser already running for user {}", userId);
                                TelegramNotificationService.sendMessage(userId, "⚠️ Парсер уже запущен");
                                return false;
                            }
                            stopUserParser(userId);
                        }
                
                        // Получение запросов пользователя
                        List<String> queries = UserDataManager.getUserQueries(userId);
                        if (queries.isEmpty()) {
                            logger.warn("User {} has no queries", userId);
                            TelegramNotificationService.sendMessage(userId,
                                    "📭 У вас нет поисковых запросов.\n" +
                                            "Добавьте запросы командой /addquery [текст]");
                            return false;
                        }
                
                        logger.info("User {} has {} queries", userId, queries.size());
                
                        // Получение настроек пользователя
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                
                        // Создание сессии пользователя
                        UserSession session = new UserSession(userId, queries, settings);
                        userSessions.put(userId, session);
                
                        // Запуск парсера в отдельном потоке
                        threadPool.submit(() -> {
                            try {
                                runUserParser(session);
                            } catch (Exception e) {
                                logger.error("Error in parser for user {}: {}", userId, e.getMessage(), e);
                                TelegramNotificationService.sendMessage(userId,
                                        "❌ Ошибка в работе парсера: " + e.getMessage());
                                userSessions.remove(userId);
                            }
                        });
                
                        logger.info("Parser started for user {}", userId);
                        return true;
                    }
                
                    /**
                     * Основной цикл работы парсера для пользователя
                     */
                    private void runUserParser(UserSession session) {
                        final long userId = session.getUserId();
                        session.setRunning(true);
                        session.setStartTime(new Date());
                
                        logger.info("Parser loop started for user {}", userId);
                
                        try {
                            SiteParser parser = ParserFactory.createParser("goofish");
                
                            while (session.isRunning() && !Thread.currentThread().isInterrupted()) {
                                long iterationStartTime = System.currentTimeMillis();
                                int productsFoundInIteration = 0;
                
                                for (String query : session.getQueries()) {
                                    if (!session.isRunning() || Thread.currentThread().isInterrupted()) {
                                        break;
                                    }
                
                                    try {
                                        logger.debug("Searching '{}' for user {}", query, userId);
                
                                        List<Product> products = parser.search(
                                                query,
                                                session.getSettings().getMaxPages(),
                                                session.getSettings().getRowsPerPage(),
                                                session.getSettings().getMaxAgeMinutes()
                                        );
                
                                        totalRequestsMade++;
                                        session.incrementRequestsMade();
                
                                        if (!products.isEmpty()) {
                                            productsFoundInIteration += products.size();
                                            session.addProductsFound(products.size());
                                            totalProductsFound += products.size();
                
                                            logger.info("Found {} products for query '{}' (user {})",
                                                    products.size(), query, userId);
                
                                            if (shouldSendNotification(session, products)) {
                                                sendProductNotifications(userId, products, query, session.getSettings());
                                            }
                
                                            UserDataManager.saveUserProducts(userId, products);
                                        }
                
                                        Thread.sleep(2000); // Задержка между запросами
                
                                    } catch (Exception e) {
                                        logger.error("Error searching query '{}' for user {}: {}",
                                                query, userId, e.getMessage());
                                        session.incrementErrors();
                
                                        if (isCookieRelatedError(e)) {
                                            logger.warn("Cookie-related error detected, refreshing cookies...");
                                            CookieService.refreshCookies("goofish");
                                        }
                
                                        Thread.sleep(5000);
                                    }
                                }
                
                                if (productsFoundInIteration > 0) {
                                    logger.info("Iteration completed for user {}: found {} products",
                                            userId, productsFoundInIteration);
                                }
                
                                // Ожидание до следующей проверки
                                int checkInterval = session.getSettings().getCheckInterval();
                                for (int i = 0; i < checkInterval && session.isRunning(); i++) {
                                    Thread.sleep(1000);
                                }
                
                                session.setLastIterationTime(new Date());
                            }
                
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                            logger.info("Parser thread interrupted for user {}", userId);
                        } catch (Exception e) {
                            logger.error("Unexpected error in parser for user {}: {}", userId, e.getMessage(), e);
                        } finally {
                            session.setRunning(false);
                            session.setEndTime(new Date());
                            userSessions.remove(userId);
                
                            logger.info("Parser stopped for user {}", userId);
                        }
                    }
                
                    /**
                     * Проверка, связана ли ошибка с куками
                     */
                    private boolean isCookieRelatedError(Exception e) {
                        if (e == null || e.getMessage() == null) return false;
                
                        String message = e.getMessage().toLowerCase();
                        return message.contains("cookie") ||
                                message.contains("session") ||
                                message.contains("auth") ||
                                message.contains("401") ||
                                message.contains("403") ||
                                message.contains("unauthorized") ||
                                message.contains("未登录") ||
                                message.contains("未授权");
                    }
                
                    /**
                     * Проверка необходимости отправки уведомления
                     */
                    private boolean shouldSendNotification(UserSession session, List<Product> products) {
                        UserSettings settings = session.getSettings();
                
                        if (products.isEmpty()) return false;
                
                        if (settings.isNotifyNewOnly()) {
                            List<Product> newProducts = UserDataManager.filterNewProducts(
                                    session.getUserId(), products);
                            return !newProducts.isEmpty();
                        }
                
                        return true;
                    }
                
                    /**
                     * Отправка уведомлений о товарах
                     */
                    private void sendProductNotifications(long userId, List<Product> products,
                                                          String query, UserSettings settings) {
                        if (products.isEmpty()) return;
                
                        List<Product> productsToNotify = settings.isNotifyNewOnly() ?
                                UserDataManager.filterNewProducts(userId, products) : products;
                
                        if (productsToNotify.isEmpty()) return;
                
                        logger.info("Sending notifications for {} products to user {}",
                                productsToNotify.size(), userId);
                
                        // Сначала отправляем общее уведомление
                        String summary = String.format(
                                "🔍 Найдено товаров: %d\n📝 По запросу: \"%s\"",
                                productsToNotify.size(), escapeHtml(query)
                        );
                        TelegramNotificationService.sendMessage(userId, summary);
                
                        // Затем отправляем каждый товар
                        for (Product product : productsToNotify) {
                            try {
                                String message = formatProductMessage(product, settings);
                                TelegramNotificationService.sendHtmlMessage(userId, message);
                                Thread.sleep(1000); // Задержка между сообщениями
                            } catch (Exception e) {
                                logger.error("Error sending notification for product {}: {}",
                                        product.getId(), e.getMessage());
                            }
                        }
                    }
                
                    /**
                     * Форматирование сообщения о товаре
                     */
                    private String formatProductMessage(Product product, UserSettings settings) {
                        StringBuilder message = new StringBuilder();
                
                        String title = escapeHtml(product.getTitle());
                        message.append("🛍️ <a href=\"").append(product.getUrl()).append("\">")
                                .append(title).append("</a>\n\n");
                
                        message.append("<b>💰 Цены:</b>\n");
                        message.append("• ").append(product.getPriceDisplay()).append(" (юани)\n");
                
                        if ("rubles".equals(settings.getPriceCurrency())) {
                            message.append("• ").append(product.getPriceDisplayRub()).append(" (рубли)\n");
                        }
                
                        message.append("\n<b>📍 Местоположение:</b> ").append(escapeHtml(product.getLocation())).append("\n");
                        message.append("<b>⏳ Возраст:</b> ").append(product.getAgeDisplay()).append("\n");
                
                        if (product.getSeller() != null && !product.getSeller().isEmpty()) {
                            message.append("<b>👤 Продавец:</b> ").append(escapeHtml(product.getSeller())).append("\n");
                        }
                
                        message.append("\n🔗 <b>Ссылка:</b> <a href=\"").append(product.getUrl())
                                .append("\">").append(product.getUrl()).append("</a>");
                
                        return message.toString();
                    }
                
                    /**
                     * Экранирование HTML символов
                     */
                    private String escapeHtml(String text) {
                        if (text == null) return "";
                
                        return text.replace("&", "&amp;")
                                .replace("<", "&lt;")
                                .replace(">", "&gt;")
                                .replace("\"", "&quot;")
                                .replace("'", "&#39;");
                    }
                
                    /**
                     * Остановка парсера для пользователя
                     */
                    public boolean stopUserParser(long userId) {
                        logger.info("Attempting to stop parser for user {}", userId);
                
                        UserSession session = userSessions.get(userId);
                        if (session != null) {
                            session.setRunning(false);
                            userSessions.remove(userId);
                
                            logger.info("Parser stopped for user {}", userId);
                            TelegramNotificationService.sendMessage(userId, "🛑 Парсер остановлен");
                            return true;
                        }
                
                        logger.warn("No active parser found for user {}", userId);
                        return false;
                    }
                
                    /**
                     * Приостановка парсера для пользователя
                     */
                    public boolean pauseUserParser(long userId) {
                        UserSession session = userSessions.get(userId);
                        if (session != null && session.isRunning()) {
                            session.setPaused(true);
                            logger.info("Parser paused for user {}", userId);
                            return true;
                        }
                        return false;
                    }
                
                    /**
                     * Возобновление парсера для пользователя
                     */
                    public boolean resumeUserParser(long userId) {
                        UserSession session = userSessions.get(userId);
                        if (session != null && session.isPaused()) {
                            session.setPaused(false);
                            logger.info("Parser resumed for user {}", userId);
                            return true;
                        }
                        return false;
                    }
                
                    /**
                     * Получение статуса пользователя
                     */
                    public Map<String, Object> getUserStatus(long userId) {
                        UserSession session = userSessions.get(userId);
                        return session != null ? session.getDetailedStatus() : null;
                    }
                
                    /**
                     * Проверка активности парсера пользователя
                     */
                    public boolean isUserParserRunning(long userId) {
                        UserSession session = userSessions.get(userId);
                        return session != null && session.isRunning();
                    }
                
                    /**
                     * Получение списка активных пользователей
                     */
                    public List<Long> getActiveUsers() {
                        return new ArrayList<>(userSessions.keySet());
                    }
                
                    /**
                     * Получение общей статистики
                     */
                    public Map<String, Object> getGlobalStatistics() {
                        Map<String, Object> stats = new HashMap<>();
                
                        stats.put("totalUsers", userSessions.size());
                        stats.put("totalProductsFound", totalProductsFound);
                        stats.put("totalRequestsMade", totalRequestsMade);
                        stats.put("uptime", System.currentTimeMillis() - startTime.getTime());
                        stats.put("activeThreads", threadPool.getActiveCount());
                        stats.put("poolSize", threadPool.getPoolSize());
                        stats.put("queueSize", threadPool.getQueue().size());
                        stats.put("startTime", startTime);
                
                        return stats;
                    }
                
                    /**
                     * Логирование статистики
                     */
                    private void logStatistics() {
                        if (logger.isInfoEnabled()) {
                            Map<String, Object> stats = getGlobalStatistics();
                            logger.info("Statistics: {} active users, {} total products found, {} active threads",
                                    stats.get("totalUsers"), stats.get("totalProductsFound"),
                                    stats.get("activeThreads"));
                        }
                    }
                
                    /**
                     * Корректное завершение работы
                     */
                    public void shutdown() {
                        logger.info("Shutting down ThreadManager...");
                
                        // Останавливаем все парсеры
                        List<Long> userIds = new ArrayList<>(userSessions.keySet());
                        for (Long userId : userIds) {
                            stopUserParser(userId);
                        }
                
                        // Завершаем пул потоков
                        threadPool.shutdown();
                        scheduler.shutdown();
                
                        try {
                            if (!threadPool.awaitTermination(30, TimeUnit.SECONDS)) {
                                threadPool.shutdownNow();
                            }
                
                            if (!scheduler.awaitTermination(10, TimeUnit.SECONDS)) {
                                scheduler.shutdownNow();
                            }
                
                            logger.info("ThreadManager shutdown complete");
                        } catch (InterruptedException e) {
                            threadPool.shutdownNow();
                            scheduler.shutdownNow();
                            Thread.currentThread().interrupt();
                        }
                    }
                }
                ----------------------------------------
            [DIR] test

              [FILE] CompareWithPython.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/test/CompareWithPython.java
                Размер: 5977 байт
                Дата изменения: 2026-01-18T22:42:01.901639429Z
                Содержимое:
                ----------------------------------------
                package com.parser.test;
                
                import com.fasterxml.jackson.databind.ObjectMapper;
                import com.fasterxml.jackson.databind.ObjectWriter;
                import com.parser.service.CookieService;
                import com.parser.util.HttpUtils;
                import org.json.JSONObject;
                
                import java.util.*;
                
                public class CompareWithPython {
                    public static void main(String[] args) {
                        try {
                            System.out.println("=== Тестирование совместимости с Python-версией ===\n");
                
                            // 1. Проверяем cookies
                            System.out.println("1. Проверка cookies:");
                            CookieService.refreshCookies("goofish");
                            Map<String, String> cookies = CookieService.getCookies("goofish");
                            System.out.println("   Получено cookies: " + cookies.size());
                
                            String mh5tk = cookies.get("_m_h5_tk");
                            System.out.println("   _m_h5_tk: " + (mh5tk != null ? mh5tk.substring(0, Math.min(20, mh5tk.length())) + "..." : "NOT FOUND"));
                
                            // 2. Тестируем POST запрос как в Python
                            System.out.println("\n2. Тестирование POST запроса:");
                
                            long timestamp = System.currentTimeMillis();
                            String token = mh5tk != null && mh5tk.contains("_") ? mh5tk.split("_")[0] : "test";
                
                            // Создаем data как в Python - используем HashMap
                            ObjectMapper mapper = new ObjectMapper();
                            Map<String, Object> data = new LinkedHashMap<>();
                            data.put("pageNumber", 1);
                            data.put("keyword", "test");
                            data.put("fromFilter", false);
                            data.put("rowsPerPage", 10);
                            data.put("sortValue", "new");
                            data.put("sortField", "");
                            data.put("customDistance", "");
                            data.put("gps", "");
                            data.put("propValueStr", new HashMap<>());
                            data.put("customGps", "");
                            data.put("searchReqFromPage", "pcSearch");
                            data.put("extraFilterValue", "{}");
                            data.put("userPositionJson", "{}");
                
                            // Упрощаем сериализацию как в Python
                            String dataStr = mapper.writeValueAsString(data);
                            dataStr = dataStr.replaceAll("\\s+", ""); // Удаляем пробелы
                            System.out.println("   Data string: " + dataStr.substring(0, Math.min(100, dataStr.length())) + "...");
                            System.out.println("   Data string length: " + dataStr.length());
                
                            // 3. Генерируем подпись
                            String signString = token + "&" + timestamp + "&34839810&" + dataStr;
                            System.out.println("   Sign string (first 100 chars): " + signString.substring(0, Math.min(100, signString.length())) + "...");
                
                            String signature = generateMD5(signString);
                            System.out.println("   Signature: " + signature);
                
                            // 4. Формируем запрос
                            String url = "https://h5api.m.goofish.com/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/";
                            StringBuilder formData = new StringBuilder();
                            formData.append("jsv=2.7.2")
                                    .append("&appKey=34839810")
                                    .append("&t=").append(timestamp)
                                    .append("&sign=").append(signature)
                                    .append("&v=1.0")
                                    .append("&type=originaljson")
                                    .append("&accountSite=xianyu")
                                    .append("&dataType=json")
                                    .append("&timeout=20000")
                                    .append("&api=mtop.taobao.idlemtopsearch.pc.search")
                                    .append("&sessionOption=AutoLoginOnly")
                                    .append("&spm_cnt=a21ybx.search.0.0")
                                    .append("&spm_pre=a21ybx.search.searchInput.0")
                                    .append("&data=").append(java.net.URLEncoder.encode(dataStr, "UTF-8"));
                
                            System.out.println("\n3. Отправка запроса...");
                            System.out.println("   URL: " + url);
                            System.out.println("   Form data length: " + formData.length());
                            System.out.println("   Form data preview: " + formData.toString().substring(0, Math.min(200, formData.length())) + "...");
                
                            String response = HttpUtils.sendPostRequest(url, formData.toString());
                
                            System.out.println("   Response length: " + response.length());
                            System.out.println("   Response (first 500 chars): " + response.substring(0, Math.min(500, response.length())) + "...");
                
                            if (response.length() > 0) {
                                JSONObject json = new JSONObject(response);
                                System.out.println("\n4. Анализ ответа:");
                                System.out.println("   Response keys: " + json.keySet());
                
                                if (json.has("ret")) {
                                    Object ret = json.get("ret");
                                    System.out.println("   ret: " + ret);
                                }
                                if (json.has("status")) {
                                    System.out.println("   status: " + json.get("status"));
                                }
                                if (json.has("data")) {
                                    System.out.println("   data exists: true");
                                }
                            } else {
                                System.out.println("\n4. Ответ пустой!");
                            }
                
                        } catch (Exception e) {
                            System.err.println("Ошибка: " + e.getMessage());
                            e.printStackTrace();
                        }
                    }
                
                    private static String generateMD5(String input) {
                        try {
                            java.security.MessageDigest md = java.security.MessageDigest.getInstance("MD5");
                            byte[] hash = md.digest(input.getBytes(java.nio.charset.StandardCharsets.UTF_8));
                            StringBuilder hex = new StringBuilder();
                            for (byte b : hash) {
                                hex.append(String.format("%02x", b));
                            }
                            return hex.toString();
                        } catch (Exception e) {
                            e.printStackTrace();
                            return "";
                        }
                    }
                }
                ----------------------------------------
            [DIR] util

              [FILE] JsonUtils.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/util/JsonUtils.java
                Размер: 3915 байт
                Дата изменения: 2026-01-15T20:12:06.434611249Z
                Содержимое:
                ----------------------------------------
                package com.parser.util;
                
                import com.fasterxml.jackson.databind.ObjectMapper;
                import com.fasterxml.jackson.databind.SerializationFeature;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                /**
                 * Утилиты для работы с JSON
                 */
                public class JsonUtils {
                    private static final Logger logger = LoggerFactory.getLogger(JsonUtils.class);
                    private static final ObjectMapper objectMapper = new ObjectMapper();
                
                    static {
                        objectMapper.enable(SerializationFeature.INDENT_OUTPUT);
                        objectMapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
                    }
                
                    /**
                     * Преобразование объекта в JSON строку
                     */
                    public static String toJson(Object obj) {
                        try {
                            return objectMapper.writeValueAsString(obj);
                        } catch (Exception e) {
                            logger.error("Error converting object to JSON: {}", e.getMessage());
                            return "{}";
                        }
                    }
                
                    /**
                     * Преобразование JSON строки в объект
                     */
                    public static <T> T fromJson(String json, Class<T> clazz) {
                        try {
                            return objectMapper.readValue(json, clazz);
                        } catch (Exception e) {
                            logger.error("Error parsing JSON: {}", e.getMessage());
                            return null;
                        }
                    }
                
                    /**
                     * Проверка валидности JSON строки
                     */
                    public static boolean isValidJson(String json) {
                        try {
                            objectMapper.readTree(json);
                            return true;
                        } catch (Exception e) {
                            return false;
                        }
                    }
                
                    /**
                     * Форматирование JSON строки
                     */
                    public static String formatJson(String json) {
                        try {
                            Object jsonObject = objectMapper.readValue(json, Object.class);
                            return objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(jsonObject);
                        } catch (Exception e) {
                            logger.error("Error formatting JSON: {}", e.getMessage());
                            return json;
                        }
                    }
                
                    /**
                     * Создание JSON из ключ-значение
                     */
                    public static String createJson(String key, String value) {
                        return String.format("{\"%s\": \"%s\"}", key, escapeJson(value));
                    }
                
                    /**
                     * Экранирование строки для JSON
                     */
                    public static String escapeJson(String str) {
                        if (str == null) return "";
                
                        return str.replace("\\", "\\\\")
                                .replace("\"", "\\\"")
                                .replace("\b", "\\b")
                                .replace("\f", "\\f")
                                .replace("\n", "\\n")
                                .replace("\r", "\\r")
                                .replace("\t", "\\t");
                    }
                
                    /**
                     * Получение значения из JSON строки по ключу
                     */
                    public static String getJsonValue(String json, String key) {
                        try {
                            var node = objectMapper.readTree(json);
                            var valueNode = node.get(key);
                            return valueNode != null ? valueNode.asText() : null;
                        } catch (Exception e) {
                            logger.error("Error getting JSON value for key {}: {}", key, e.getMessage());
                            return null;
                        }
                    }
                
                    /**
                     * Обновление значения в JSON строке
                     */
                    public static String updateJsonValue(String json, String key, String value) {
                        try {
                            var node = objectMapper.readTree(json);
                            ((com.fasterxml.jackson.databind.node.ObjectNode) node).put(key, value);
                            return objectMapper.writeValueAsString(node);
                        } catch (Exception e) {
                            logger.error("Error updating JSON value for key {}: {}", key, e.getMessage());
                            return json;
                        }
                    }
                
                    /**
                     * Получение ObjectMapper экземпляра
                     */
                    public static ObjectMapper getObjectMapper() {
                        return objectMapper;
                    }
                }
                ----------------------------------------

              [FILE] HttpUtils.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/util/HttpUtils.java
                Размер: 11168 байт
                Дата изменения: 2026-01-19T07:27:37.265279195Z
                Содержимое:
                ----------------------------------------
                package com.parser.util;
                
                import com.parser.config.Config;
                import com.parser.service.CookieService;
                import org.apache.http.HttpHeaders;
                import org.apache.http.HttpStatus;
                import org.apache.http.client.config.CookieSpecs;
                import org.apache.http.client.config.RequestConfig;
                import org.apache.http.client.methods.CloseableHttpResponse;
                import org.apache.http.client.methods.HttpGet;
                import org.apache.http.client.methods.HttpPost;
                import org.apache.http.entity.StringEntity;
                import org.apache.http.impl.client.CloseableHttpClient;
                import org.apache.http.impl.client.HttpClients;
                import org.apache.http.impl.client.LaxRedirectStrategy;
                import org.apache.http.util.EntityUtils;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.net.URL;
                import java.nio.charset.StandardCharsets;
                import java.util.*;
                
                /**
                 * HTTP утилиты с автоматической подстановкой cookies
                 */
                public class HttpUtils {
                    private static final Logger logger = LoggerFactory.getLogger(HttpUtils.class);
                    private static final Random random = new Random();
                
                    private static final RequestConfig requestConfig = RequestConfig.custom()
                            .setConnectTimeout(Config.getHttpConnectTimeout())
                            .setSocketTimeout(Config.getHttpReadTimeout())
                            .setConnectionRequestTimeout(5000)
                            .setRedirectsEnabled(true)
                            .setCookieSpec(CookieSpecs.STANDARD)
                            .build();
                
                    private static volatile CloseableHttpClient httpClient = null;
                
                    private static synchronized CloseableHttpClient getHttpClient() {
                        if (httpClient == null) {
                            httpClient = HttpClients.custom()
                                    .setDefaultRequestConfig(requestConfig)
                                    .setRedirectStrategy(new LaxRedirectStrategy())
                                    .setMaxConnTotal(100)
                                    .setMaxConnPerRoute(20)
                                    .disableCookieManagement()
                                    .build();
                        }
                        return httpClient;
                    }
                
                    /**
                     * GET запрос с расширенными параметрами
                     */
                    public static String sendGetRequest(String url, String userAgent, boolean useCookies) throws Exception {
                        if (url == null || url.isEmpty()) {
                            throw new IllegalArgumentException("URL cannot be empty");
                        }
                
                        HttpGet request = new HttpGet(url);
                
                        // Добавляем стандартные заголовки
                        request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                        request.setHeader(HttpHeaders.ACCEPT, "application/json, text/plain, */*");
                        request.setHeader(HttpHeaders.ACCEPT_LANGUAGE, "zh-CN,zh;q=0.9,en;q=0.8,ru;q=0.7");
                        request.setHeader(HttpHeaders.ACCEPT_ENCODING, "gzip, deflate, br");
                        request.setHeader(HttpHeaders.CONNECTION, "keep-alive");
                        request.setHeader(HttpHeaders.CACHE_CONTROL, "no-cache");
                        request.setHeader("sec-ch-ua", "\"Google Chrome\";v=\"120\", \"Chromium\";v=\"120\", \"Not?A_Brand\";v=\"24\"");
                        request.setHeader("sec-ch-ua-mobile", "?0");
                        request.setHeader("sec-ch-ua-platform", "\"Windows\"");
                        request.setHeader("sec-fetch-dest", "empty");
                        request.setHeader("sec-fetch-mode", "cors");
                        request.setHeader("sec-fetch-site", "same-site");
                        request.setHeader("x-requested-with", "XMLHttpRequest");
                        request.setHeader("referer", "https://www.goofish.com/");
                        request.setHeader("origin", "https://www.goofish.com");
                
                        // Добавляем cookies
                        if (useCookies) {
                            String cookieHeader = CookieService.getCookieHeader("goofish");
                            if (!cookieHeader.isEmpty()) {
                                request.setHeader("Cookie", cookieHeader);
                                logger.debug("Added Cookie header: {} chars", cookieHeader.length());
                            } else {
                                logger.warn("No cookies available for request");
                            }
                        }
                
                        try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                            int statusCode = response.getStatusLine().getStatusCode();
                            String responseBody = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
                
                            logger.debug("GET Response: status={}, length={}", statusCode, responseBody.length());
                
                            if (statusCode == HttpStatus.SC_OK) {
                                return responseBody;
                            } else if (statusCode == HttpStatus.SC_TOO_MANY_REQUESTS) {
                                throw new Exception("Rate limited (429)");
                            } else if (statusCode == HttpStatus.SC_FORBIDDEN) {
                                logger.warn("Forbidden (403), response preview: {}",
                                        responseBody.substring(0, Math.min(200, responseBody.length())));
                                throw new Exception("Forbidden (403) - Cookies may be invalid");
                            } else if (statusCode == HttpStatus.SC_UNAUTHORIZED) {
                                throw new Exception("Unauthorized (401) - Need to refresh cookies");
                            } else {
                                logger.warn("HTTP error {}: {}", statusCode,
                                        responseBody.substring(0, Math.min(200, responseBody.length())));
                                throw new Exception("HTTP error: " + statusCode);
                            }
                        }
                    }
                
                    /**
                     * POST запрос
                     */
                    public static String sendPostRequest(String url, String formData) throws Exception {
                        return sendPostRequest(url, formData, getDefaultUserAgent(), true);
                    }
                
                    /**
                     * POST запрос с расширенными параметрами
                     */
                    public static String sendPostRequest(String url, String formData, String userAgent, boolean useCookies) throws Exception {
                        HttpPost request = new HttpPost(url);
                
                        // Заголовки для Goofish API
                        request.setHeader(HttpHeaders.USER_AGENT, userAgent != null ? userAgent : getDefaultUserAgent());
                        request.setHeader(HttpHeaders.CONTENT_TYPE, "application/x-www-form-urlencoded; charset=UTF-8");
                        request.setHeader(HttpHeaders.ACCEPT, "application/json, text/plain, */*");
                        request.setHeader(HttpHeaders.ACCEPT_LANGUAGE, "zh-CN,zh;q=0.9,en;q=0.8,ru;q=0.7");
                        request.setHeader(HttpHeaders.ACCEPT_ENCODING, "gzip, deflate, br");
                        request.setHeader(HttpHeaders.CONNECTION, "keep-alive");
                        request.setHeader("sec-ch-ua", "\"Google Chrome\";v=\"120\", \"Chromium\";v=\"120\", \"Not?A_Brand\";v=\"24\"");
                        request.setHeader("sec-ch-ua-mobile", "?0");
                        request.setHeader("sec-ch-ua-platform", "\"Windows\"");
                        request.setHeader("sec-fetch-dest", "empty");
                        request.setHeader("sec-fetch-mode", "cors");
                        request.setHeader("sec-fetch-site", "same-site");
                        request.setHeader("x-requested-with", "XMLHttpRequest");
                        request.setHeader("referer", "https://www.goofish.com/");
                        request.setHeader("origin", "https://www.goofish.com");
                
                        // Добавляем cookies
                        if (useCookies) {
                            String cookieHeader = CookieService.getCookieHeader("goofish");
                            if (!cookieHeader.isEmpty()) {
                                request.setHeader("Cookie", cookieHeader);
                                logger.debug("POST Cookie header: {} chars", cookieHeader.length());
                            } else {
                                logger.warn("No cookies available for POST request");
                            }
                        }
                
                        if (formData != null && !formData.isEmpty()) {
                            request.setEntity(new StringEntity(formData, StandardCharsets.UTF_8));
                            logger.debug("POST body length: {}", formData.length());
                        }
                
                        try (CloseableHttpResponse response = getHttpClient().execute(request)) {
                            int statusCode = response.getStatusLine().getStatusCode();
                            String responseBody = EntityUtils.toString(response.getEntity(), StandardCharsets.UTF_8);
                
                            logger.debug("POST Response: status={}, length={}", statusCode, responseBody.length());
                
                            if (statusCode == HttpStatus.SC_OK) {
                                return responseBody;
                            } else if (statusCode == HttpStatus.SC_TOO_MANY_REQUESTS) {
                                throw new Exception("Rate limited (429)");
                            } else if (statusCode == HttpStatus.SC_FORBIDDEN) {
                                logger.warn("POST Forbidden (403), response preview: {}",
                                        responseBody.substring(0, Math.min(200, responseBody.length())));
                                throw new Exception("Forbidden (403) - Cookies may be invalid");
                            } else {
                                logger.warn("HTTP POST error {}: {}", statusCode,
                                        responseBody.substring(0, Math.min(200, responseBody.length())));
                                throw new Exception("HTTP POST error: " + statusCode);
                            }
                        }
                    }
                
                    /**
                     * Извлечь домен из URL
                     */
                    public static String extractDomain(String url) {
                        try {
                            return new URL(url).getHost();
                        } catch (Exception e) {
                            logger.warn("Failed to extract domain from URL: {}", url);
                            return "";
                        }
                    }
                
                    /**
                     * Получить стандартный User-Agent
                     */
                    public static String getDefaultUserAgent() {
                        return Config.getHttpUserAgent();
                    }
                
                    /**
                     * Получить случайный User-Agent
                     */
                    public static String getRandomUserAgent() {
                        String[] agents = {
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0",
                                "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                                "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
                        };
                        return agents[random.nextInt(agents.length)];
                    }
                
                    /**
                     * Построить URL с параметрами
                     */
                    public static String buildUrlWithParams(String baseUrl, Map<String, String> params) {
                        if (params == null || params.isEmpty()) {
                            return baseUrl;
                        }
                
                        StringBuilder url = new StringBuilder(baseUrl).append("?");
                        boolean first = true;
                
                        for (Map.Entry<String, String> entry : params.entrySet()) {
                            if (!first) {
                                url.append("&");
                            }
                            try {
                                url.append(entry.getKey()).append("=")
                                        .append(java.net.URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8));
                            } catch (Exception e) {
                                url.append(entry.getKey()).append("=").append(entry.getValue());
                            }
                            first = false;
                        }
                
                        return url.toString();
                    }
                
                    /**
                     * Закрыть HTTP клиент
                     */
                    public static void closeHttpClient() {
                        if (httpClient != null) {
                            try {
                                httpClient.close();
                                httpClient = null;
                            } catch (Exception e) {
                                logger.error("Error closing HTTP client: {}", e.getMessage());
                            }
                        }
                    }
                }
                ----------------------------------------
            [DIR] config

              [FILE] ParserSettings.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/config/ParserSettings.java
                Размер: 2555 байт
                Дата изменения: 2026-01-18T21:00:23.688367899Z
                Содержимое:
                ----------------------------------------
                package com.parser.config;
                
                /**
                 * Класс с константами для настроек парсера
                 */
                public class ParserSettings {
                    // Минимальные и максимальные значения для валидации
                    public static final int MIN_CHECK_INTERVAL = 20; // секунд
                    public static final int MAX_CHECK_INTERVAL = 3600; // секунд
                
                    public static final int MIN_MAX_AGE_MINUTES = 1;
                    public static final int MAX_MAX_AGE_MINUTES = 10080; // 7 дней
                
                    public static final int MIN_MAX_PAGES = 1;
                    public static final int MAX_MAX_PAGES = 50;
                
                    public static final int MIN_ROWS_PER_PAGE = 10;
                    public static final int MAX_ROWS_PER_PAGE = 1000;
                
                    // Коды валют
                    public static final String CURRENCY_YUAN = "yuan";
                    public static final String CURRENCY_RUBLES = "rubles";
                
                    // Статусы парсера
                    public static final String STATUS_RUNNING = "running";
                    public static final String STATUS_STOPPED = "stopped";
                    public static final String STATUS_PAUSED = "paused";
                    public static final String STATUS_ERROR = "error";
                
                    /**
                     * Валидация интервала проверки
                     */
                    public static boolean isValidCheckInterval(int interval) {
                        return interval >= MIN_CHECK_INTERVAL && interval <= MAX_CHECK_INTERVAL;
                    }
                
                    /**
                     * Валидация максимального возраста товара
                     */
                    public static boolean isValidMaxAge(int maxAge) {
                        return maxAge >= MIN_MAX_AGE_MINUTES && maxAge <= MAX_MAX_AGE_MINUTES;
                    }
                
                    /**
                     * Нормализация интервала проверки
                     */
                    public static int normalizeCheckInterval(int interval) {
                        return Math.max(MIN_CHECK_INTERVAL, Math.min(interval, MAX_CHECK_INTERVAL));
                    }
                
                    /**
                     * Нормализация максимального возраста
                     */
                    public static int normalizeMaxAge(int maxAge) {
                        return Math.max(MIN_MAX_AGE_MINUTES, Math.min(maxAge, MAX_MAX_AGE_MINUTES));
                    }
                
                    /**
                     * Получение курса валюты
                     */
                    public static double getCurrencyRate(String fromCurrency, String toCurrency) {
                        if (CURRENCY_YUAN.equals(fromCurrency) && CURRENCY_RUBLES.equals(toCurrency)) {
                            return 14.0; // Курс юаня к рублю
                        } else if (CURRENCY_RUBLES.equals(fromCurrency) && CURRENCY_YUAN.equals(toCurrency)) {
                            return 1.0 / 14.0; // Обратный курс
                        }
                        return 1.0;
                    }
                }
                ----------------------------------------

              [FILE] Config.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/config/Config.java
                Размер: 12251 байт
                Дата изменения: 2026-01-18T21:28:36.602753721Z
                Содержимое:
                ----------------------------------------
                package com.parser.config;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.*;
                import java.util.Properties;
                
                /**
                 * Класс для управления конфигурацией приложения
                 */
                public class Config {
                    private static final Logger logger = LoggerFactory.getLogger(Config.class);
                    private static final Properties properties = new Properties();
                    private static final String CONFIG_FILE = "config.properties";
                    private static volatile boolean isLoaded = false;
                
                    static {
                        synchronized (Config.class) {
                            if (!isLoaded) {
                                loadProperties();
                                isLoaded = true;
                            }
                        }
                    }
                
                    /**
                     * Загрузка свойств из файла конфигурации
                     */
                    private static void loadProperties() {
                        File externalConfig = new File(CONFIG_FILE);
                        if (externalConfig.exists() && externalConfig.isFile()) {
                            try (InputStream input = new FileInputStream(externalConfig)) {
                                properties.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded configuration from external file: {}", CONFIG_FILE);
                                return;
                            } catch (IOException e) {
                                logger.warn("Failed to load external config file: {}", e.getMessage());
                            }
                        }
                
                        try (InputStream input = Thread.currentThread().getContextClassLoader().getResourceAsStream(CONFIG_FILE)) {
                            if (input != null) {
                                properties.load(new InputStreamReader(input, "UTF-8"));
                                logger.info("Loaded configuration from resources: {}", CONFIG_FILE);
                            } else {
                                setDefaults();
                                logger.warn("Config file not found, using defaults");
                            }
                        } catch (IOException e) {
                            setDefaults();
                            logger.error("Error loading config from resources: {}", e.getMessage(), e);
                        }
                    }
                
                    /**
                     * Установка значений по умолчанию
                     */
                    private static void setDefaults() {
                        // Telegram
                        properties.setProperty("telegram.bot.token", "");
                        properties.setProperty("telegram.bot.username", "");
                        properties.setProperty("telegram.admin.id", "0");
                
                        // Parser
                        properties.setProperty("parser.default.check_interval", "300");
                        properties.setProperty("parser.default.max_age_minutes", "1440");
                        properties.setProperty("parser.default.max_pages", "3");
                        properties.setProperty("parser.default.rows_per_page", "100");
                        properties.setProperty("parser.default.notify_new_only", "true");
                
                        // Thread Pool
                        properties.setProperty("thread.pool.core.size", "5");
                        properties.setProperty("thread.pool.max.size", "20");
                        properties.setProperty("thread.pool.queue.capacity", "100");
                        properties.setProperty("thread.pool.keepalive.seconds", "60");
                
                        // Storage
                        properties.setProperty("storage.data.dir", "./data");
                        properties.setProperty("storage.backup.enabled", "true");
                
                        // HTTP
                        properties.setProperty("http.connect.timeout", "10000");
                        properties.setProperty("http.read.timeout", "15000");
                        properties.setProperty("http.user.agent",
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36");
                        properties.setProperty("http.max.retries", "3");
                
                        // Cookie configuration
                        properties.setProperty("cookie.update.interval.hours", "6");
                        properties.setProperty("cookie.auto.update", "true");
                        properties.setProperty("cookie.selenium.headless", "true");
                        properties.setProperty("cookie.dynamic.enabled", "true");
                
                        // Logging
                        properties.setProperty("logging.level", "INFO");
                        properties.setProperty("logging.file", "parser.log");
                
                        // Supported sites
                        properties.setProperty("sites.supported", "goofish");
                        properties.setProperty("site.goofish.name", "Goofish");
                        properties.setProperty("site.goofish.base_url", "https://h5api.m.goofish.com");
                        properties.setProperty("site.goofish.search_endpoint", "/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/");
                        properties.setProperty("site.goofish.app_key", "34839810");
                        properties.setProperty("site.goofish.delay_between_requests", "2000");
                    }
                
                    /**
                     * Получение целочисленного значения
                     */
                    public static int getInt(String key, int defaultValue) {
                        try {
                            return Integer.parseInt(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid integer value for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    /**
                     * Получение строкового значения
                     */
                    public static String getString(String key, String defaultValue) {
                        String value = properties.getProperty(key, defaultValue);
                        return value != null ? value.trim() : defaultValue;
                    }
                
                    /**
                     * Получение булевого значения
                     */
                    public static boolean getBoolean(String key, boolean defaultValue) {
                        String value = properties.getProperty(key, String.valueOf(defaultValue));
                        if (value == null) return defaultValue;
                
                        value = value.trim().toLowerCase();
                        return value.equals("true") || value.equals("yes") || value.equals("1");
                    }
                
                    /**
                     * Получение значения с плавающей точкой
                     */
                    public static double getDouble(String key, double defaultValue) {
                        try {
                            return Double.parseDouble(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid double value for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    /**
                     * Получение long значения
                     */
                    public static long getLong(String key, long defaultValue) {
                        try {
                            return Long.parseLong(properties.getProperty(key, String.valueOf(defaultValue)).trim());
                        } catch (NumberFormatException e) {
                            logger.warn("Invalid long value for key '{}', using default: {}", key, defaultValue);
                            return defaultValue;
                        }
                    }
                
                    /**
                     * Сохранение конфигурации в файл
                     */
                    public static void saveConfig() {
                        File externalConfig = new File(CONFIG_FILE);
                        try (OutputStream output = new FileOutputStream(externalConfig)) {
                            properties.store(output, "Multi-Parser Configuration\nAuto-generated configuration");
                            logger.info("Configuration saved to: {}", CONFIG_FILE);
                        } catch (IOException e) {
                            logger.error("Failed to save configuration: {}", e.getMessage(), e);
                        }
                    }
                
                    /**
                     * Установка значения свойства
                     */
                    public static void setProperty(String key, String value) {
                        properties.setProperty(key, value);
                    }
                
                    /**
                     * Получение всех свойств
                     */
                    public static Properties getAllProperties() {
                        return new Properties(properties);
                    }
                
                    /**
                     * Релоад конфигурации
                     */
                    public static void reload() {
                        synchronized (Config.class) {
                            properties.clear();
                            loadProperties();
                            logger.info("Configuration reloaded");
                        }
                    }
                
                    // ============ Методы для получения конкретных параметров ============
                
                    public static String getTelegramBotToken() {
                        return getString("telegram.bot.token", "");
                    }
                
                    public static String getTelegramBotUsername() {
                        return getString("telegram.bot.username", "");
                    }
                
                    public static long getTelegramAdminId() {
                        return getLong("telegram.admin.id", 0L);
                    }
                
                    public static int getThreadPoolCoreSize() {
                        return getInt("thread.pool.core.size", 5);
                    }
                
                    public static int getThreadPoolMaxSize() {
                        return getInt("thread.pool.max.size", 20);
                    }
                
                    public static int getThreadPoolKeepAlive() {
                        return getInt("thread.pool.keepalive.seconds", 60);
                    }
                
                    public static int getThreadPoolQueueCapacity() {
                        return getInt("thread.pool.queue.capacity", 100);
                    }
                
                    public static int getHttpConnectTimeout() {
                        return getInt("http.connect.timeout", 10000);
                    }
                
                    public static int getHttpReadTimeout() {
                        return getInt("http.read.timeout", 15000);
                    }
                
                    public static String getHttpUserAgent() {
                        return getString("http.user.agent",
                                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36");
                    }
                
                    public static int getHttpMaxRetries() {
                        return getInt("http.max.retries", 3);
                    }
                
                    public static String getStorageDataDir() {
                        return getString("storage.data.dir", "./data");
                    }
                
                    public static boolean isStorageBackupEnabled() {
                        return getBoolean("storage.backup.enabled", true);
                    }
                
                    public static int getCookieUpdateIntervalHours() {
                        return getInt("cookie.update.interval.hours", 6);
                    }
                
                    public static boolean isCookieAutoUpdate() {
                        return getBoolean("cookie.auto.update", true);
                    }
                
                    public static boolean isSeleniumHeadless() {
                        return getBoolean("cookie.selenium.headless", true);
                    }
                
                    public static boolean isDynamicCookiesEnabled() {
                        return getBoolean("cookie.dynamic.enabled", true);
                    }
                
                    public static String getLoggingLevel() {
                        return getString("logging.level", "INFO");
                    }
                
                    public static String getLoggingFile() {
                        return getString("logging.file", "parser.log");
                    }
                
                    public static int getDefaultCheckInterval() {
                        return getInt("parser.default.check_interval", 300);
                    }
                
                    public static int getDefaultMaxAgeMinutes() {
                        return getInt("parser.default.max_age_minutes", 1440);
                    }
                
                    public static int getDefaultMaxPages() {
                        return getInt("parser.default.max_pages", 3);
                    }
                
                    public static int getDefaultRowsPerPage() {
                        return getInt("parser.default.rows_per_page", 100);
                    }
                
                    public static boolean getDefaultNotifyNewOnly() {
                        return getBoolean("parser.default.notify_new_only", true);
                    }
                
                    /**
                     * Получение списка поддерживаемых сайтов
                     */
                    public static String[] getSupportedSites() {
                        String sites = getString("sites.supported", "goofish");
                        return sites.split(",");
                    }
                
                    /**
                     * Получение конфигурации для конкретного сайта
                     */
                    public static SiteConfig getSiteConfig(String siteName) {
                        String baseUrl = getString("site." + siteName + ".base_url", "");
                        String searchEndpoint = getString("site." + siteName + ".search_endpoint", "");
                        String appKey = getString("site." + siteName + ".app_key", "");
                        int delay = getInt("site." + siteName + ".delay_between_requests", 2000);
                
                        return new SiteConfig(siteName, baseUrl, searchEndpoint, appKey, delay);
                    }
                
                    /**
                     * Класс для хранения конфигурации сайта
                     */
                    public static class SiteConfig {
                        private final String name;
                        private final String baseUrl;
                        private final String searchEndpoint;
                        private final String appKey;
                        private final int requestDelay;
                
                        public SiteConfig(String name, String baseUrl, String searchEndpoint, String appKey, int requestDelay) {
                            this.name = name;
                            this.baseUrl = baseUrl;
                            this.searchEndpoint = searchEndpoint;
                            this.appKey = appKey;
                            this.requestDelay = requestDelay;
                        }
                
                        public String getName() { return name; }
                        public String getBaseUrl() { return baseUrl; }
                        public String getSearchEndpoint() { return searchEndpoint; }
                        public String getAppKey() { return appKey; }
                        public int getRequestDelay() { return requestDelay; }
                    }
                }
                ----------------------------------------
            [DIR] parser

              [FILE] ParserFactory.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/ParserFactory.java
                Размер: 4110 байт
                Дата изменения: 2026-01-18T21:03:00.008354051Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import com.parser.config.Config;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.util.HashMap;
                import java.util.Map;
                
                /**
                 * Фабрика для создания парсеров различных сайтов
                 */
                public class ParserFactory {
                    private static final Logger logger = LoggerFactory.getLogger(ParserFactory.class);
                
                    private static final Map<String, Class<? extends SiteParser>> parsers = new HashMap<>();
                    private static final Map<String, SiteParser> parserInstances = new HashMap<>();
                
                    static {
                        // Регистрируем парсеры для поддерживаемых сайтов
                        for (String site : Config.getSupportedSites()) {
                            switch (site.toLowerCase()) {
                                case "goofish":
                                    registerParser(site, com.parser.parser.goofish.GoofishParser.class);
                                    break;
                                // Здесь можно добавить регистрацию парсеров для других сайтов
                            }
                        }
                    }
                
                    /**
                     * Регистрация парсера
                     */
                    public static void registerParser(String siteName, Class<? extends SiteParser> parserClass) {
                        String key = siteName.toLowerCase();
                        parsers.put(key, parserClass);
                        logger.info("Registered parser for site: {}", siteName);
                    }
                
                    /**
                     * Создание парсера для указанного сайта
                     */
                    public static SiteParser createParser(String siteName) {
                        String key = siteName.toLowerCase();
                
                        if (!parsers.containsKey(key)) {
                            logger.error("No parser registered for site: {}", siteName);
                            throw new IllegalArgumentException("Unsupported site: " + siteName);
                        }
                
                        try {
                            if (!parserInstances.containsKey(key)) {
                                Class<? extends SiteParser> parserClass = parsers.get(key);
                                SiteParser parser = parserClass.getDeclaredConstructor().newInstance();
                                parserInstances.put(key, parser);
                                logger.debug("Created new parser instance for site: {}", siteName);
                            }
                
                            return parserInstances.get(key);
                
                        } catch (Exception e) {
                            logger.error("Failed to create parser for site {}: {}", siteName, e.getMessage(), e);
                            throw new RuntimeException("Failed to create parser for site: " + siteName, e);
                        }
                    }
                
                    /**
                     * Проверка наличия парсера для сайта
                     */
                    public static boolean hasParser(String siteName) {
                        return parsers.containsKey(siteName.toLowerCase());
                    }
                
                    /**
                     * Получение списка поддерживаемых сайтов
                     */
                    public static String[] getSupportedSites() {
                        return parsers.keySet().toArray(new String[0]);
                    }
                
                    /**
                     * Получение информации о всех зарегистрированных парсерах
                     */
                    public static Map<String, String> getParserInfo() {
                        Map<String, String> info = new HashMap<>();
                
                        for (Map.Entry<String, Class<? extends SiteParser>> entry : parsers.entrySet()) {
                            info.put(entry.getKey(), entry.getValue().getSimpleName());
                        }
                
                        return info;
                    }
                
                    /**
                     * Очистка кэша парсеров
                     */
                    public static void clearCache() {
                        int count = parserInstances.size();
                        parserInstances.clear();
                        logger.info("Cleared parser cache ({} instances)", count);
                    }
                
                    /**
                     * Получение статистики по всем парсерам
                     */
                    public static Map<String, Object> getParsersStats() {
                        Map<String, Object> stats = new HashMap<>();
                
                        for (Map.Entry<String, SiteParser> entry : parserInstances.entrySet()) {
                            if (entry.getValue() instanceof BaseParser) {
                                BaseParser parser = (BaseParser) entry.getValue();
                                stats.put(entry.getKey(), parser.getStats());
                            }
                        }
                
                        return stats;
                    }
                }
                ----------------------------------------
              [DIR] goofish

                [FILE] GoofishParser.java
                  Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/goofish/GoofishParser.java
                  Размер: 14825 байт
                  Дата изменения: 2026-01-19T07:38:41.129810751Z
                  Содержимое:
                  ----------------------------------------
                  package com.parser.parser.goofish;
                  
                  import com.parser.model.Product;
                  import com.parser.parser.BaseParser;
                  import com.parser.service.CookieService;
                  import com.parser.util.HttpUtils;
                  import org.json.JSONArray;
                  import org.json.JSONObject;
                  import org.slf4j.Logger;
                  import org.slf4j.LoggerFactory;
                  
                  import java.nio.charset.StandardCharsets;
                  import java.security.MessageDigest;
                  import java.util.*;
                  
                  /**
                   * Парсер для Goofish - ФИНАЛЬНАЯ ВЕРСИЯ
                   */
                  public class GoofishParser extends BaseParser {
                      private static final Logger logger = LoggerFactory.getLogger(GoofishParser.class);
                  
                      private static final String BASE_URL = "https://h5api.m.goofish.com";
                      private static final String SEARCH_ENDPOINT = "/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/";
                      private static final String APP_KEY = "34839810";
                      private static final int REQUEST_DELAY = 3000; // 3 секунды между запросами
                  
                      public GoofishParser() {
                          super("goofish", BASE_URL);
                      }
                  
                      @Override
                      public List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes) {
                          List<Product> allProducts = new ArrayList<>();
                          long startTime = System.currentTimeMillis();
                  
                          logger.info("Starting search for '{}' on {}, pages: {}, rows: {}, max age: {}min",
                                  query, siteName, maxPages, rowsPerPage, maxAgeMinutes);
                  
                          // Проверяем cookies перед началом
                          Map<String, String> cookies = CookieService.getCookies("goofish");
                          if (cookies.isEmpty()) {
                              logger.error("No cookies available! Please refresh cookies first.");
                              return allProducts;
                          }
                  
                          logger.info("Using {} cookies for search", cookies.size());
                  
                          for (int page = 1; page <= maxPages; page++) {
                              try {
                                  logger.debug("Processing page {} for query '{}'", page, query);
                  
                                  String url = BASE_URL + SEARCH_ENDPOINT;
                                  String requestBody = buildPostRequestBody(query, page, rowsPerPage);
                  
                                  if (requestBody == null || requestBody.isEmpty()) {
                                      logger.error("Failed to build request body");
                                      continue;
                                  }
                  
                                  long requestStartTime = System.currentTimeMillis();
                                  String response = HttpUtils.sendPostRequest(url, requestBody);
                                  totalRequests++;
                  
                                  long requestTime = System.currentTimeMillis() - requestStartTime;
                                  logger.debug("Page {} fetched in {}ms", page, requestTime);
                  
                                  List<Product> products = parseResponse(response, query);
                  
                                  if (products.isEmpty()) {
                                      logger.debug("No products found on page {}", page);
                                      break;
                                  }
                  
                                  // Фильтрация по возрасту
                                  List<Product> filtered = new ArrayList<>();
                                  for (Product product : products) {
                                      if (product.getAgeMinutes() <= maxAgeMinutes) {
                                          filtered.add(product);
                                      }
                                  }
                  
                                  allProducts.addAll(filtered);
                                  logger.info("Page {}: found {} products ({} after age filter)",
                                          page, products.size(), filtered.size());
                  
                                  if (filtered.size() < rowsPerPage / 2) {
                                      logger.debug("Less than half expected, probably last page");
                                      break;
                                  }
                  
                                  // Задержка между страницами
                                  if (page < maxPages) {
                                      Thread.sleep(REQUEST_DELAY);
                                  }
                  
                              } catch (Exception e) {
                                  failedRequests++;
                                  logger.error("Error parsing page {}: {}", page, e.getMessage());
                  
                                  if (shouldStopOnError(e)) {
                                      logger.warn("Stopping search due to critical error");
                                      break;
                                  }
                  
                                  try {
                                      Thread.sleep(5000); // 5 секунд при ошибке
                                  } catch (InterruptedException ie) {
                                      Thread.currentThread().interrupt();
                                      break;
                                  }
                              }
                          }
                  
                          long totalTime = System.currentTimeMillis() - startTime;
                          logger.info("Search completed for '{}': found {} products in {}ms ({} requests)",
                                  query, allProducts.size(), totalTime, totalRequests);
                  
                          return allProducts;
                      }
                  
                      /**
                       * Построение тела POST запроса
                       */
                      private String buildPostRequestBody(String query, int page, int rows) {
                          try {
                              long timestamp = System.currentTimeMillis();
                              String token = getToken();
                  
                              if (token == null || token.isEmpty()) {
                                  logger.error("Token is null or empty - cookies may be invalid!");
                                  return "";
                              }
                  
                              logger.debug("Using token: {}...", token.substring(0, Math.min(10, token.length())));
                  
                              // Создаем data как в Python
                              Map<String, Object> data = new LinkedHashMap<>();
                              data.put("pageNumber", page);
                              data.put("keyword", query);
                              data.put("fromFilter", false);
                              data.put("rowsPerPage", rows);
                              data.put("sortValue", "new");
                              data.put("sortField", "");
                              data.put("customDistance", "");
                              data.put("gps", "");
                              data.put("propValueStr", new LinkedHashMap<>());
                              data.put("customGps", "");
                              data.put("searchReqFromPage", "pcSearch");
                              data.put("extraFilterValue", "{}");
                              data.put("userPositionJson", "{}");
                  
                              String dataStr = new org.json.JSONObject(data).toString();
                  
                              // Генерация подписи
                              String signString = token + "&" + timestamp + "&" + APP_KEY + "&" + dataStr;
                              String signature = generateSignature(signString);
                  
                              // Создаем параметры
                              Map<String, String> params = new LinkedHashMap<>();
                              params.put("jsv", "2.7.2");
                              params.put("appKey", APP_KEY);
                              params.put("t", String.valueOf(timestamp));
                              params.put("sign", signature);
                              params.put("v", "1.0");
                              params.put("type", "originaljson");
                              params.put("accountSite", "xianyu");
                              params.put("dataType", "json");
                              params.put("timeout", "20000");
                              params.put("api", "mtop.taobao.idlemtopsearch.pc.search");
                              params.put("sessionOption", "AutoLoginOnly");
                              params.put("spm_cnt", "a21ybx.search.0.0");
                              params.put("spm_pre", "a21ybx.search.searchInput.0");
                              params.put("data", dataStr);
                  
                              // Собираем query string
                              StringBuilder queryString = new StringBuilder();
                              boolean first = true;
                              for (Map.Entry<String, String> entry : params.entrySet()) {
                                  if (!first) {
                                      queryString.append("&");
                                  }
                                  queryString.append(entry.getKey())
                                          .append("=")
                                          .append(java.net.URLEncoder.encode(entry.getValue(), StandardCharsets.UTF_8));
                                  first = false;
                              }
                  
                              return queryString.toString();
                  
                          } catch (Exception e) {
                              logger.error("Error building POST request body: {}", e.getMessage(), e);
                              return "";
                          }
                      }
                  
                      private String generateSignature(String input) {
                          try {
                              MessageDigest md = MessageDigest.getInstance("MD5");
                              byte[] hash = md.digest(input.getBytes(StandardCharsets.UTF_8));
                  
                              StringBuilder hex = new StringBuilder();
                              for (byte b : hash) {
                                  hex.append(String.format("%02x", b));
                              }
                              return hex.toString();
                          } catch (Exception e) {
                              logger.error("Error generating signature: {}", e.getMessage());
                              return "";
                          }
                      }
                  
                      @Override
                      protected List<Product> parseResponse(String response, String query) {
                          List<Product> products = new ArrayList<>();
                  
                          if (response == null || response.isEmpty()) {
                              logger.warn("Empty response");
                              return products;
                          }
                  
                          try {
                              JSONObject json = new JSONObject(response);
                  
                              // Проверяем ret
                              if (json.has("ret")) {
                                  JSONArray retArray = json.optJSONArray("ret");
                                  if (retArray != null && retArray.length() > 0) {
                                      String error = retArray.getString(0);
                                      logger.debug("API ret: {}", error);
                  
                                      if (error.contains("RGV587_ERROR") || error.contains("被挤爆啦")) {
                                          logger.error("❌ RATE LIMIT! Cookies are INVALID or EXPIRED!");
                                          logger.error("Please run: /cookies refresh goofish");
                                          return products;
                                      }
                  
                                      if (!error.contains("SUCCESS")) {
                                          logger.error("API Error: {}", error);
                                          return products;
                                      }
                                  }
                              }
                  
                              // Получение данных
                              JSONObject data = json.optJSONObject("data");
                              if (data == null) {
                                  logger.warn("No data in response");
                                  return products;
                              }
                  
                              JSONArray items = data.optJSONArray("resultList");
                              if (items == null || items.length() == 0) {
                                  logger.info("No products found in response");
                                  return products;
                              }
                  
                              logger.info("Found {} items in API response", items.length());
                  
                              // Парсим товары
                              for (int i = 0; i < items.length(); i++) {
                                  try {
                                      JSONObject item = items.getJSONObject(i);
                                      Product product = parseProduct(item, query);
                  
                                      if (product != null && isValid(product)) {
                                          products.add(product);
                                      }
                                  } catch (Exception e) {
                                      logger.debug("Error parsing item {}: {}", i, e.getMessage());
                                  }
                              }
                  
                              logger.info("Successfully parsed {} products", products.size());
                  
                          } catch (Exception e) {
                              logger.error("Error parsing response: {}", e.getMessage(), e);
                          }
                  
                          return products;
                      }
                  
                      private Product parseProduct(JSONObject item, String query) {
                          try {
                              JSONObject itemData = item.optJSONObject("data");
                              if (itemData == null) return null;
                  
                              JSONObject itemObj = itemData.optJSONObject("item");
                              if (itemObj == null) return null;
                  
                              JSONObject mainObj = itemObj.optJSONObject("main");
                              if (mainObj == null) return null;
                  
                              JSONObject clickParam = mainObj.optJSONObject("clickParam");
                              if (clickParam == null) return null;
                  
                              JSONObject args = clickParam.optJSONObject("args");
                              if (args == null) return null;
                  
                              String itemId = args.optString("id", "");
                              if (itemId.isEmpty()) return null;
                  
                              String title = args.optString("title", "");
                              if (title.isEmpty()) return null;
                  
                              String priceStr = args.optString("price", "0");
                              double price = 0.0;
                              try {
                                  priceStr = priceStr.replaceAll("[^\\d.]", "");
                                  price = Double.parseDouble(priceStr);
                              } catch (Exception e) {
                                  // Ignore
                              }
                  
                              String location = args.optString("area", "Unknown");
                  
                              String publishTimeStr = args.optString("publishTime", "0");
                              int ageMinutes = 1;
                  
                              try {
                                  long publishTime = Long.parseLong(publishTimeStr);
                                  if (publishTime > 0) {
                                      long currentTime = System.currentTimeMillis();
                                      ageMinutes = (int) ((currentTime - publishTime) / (1000 * 60));
                                      ageMinutes = Math.max(1, Math.min(ageMinutes, 10080));
                                  }
                              } catch (Exception e) {
                                  // Use default
                              }
                  
                              List<String> images = new ArrayList<>();
                              String picUrl = args.optString("picUrl", "");
                              if (!picUrl.isEmpty() && picUrl.startsWith("http")) {
                                  images.add(picUrl);
                              }
                  
                              Product product = new Product();
                              product.setId(itemId);
                              product.setTitle(title);
                              product.setPrice(price);
                              product.setUrl("https://www.goofish.com/item?id=" + itemId);
                              product.setSite("goofish");
                              product.setLocation(location);
                              product.setAgeMinutes(ageMinutes);
                              product.setQuery(query);
                  
                              if (!images.isEmpty()) {
                                  for (String image : images) {
                                      product.addImage(image);
                                  }
                              }
                  
                              return product;
                  
                          } catch (Exception e) {
                              return null;
                          }
                      }
                  
                      private String getToken() {
                          try {
                              Map<String, String> cookies = CookieService.getCookies("goofish");
                              if (cookies == null || cookies.isEmpty()) {
                                  logger.warn("No cookies available");
                                  return "";
                              }
                  
                              String mh5tk = cookies.get("_m_h5_tk");
                              if (mh5tk == null || mh5tk.isEmpty()) {
                                  logger.warn("_m_h5_tk cookie not found");
                                  return "";
                              }
                  
                              if (mh5tk.contains("_")) {
                                  String token = mh5tk.split("_")[0];
                                  logger.debug("Extracted token from _m_h5_tk");
                                  return token;
                              }
                  
                              return mh5tk;
                  
                          } catch (Exception e) {
                              logger.error("Error getting token: {}", e.getMessage());
                              return "";
                          }
                      }
                  
                      private boolean isValid(Product product) {
                          return product != null
                                  && product.getId() != null && !product.getId().isEmpty()
                                  && product.getTitle() != null && !product.getTitle().isEmpty()
                                  && product.getPrice() >= 0;
                      }
                  
                      @Override
                      protected String buildSearchUrl(String query, int page, int rows) {
                          return "";
                      }
                  
                      @Override
                      protected int getRequestDelay() {
                          return REQUEST_DELAY;
                      }
                  
                      @Override
                      protected boolean shouldStopOnError(Exception e) {
                          String msg = e.getMessage();
                          return msg != null && (msg.contains("429") || msg.contains("403"));
                      }
                  }
                  ----------------------------------------

              [FILE] BaseParser.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/BaseParser.java
                Размер: 6881 байт
                Дата изменения: 2026-01-18T21:41:28.278241425Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import com.parser.model.Product;
                import com.parser.util.HttpUtils;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.util.ArrayList;
                import java.util.List;
                
                /**
                 * Абстрактный базовый класс для всех парсеров сайтов
                 */
                public abstract class BaseParser implements SiteParser {
                    protected static final Logger logger = LoggerFactory.getLogger(BaseParser.class);
                
                    protected String siteName;
                    protected String baseUrl;
                    protected String userAgent;
                
                    // Статистика
                    protected int totalRequests = 0;
                    protected int failedRequests = 0;
                    protected long totalParseTime = 0;
                
                    public BaseParser(String siteName, String baseUrl) {
                        this.siteName = siteName;
                        this.baseUrl = baseUrl;
                        this.userAgent = HttpUtils.getRandomUserAgent();
                    }
                
                    @Override
                    public String getSiteName() {
                        return siteName;
                    }
                
                    /**
                     * Абстрактный метод для парсинга ответа
                     */
                    protected abstract List<Product> parseResponse(String response, String query);
                
                    /**
                     * Абстрактный метод для построения URL поиска
                     */
                    protected abstract String buildSearchUrl(String query, int page, int rows);
                
                    /**
                     * Основной метод поиска товаров
                     */
                    @Override
                    public List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes) {
                        List<Product> allProducts = new ArrayList<>();
                        long startTime = System.currentTimeMillis();
                
                        logger.info("Starting search for '{}' on {}, pages: {}, rows: {}, max age: {}min",
                                query, siteName, maxPages, rowsPerPage, maxAgeMinutes);
                
                        for (int page = 1; page <= maxPages; page++) {
                            try {
                                // Построение URL
                                String url = buildSearchUrl(query, page, rowsPerPage);
                                logger.debug("Fetching page {}: {}", page, url);
                
                                // Выполнение запроса
                                long requestStartTime = System.currentTimeMillis();
                                String response = HttpUtils.sendGetRequest(url, userAgent, true);
                                totalRequests++;
                
                                long requestTime = System.currentTimeMillis() - requestStartTime;
                                logger.debug("Page {} fetched in {}ms", page, requestTime);
                
                                // Парсинг ответа
                                long parseStartTime = System.currentTimeMillis();
                                List<Product> products = parseResponse(response, query);
                                totalParseTime += System.currentTimeMillis() - parseStartTime;
                
                                if (products.isEmpty()) {
                                    logger.debug("No products found on page {}", page);
                                    break;
                                }
                
                                // Фильтрация по возрасту
                                List<Product> filtered = new ArrayList<>();
                                for (Product product : products) {
                                    if (product.getAgeMinutes() <= maxAgeMinutes) {
                                        filtered.add(product);
                                    }
                                }
                
                                allProducts.addAll(filtered);
                                logger.info("Page {}: found {} products ({} after age filter)",
                                        page, products.size(), filtered.size());
                
                                // Проверка, нужно ли продолжать
                                if (filtered.size() < rowsPerPage) {
                                    logger.debug("Last page reached");
                                    break;
                                }
                
                                // Задержка между запросами
                                int delay = getRequestDelay();
                                if (delay > 0 && page < maxPages) {
                                    Thread.sleep(delay);
                                }
                
                            } catch (Exception e) {
                                failedRequests++;
                                logger.error("Error parsing page {}: {}", page, e.getMessage());
                
                                if (shouldStopOnError(e)) {
                                    break;
                                }
                
                                // Задержка при ошибке
                                try {
                                    Thread.sleep(3000);
                                } catch (InterruptedException ie) {
                                    Thread.currentThread().interrupt();
                                    break;
                                }
                            }
                        }
                
                        long totalTime = System.currentTimeMillis() - startTime;
                        logger.info("Search completed for '{}': found {} products in {}ms ({} requests)",
                                query, allProducts.size(), totalTime, totalRequests);
                
                        return allProducts;
                    }
                
                    /**
                     * Получение задержки между запросами
                     */
                    protected int getRequestDelay() {
                        return 2000;
                    }
                
                    /**
                     * Определение, нужно ли прекращать поиск при ошибке
                     */
                    protected boolean shouldStopOnError(Exception e) {
                        return false;
                    }
                
                    /**
                     * Получение статистики парсера
                     */
                    public ParserStats getStats() {
                        ParserStats stats = new ParserStats();
                        stats.siteName = siteName;
                        stats.totalRequests = totalRequests;
                        stats.failedRequests = failedRequests;
                        stats.successRate = totalRequests > 0 ?
                                (double)(totalRequests - failedRequests) / totalRequests * 100 : 0;
                        stats.avgParseTime = totalRequests > 0 ? totalParseTime / totalRequests : 0;
                        return stats;
                    }
                
                    /**
                     * Вспомогательный класс для статистики
                     */
                    public static class ParserStats {
                        public String siteName;
                        public int totalRequests;
                        public int failedRequests;
                        public double successRate;
                        public long avgParseTime;
                
                        @Override
                        public String toString() {
                            return String.format(
                                    "ParserStats{site=%s, requests=%d, failed=%d, success=%.1f%%, avgTime=%dms}",
                                    siteName, totalRequests, failedRequests, successRate, avgParseTime
                            );
                        }
                    }
                
                    /**
                     * Очистка строки
                     */
                    protected String cleanString(String str) {
                        if (str == null) return "";
                        return str.trim().replaceAll("\\s+", " ").replaceAll("[\\p{C}]", "");
                    }
                
                    /**
                     * Извлечение числа из строки
                     */
                    protected double extractPrice(String priceStr) {
                        if (priceStr == null || priceStr.isEmpty()) {
                            return 0.0;
                        }
                
                        try {
                            String clean = priceStr.replaceAll("[^\\d.,]", "");
                            clean = clean.replace(',', '.');
                            return Double.parseDouble(clean);
                        } catch (NumberFormatException e) {
                            logger.warn("Failed to parse price: {}", priceStr);
                            return 0.0;
                        }
                    }
                }
                ----------------------------------------

              [FILE] SiteParser.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/parser/SiteParser.java
                Размер: 965 байт
                Дата изменения: 2026-01-18T21:02:21.747662048Z
                Содержимое:
                ----------------------------------------
                package com.parser.parser;
                
                import com.parser.model.Product;
                import java.util.List;
                
                /**
                 * Интерфейс для всех парсеров сайтов
                 */
                public interface SiteParser {
                
                    /**
                     * Получение названия сайта
                     */
                    String getSiteName();
                
                    /**
                     * Поиск товаров по запросу
                     */
                    List<Product> search(String query, int maxPages, int rowsPerPage, int maxAgeMinutes);
                
                    /**
                     * Поиск товаров с настройками по умолчанию
                     */
                    default List<Product> search(String query) {
                        return search(query, 3, 100, 1440);
                    }
                
                    /**
                     * Проверка доступности сайта
                     */
                    default boolean isSiteAvailable() {
                        return true;
                    }
                
                    /**
                     * Получение информации о парсере
                     */
                    default String getParserInfo() {
                        return "SiteParser for " + getSiteName();
                    }
                }
                ----------------------------------------
            [DIR] storage

              [FILE] WhitelistManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/WhitelistManager.java
                Размер: 9979 байт
                Дата изменения: 2026-01-17T14:46:18.638222457Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.*;
                
                /**
                 * Менеджер белого списка пользователей
                 */
                public class WhitelistManager {
                    private static final Logger logger = LoggerFactory.getLogger(WhitelistManager.class);
                    private static final String WHITELIST_FILE = "whitelist.txt";
                    private static final Set<Long> whitelist = loadWhitelist();
                
                    /**
                     * Загрузка белого списка из файла
                     */
                    private static Set<Long> loadWhitelist() {
                        Set<Long> set = new HashSet<>();
                        List<String> lines = FileStorage.readLines(WHITELIST_FILE);
                
                        logger.info("Loading whitelist from file. Found {} lines", lines.size());
                
                        for (String line : lines) {
                            try {
                                line = line.trim();
                                if (line.isEmpty() || line.startsWith("#")) {
                                    continue; // Пропускаем пустые строки и комментарии
                                }
                
                                long userId = Long.parseLong(line);
                                if (userId > 0) {
                                    set.add(userId);
                                    logger.debug("Added user {} to whitelist from file", userId);
                                } else {
                                    logger.warn("Invalid user ID in whitelist (must be > 0): {}", userId);
                                }
                            } catch (NumberFormatException e) {
                                logger.warn("Invalid user ID format in whitelist: '{}'. Error: {}", line, e.getMessage());
                            }
                        }
                
                        logger.info("Loaded {} users from whitelist file", set.size());
                        return Collections.synchronizedSet(set);
                    }
                
                    /**
                     * Сохранение белого списка в файл
                     */
                    private static void saveWhitelist() {
                        List<String> lines = new ArrayList<>();
                
                        // Добавляем заголовок
                        lines.add("# Whitelist - список авторизованных пользователей");
                        lines.add("# Формат: один ID пользователя на строке");
                        lines.add("# Создан: " + new Date());
                        lines.add("");
                
                        // Сортируем ID для удобства чтения
                        List<Long> sortedUsers = new ArrayList<>(whitelist);
                        Collections.sort(sortedUsers);
                
                        for (Long userId : sortedUsers) {
                            lines.add(String.valueOf(userId));
                        }
                
                        String filePath = FileStorage.getFilePath(WHITELIST_FILE);
                        logger.info("Saving whitelist with {} users to: {}", whitelist.size(), filePath);
                
                        try {
                            FileStorage.writeLines(WHITELIST_FILE, lines);
                            logger.info("✅ Whitelist saved successfully with {} users", whitelist.size());
                        } catch (Exception e) {
                            logger.error("❌ Failed to save whitelist: {}", e.getMessage(), e);
                        }
                    }
                
                    /**
                     * Проверка, разрешен ли пользователь
                     */
                    public static boolean isUserAllowed(long userId) { // long вместо int
                        boolean allowed = whitelist.contains(userId);
                        logger.debug("Checking whitelist for user {}: {}", userId, allowed);
                        return allowed;
                    }
                
                
                    /**
                     * Добавление пользователя в белый список
                     */
                    public static boolean addUser(long userId) { // long вместо int
                        if (userId <= 0) {
                            logger.warn("Attempted to add invalid user ID: {}", userId);
                            return false;
                        }
                
                        logger.info("Adding user {} to whitelist. Current whitelist size: {}", userId, whitelist.size());
                
                        if (whitelist.add(userId)) {
                            try {
                                saveWhitelist();
                                logger.info("✅ User {} successfully added to whitelist", userId);
                                logger.info("📊 Whitelist now contains {} users", whitelist.size());
                                return true;
                            } catch (Exception e) {
                                logger.error("❌ Failed to save whitelist after adding user {}: {}", userId, e.getMessage());
                                whitelist.remove(userId);
                                return false;
                            }
                        }
                
                        logger.debug("User {} already exists in whitelist", userId);
                        return false;
                    }
                
                    /**
                     * Удаление пользователя из белого списка
                     */
                    public static boolean removeUser(long userId) {
                        logger.info("Removing user {} from whitelist", userId);
                
                        if (whitelist.remove(userId)) {
                            try {
                                saveWhitelist();
                                logger.info("✅ User {} removed from whitelist", userId);
                                return true;
                            } catch (Exception e) {
                                logger.error("❌ Failed to save whitelist after removing user {}: {}", userId, e.getMessage());
                                return false;
                            }
                        }
                
                        logger.debug("User {} not found in whitelist", userId);
                        return false;
                    }
                
                    /**
                     * Получение всех пользователей из белого списка
                     */
                    public static List<Long> getAllUsers() { // Изменяем на List<Long>
                        return new ArrayList<>(whitelist);
                    }
                
                    /**
                     * Получение количества пользователей в белом списке
                     */
                    public static long getUserCount() {
                        return whitelist.size();
                    }
                
                    /**
                     * Проверка существования пользователя
                     */
                    public static boolean userExists(long userId) {
                        return whitelist.contains(userId);
                    }
                
                    /**
                     * Очистка белого списка
                     */
                    public static void clearWhitelist() {
                        long count = whitelist.size();
                        whitelist.clear();
                        saveWhitelist();
                        logger.info("Whitelist cleared ({} users removed)", count);
                    }
                
                    /**
                     * Добавление нескольких пользователей
                     */
                    public static long addUsers(List<Long> userIds) {
                        long added = 0;
                        for (Long userId : userIds) {
                            if (userId != null && userId > 0 && whitelist.add(userId)) {
                                added++;
                            }
                        }
                
                        if (added > 0) {
                            saveWhitelist();
                            logger.info("Added {} users to whitelist", added);
                        }
                
                        return added;
                    }
                
                    /**
                     * Получение статистики белого списка
                     */
                    public static Map<String, Object> getStats() {
                        Map<String, Object> stats = new HashMap<>();
                        stats.put("totalUsers", whitelist.size());
                        stats.put("filePath", FileStorage.getFilePath(WHITELIST_FILE));
                        stats.put("fileExists", FileStorage.fileExists(WHITELIST_FILE));
                        stats.put("fileSize", FileStorage.getFileSize(WHITELIST_FILE));
                        stats.put("lastModified", FileStorage.getLastModified(WHITELIST_FILE));
                        stats.put("users", new ArrayList<>(whitelist));
                        return stats;
                    }
                
                    /**
                     * Поиск пользователей по шаблону (по ID)
                     */
                    public static List<Long> searchUsers(String pattern) {
                        List<Long> result = new ArrayList<>();
                        String searchPattern = pattern.toLowerCase();
                
                        for (Long userId : whitelist) {
                            if (String.valueOf(userId).contains(searchPattern)) {
                                result.add(userId);
                            }
                        }
                
                        return result;
                    }
                
                    /**
                     * Экспорт белого списка в текстовый файл
                     */
                    public static boolean exportWhitelist(String exportFilename) {
                        try {
                            List<String> lines = new ArrayList<>();
                            lines.add("# Whitelist export - " + new Date());
                            lines.add("# Total users: " + whitelist.size());
                            lines.add("");
                
                            // Сортируем для удобства
                            List<Long> sortedUsers = new ArrayList<>(whitelist);
                            Collections.sort(sortedUsers);
                
                            for (Long userId : sortedUsers) {
                                lines.add(String.valueOf(userId));
                            }
                
                            FileStorage.writeLines(exportFilename, lines);
                            logger.info("Whitelist exported to {}", exportFilename);
                            return true;
                
                        } catch (Exception e) {
                            logger.error("Error exporting whitelist: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Импорт белого списка из файла
                     */
                    public static int importWhitelist(String importFilename) {
                        try {
                            List<String> lines = FileStorage.readLines(importFilename);
                            int imported = 0;
                
                            for (String line : lines) {
                                try {
                                    line = line.trim();
                                    if (line.isEmpty() || line.startsWith("#")) {
                                        continue;
                                    }
                
                                    long userId = Long.parseLong(line);
                                    if (userId > 0 && whitelist.add(userId)) {
                                        imported++;
                                    }
                                } catch (NumberFormatException e) {
                                    // Пропускаем некорректные строки
                                }
                            }
                
                            if (imported > 0) {
                                saveWhitelist();
                                logger.info("Imported {} users from {}", imported, importFilename);
                            }
                
                            return imported;
                
                        } catch (Exception e) {
                            logger.error("Error importing whitelist: {}", e.getMessage());
                            return 0;
                        }
                    }
                
                    /**
                     * Перезагрузка whitelist из файла (для отладки)
                     */
                    public static void reload() {
                        logger.info("Reloading whitelist from file...");
                        Set<Long> newWhitelist = loadWhitelist();
                        whitelist.clear();
                        whitelist.addAll(newWhitelist);
                        logger.info("Whitelist reloaded. Now contains {} users", whitelist.size());
                    }
                }
                ----------------------------------------

              [FILE] UserDataManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/UserDataManager.java
                Размер: 8399 байт
                Дата изменения: 2026-01-18T21:09:17.760515874Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import com.parser.model.Product;
                import com.parser.model.UserSettings;
                import com.fasterxml.jackson.databind.ObjectMapper;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.util.*;
                
                /**
                 * Менеджер для работы с данными пользователей
                 */
                public class UserDataManager {
                    private static final Logger logger = LoggerFactory.getLogger(UserDataManager.class);
                    private static final ObjectMapper objectMapper = new ObjectMapper();
                
                    /**
                     * Получение поисковых запросов пользователя
                     */
                    public static List<String> getUserQueries(long userId) {
                        String filename = "user_queries/" + userId + ".txt";
                        return FileStorage.readLines(filename);
                    }
                
                    /**
                     * Сохранение поисковых запросов пользователя
                     */
                    public static void saveUserQueries(long userId, List<String> queries) {
                        String filename = "user_queries/" + userId + ".txt";
                        FileStorage.writeLines(filename, queries);
                        logger.debug("Saved {} queries for user {}", queries.size(), userId);
                    }
                
                    /**
                     * Добавление поискового запроса
                     */
                    public static boolean addUserQuery(long userId, String query) {
                        if (query == null || query.trim().isEmpty()) {
                            logger.warn("Attempted to add empty query for user {}", userId);
                            return false;
                        }
                
                        String trimmedQuery = query.trim();
                        List<String> queries = getUserQueries(userId);
                
                        // Проверка на дубликаты
                        for (String existingQuery : queries) {
                            if (existingQuery.equalsIgnoreCase(trimmedQuery)) {
                                logger.debug("Query already exists for user {}: {}", userId, trimmedQuery);
                                return false;
                            }
                        }
                
                        // Ограничение на количество запросов
                        if (queries.size() >= 50) {
                            logger.warn("User {} reached query limit (50)", userId);
                            return false;
                        }
                
                        queries.add(trimmedQuery);
                        saveUserQueries(userId, queries);
                        logger.info("Query added for user {}: {}", userId, trimmedQuery);
                        return true;
                    }
                
                    /**
                     * Удаление поискового запроса
                     */
                    public static boolean removeUserQuery(long userId, String query) {
                        List<String> queries = getUserQueries(userId);
                        boolean removed = queries.remove(query);
                
                        if (removed) {
                            saveUserQueries(userId, queries);
                            logger.info("Query removed for user {}: {}", userId, query);
                        }
                
                        return removed;
                    }
                
                    /**
                     * Очистка всех поисковых запросов пользователя
                     */
                    public static void clearUserQueries(long userId) {
                        saveUserQueries(userId, new ArrayList<>());
                        logger.info("All queries cleared for user {}", userId);
                    }
                
                    /**
                     * Получение настроек пользователя
                     */
                    public static UserSettings getUserSettings(long userId) {
                        String filename = "user_settings/" + userId + ".json";
                        String json = FileStorage.readJson(filename);
                
                        try {
                            if (json == null || json.isEmpty() || json.equals("{}")) {
                                // Возвращаем настройки по умолчанию
                                UserSettings defaultSettings = new UserSettings();
                                saveUserSettings(userId, defaultSettings);
                                return defaultSettings;
                            }
                
                            return objectMapper.readValue(json, UserSettings.class);
                
                        } catch (Exception e) {
                            logger.error("Error parsing settings for user {}: {}", userId, e.getMessage());
                            return new UserSettings();
                        }
                    }
                
                    /**
                     * Сохранение настроек пользователя
                     */
                    public static void saveUserSettings(long userId, UserSettings settings) {
                        String filename = "user_settings/" + userId + ".json";
                
                        try {
                            String json = objectMapper.writeValueAsString(settings);
                            FileStorage.writeJson(filename, json);
                            logger.debug("Settings saved for user {}", userId);
                        } catch (Exception e) {
                            logger.error("Error saving settings for user {}: {}", userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Получение сохраненных товаров пользователя
                     */
                    public static List<Product> getUserProducts(long userId) {
                        String filename = "user_products/" + userId + ".json";
                        String json = FileStorage.readJson(filename);
                
                        if (json == null || json.isEmpty() || json.equals("{}")) {
                            return new ArrayList<>();
                        }
                
                        try {
                            Product[] products = objectMapper.readValue(json, Product[].class);
                            return new ArrayList<>(Arrays.asList(products));
                        } catch (Exception e) {
                            logger.error("Error parsing products for user {}: {}", userId, e.getMessage());
                            return new ArrayList<>();
                        }
                    }
                
                    /**
                     * Сохранение товаров пользователя
                     */
                    public static void saveUserProducts(long userId, List<Product> products) {
                        String filename = "user_products/" + userId + ".json";
                
                        try {
                            String json = objectMapper.writeValueAsString(products);
                            FileStorage.writeJson(filename, json);
                            logger.debug("Saved {} products for user {}", products.size(), userId);
                        } catch (Exception e) {
                            logger.error("Error saving products for user {}: {}", userId, e.getMessage());
                        }
                    }
                
                    /**
                     * Добавление товаров к существующим
                     */
                    public static void addUserProducts(long userId, List<Product> newProducts) {
                        if (newProducts == null || newProducts.isEmpty()) return;
                
                        List<Product> existingProducts = getUserProducts(userId);
                        Set<String> existingIds = new HashSet<>();
                
                        for (Product product : existingProducts) {
                            existingIds.add(product.getId());
                        }
                
                        for (Product product : newProducts) {
                            if (!existingIds.contains(product.getId())) {
                                existingProducts.add(product);
                                existingIds.add(product.getId());
                            }
                        }
                
                        // Ограничиваем количество хранимых товаров
                        if (existingProducts.size() > 1000) {
                            existingProducts = existingProducts.subList(
                                    existingProducts.size() - 1000, existingProducts.size());
                        }
                
                        saveUserProducts(userId, existingProducts);
                    }
                
                    /**
                     * Очистка товаров пользователя
                     */
                    public static void clearUserProducts(long userId) {
                        String filename = "user_products/" + userId + ".json";
                        FileStorage.writeJson(filename, "[]");
                        logger.info("Products cleared for user {}", userId);
                    }
                
                    /**
                     * Фильтрация новых товаров
                     */
                    public static List<Product> filterNewProducts(long userId, List<Product> products) {
                        if (products == null || products.isEmpty()) return new ArrayList<>();
                
                        List<Product> existingProducts = getUserProducts(userId);
                        Set<String> existingIds = new HashSet<>();
                
                        for (Product product : existingProducts) {
                            existingIds.add(product.getId());
                        }
                
                        List<Product> newProducts = new ArrayList<>();
                        for (Product product : products) {
                            if (!existingIds.contains(product.getId())) {
                                newProducts.add(product);
                            }
                        }
                
                        return newProducts;
                    }
                
                    /**
                     * Получение статистики пользователя
                     */
                    public static Map<String, Object> getUserStats(long userId) {
                        Map<String, Object> stats = new HashMap<>();
                
                        List<String> queries = getUserQueries(userId);
                        stats.put("queryCount", queries.size());
                
                        List<Product> products = getUserProducts(userId);
                        stats.put("productCount", products.size());
                
                        UserSettings settings = getUserSettings(userId);
                        stats.put("settings", settings.getSummary());
                
                        return stats;
                    }
                }
                ----------------------------------------

              [FILE] FileStorage.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/storage/FileStorage.java
                Размер: 17724 байт
                Дата изменения: 2026-01-17T13:59:52.567565253Z
                Содержимое:
                ----------------------------------------
                package com.parser.storage;
                
                import com.parser.config.Config;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.io.*;
                import java.nio.charset.StandardCharsets;
                import java.nio.file.*;
                import java.util.*;
                import java.util.concurrent.locks.ReentrantLock;
                import java.util.zip.GZIPOutputStream;
                
                /**
                 * Утилита для работы с файловым хранилищем
                 */
                public class FileStorage {
                    private static final Logger logger = LoggerFactory.getLogger(FileStorage.class);
                
                    // Блокировки для предотвращения конкурентного доступа
                    private static final Map<String, ReentrantLock> fileLocks = new HashMap<>();
                
                    /**
                     * Получение блокировки для файла
                     */
                    private static synchronized ReentrantLock getFileLock(String filename) {
                        return fileLocks.computeIfAbsent(filename, k -> new ReentrantLock());
                    }
                
                    /**
                     * Создание директории для данных, если она не существует
                     */
                    public static void ensureDataDir() {
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        File dir = new File(dataDir);
                
                        if (!dir.exists()) {
                            logger.info("Создание директории данных: {}", dataDir);
                            if (dir.mkdirs()) {
                                logger.info("✅ Директория данных создана: {}", dataDir);
                
                                // Создание поддиректорий
                                createSubdirectory(dataDir, "user_settings");
                                createSubdirectory(dataDir, "user_products");
                                createSubdirectory(dataDir, "backups");
                                createSubdirectory(dataDir, "logs");
                
                            } else {
                                logger.error("❌ Не удалось создать директорию данных: {}", dataDir);
                                throw new RuntimeException("Failed to create data directory: " + dataDir);
                            }
                        } else {
                            logger.debug("Директория данных уже существует: {}", dataDir);
                        }
                    }
                
                    /**
                     * Создание поддиректории
                     */
                    private static void createSubdirectory(String parentDir, String subdirName) {
                        File subdir = new File(parentDir + "/" + subdirName);
                        if (!subdir.exists()) {
                            if (subdir.mkdirs()) {
                                logger.debug("✅ Создана поддиректория: {}", subdir.getAbsolutePath());
                            } else {
                                logger.warn("⚠️ Не удалось создать поддиректорию: {}", subdir.getAbsolutePath());
                            }
                        }
                    }
                
                    /**
                     * Получение пути к файлу
                     */
                    public static String getFilePath(String filename) {
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        return dataDir + "/" + filename;
                    }
                
                    /**
                     * Чтение строк из файла
                     */
                    public static List<String> readLines(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            if (!file.exists()) {
                                logger.debug("Файл не существует: {}", filename);
                                return new ArrayList<>();
                            }
                
                            List<String> lines = new ArrayList<>();
                            try (BufferedReader reader = new BufferedReader(
                                    new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {
                
                                String line;
                                int lineNumber = 0;
                                while ((line = reader.readLine()) != null) {
                                    lineNumber++;
                                    line = line.trim();
                                    if (!line.isEmpty()) {
                                        lines.add(line);
                                    }
                                }
                
                                logger.debug("Прочитано {} строк из {}", lines.size(), filename);
                                return lines;
                
                            } catch (IOException e) {
                                logger.error("Ошибка чтения файла {}: {}", filename, e.getMessage());
                                return new ArrayList<>();
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Запись строк в файл
                     */
                    public static void writeLines(String filename, List<String> lines) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            ensureDataDir();
                            File file = new File(getFilePath(filename));
                
                            logger.info("📝 Запись в файл: {} (абсолютный путь: {})",
                                    filename, file.getAbsolutePath());
                            logger.info("   Файл существует перед записью: {}", file.exists());
                            logger.info("   Родительская директория: {}", file.getParent());
                            logger.info("   Количество строк для записи: {}", lines.size());
                
                            // Проверяем родительскую директорию
                            File parentDir = file.getParentFile();
                            if (parentDir != null && !parentDir.exists()) {
                                logger.info("   Создание родительской директории: {}", parentDir.getAbsolutePath());
                                if (!parentDir.mkdirs()) {
                                    logger.error("❌ Не удалось создать родительскую директорию");
                                    throw new RuntimeException("Cannot create parent directory: " + parentDir.getAbsolutePath());
                                }
                            }
                
                            // Проверяем права на запись
                            if (file.exists() && !file.canWrite()) {
                                logger.error("❌ Нет прав на запись в файл: {}", file.getAbsolutePath());
                                throw new RuntimeException("No write permission for file: " + file.getAbsolutePath());
                            }
                
                            // Создание резервной копии, если файл существует
                            if (file.exists()) {
                                logger.debug("   Создание резервной копии...");
                                createBackup(filename);
                            }
                
                            try (BufferedWriter writer = new BufferedWriter(
                                    new OutputStreamWriter(new FileOutputStream(file), StandardCharsets.UTF_8))) {
                
                                for (String line : lines) {
                                    writer.write(line);
                                    writer.newLine();
                                }
                
                                writer.flush();
                
                                logger.info("✅ Успешно записано {} строк в {}", lines.size(), filename);
                                logger.info("   Файл существует после записи: {}", file.exists());
                                logger.info("   Размер файла после записи: {} байт", file.length());
                
                            } catch (IOException e) {
                                logger.error("❌ Ошибка записи файла {}: {}", filename, e.getMessage(), e);
                                throw new RuntimeException("Failed to write file: " + filename, e);
                            }
                
                        } catch (Exception e) {
                            logger.error("❌ Критическая ошибка в writeLines для {}: {}", filename, e.getMessage(), e);
                            // Пробрасываем исключение дальше
                            if (e instanceof RuntimeException) {
                                throw (RuntimeException) e;
                            } else {
                                throw new RuntimeException("Error in writeLines for " + filename, e);
                            }
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Добавление строки в конец файла
                     */
                    public static void appendLine(String filename, String line) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            ensureDataDir();
                            File file = new File(getFilePath(filename));
                
                            try (BufferedWriter writer = new BufferedWriter(
                                    new OutputStreamWriter(new FileOutputStream(file, true), StandardCharsets.UTF_8))) {
                
                                writer.write(line);
                                writer.newLine();
                
                                logger.debug("Appended line to {}", filename);
                
                            } catch (IOException e) {
                                logger.error("Error appending to file {}: {}", filename, e.getMessage());
                                throw new RuntimeException("Failed to append to file: " + filename, e);
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Чтение JSON объекта из файла
                     */
                    public static String readJson(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            if (!file.exists()) {
                                return "{}";
                            }
                
                            StringBuilder content = new StringBuilder();
                            try (BufferedReader reader = new BufferedReader(
                                    new InputStreamReader(new FileInputStream(file), StandardCharsets.UTF_8))) {
                
                                String line;
                                while ((line = reader.readLine()) != null) {
                                    content.append(line);
                                }
                
                                return content.toString();
                
                            } catch (IOException e) {
                                logger.error("Error reading JSON file {}: {}", filename, e.getMessage());
                                return "{}";
                            }
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Запись JSON объекта в файл
                     */
                    public static void writeJson(String filename, String json) {
                        writeLines(filename, List.of(json));
                    }
                
                    /**
                     * Проверка существования файла
                     */
                    public static boolean fileExists(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists();
                    }
                
                    /**
                     * Удаление файла
                     */
                    public static boolean deleteFile(String filename) {
                        ReentrantLock lock = getFileLock(filename);
                        lock.lock();
                
                        try {
                            File file = new File(getFilePath(filename));
                            boolean deleted = file.delete();
                
                            if (deleted) {
                                logger.debug("Deleted file: {}", filename);
                            } else {
                                logger.warn("Failed to delete file: {}", filename);
                            }
                
                            return deleted;
                
                        } finally {
                            lock.unlock();
                        }
                    }
                
                    /**
                     * Копирование файла
                     */
                    public static boolean copyFile(String sourceFilename, String destFilename) {
                        ReentrantLock sourceLock = getFileLock(sourceFilename);
                        ReentrantLock destLock = getFileLock(destFilename);
                
                        sourceLock.lock();
                        destLock.lock();
                
                        try {
                            Path source = Paths.get(getFilePath(sourceFilename));
                            Path destination = Paths.get(getFilePath(destFilename));
                
                            Files.copy(source, destination, StandardCopyOption.REPLACE_EXISTING);
                            logger.debug("Copied {} to {}", sourceFilename, destFilename);
                            return true;
                
                        } catch (IOException e) {
                            logger.error("Error copying file {} to {}: {}",
                                    sourceFilename, destFilename, e.getMessage());
                            return false;
                        } finally {
                            destLock.unlock();
                            sourceLock.unlock();
                        }
                    }
                
                    /**
                     * Создание резервной копии файла
                     */
                    public static void createBackup(String filename) {
                        if (!Config.getBoolean("storage.backup.enabled", true)) {
                            return;
                        }
                
                        try {
                            String backupDir = getFilePath("backups");
                            String timestamp = new java.text.SimpleDateFormat("yyyyMMdd_HHmmss")
                                    .format(new java.util.Date());
                
                            String backupFilename = String.format("%s/%s_%s.backup",
                                    backupDir, filename.replace("/", "_"), timestamp);
                
                            copyFile(filename, backupFilename);
                
                            // Сжатие резервной копии
                            compressFile(backupFilename);
                
                            // Очистка старых резервных копий
                            cleanupOldBackups(filename);
                
                        } catch (Exception e) {
                            logger.error("Error creating backup for {}: {}", filename, e.getMessage());
                        }
                    }
                
                    /**
                     * Сжатие файла с использованием GZIP
                     */
                    private static void compressFile(String filename) {
                        try {
                            File inputFile = new File(filename);
                            File outputFile = new File(filename + ".gz");
                
                            try (FileInputStream fis = new FileInputStream(inputFile);
                                 FileOutputStream fos = new FileOutputStream(outputFile);
                                 GZIPOutputStream gzipOS = new GZIPOutputStream(fos)) {
                
                                byte[] buffer = new byte[1024];
                                int len;
                                while ((len = fis.read(buffer)) != -1) {
                                    gzipOS.write(buffer, 0, len);
                                }
                            }
                
                            // Удаление несжатого файла
                            inputFile.delete();
                            logger.debug("Compressed backup file: {}", outputFile.getName());
                
                        } catch (IOException e) {
                            logger.error("Error compressing file {}: {}", filename, e.getMessage());
                        }
                    }
                
                    /**
                     * Очистка старых резервных копий
                     */
                    private static void cleanupOldBackups(String originalFilename) {
                        try {
                            String backupDir = getFilePath("backups");
                            File dir = new File(backupDir);
                
                            if (!dir.exists()) {
                                return;
                            }
                
                            String baseName = originalFilename.replace("/", "_");
                            File[] backupFiles = dir.listFiles((d, name) ->
                                    name.startsWith(baseName + "_") && name.endsWith(".backup.gz"));
                
                            if (backupFiles == null || backupFiles.length <= 10) {
                                return; // Сохраняем последние 10 копий
                            }
                
                            // Сортировка по времени изменения (старые первыми)
                            Arrays.sort(backupFiles, Comparator.comparingLong(File::lastModified));
                
                            // Удаление старых копий
                            for (int i = 0; i < backupFiles.length - 10; i++) {
                                backupFiles[i].delete();
                                logger.debug("Deleted old backup: {}", backupFiles[i].getName());
                            }
                
                        } catch (Exception e) {
                            logger.error("Error cleaning up old backups: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Получение списка файлов в директории
                     */
                    public static List<String> listFiles(String directory) {
                        String dirPath = getFilePath(directory);
                        File dir = new File(dirPath);
                
                        if (!dir.exists() || !dir.isDirectory()) {
                            return new ArrayList<>();
                        }
                
                        File[] files = dir.listFiles();
                        if (files == null) {
                            return new ArrayList<>();
                        }
                
                        List<String> fileList = new ArrayList<>();
                        for (File file : files) {
                            if (file.isFile()) {
                                fileList.add(file.getName());
                            }
                        }
                
                        return fileList;
                    }
                
                    /**
                     * Получение размера файла в байтах
                     */
                    public static long getFileSize(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists() ? file.length() : 0;
                    }
                
                    /**
                     * Получение времени последнего изменения файла
                     */
                    public static long getLastModified(String filename) {
                        File file = new File(getFilePath(filename));
                        return file.exists() ? file.lastModified() : 0;
                    }
                
                    /**
                     * Проверка, является ли файл пустым
                     */
                    public static boolean isEmpty(String filename) {
                        File file = new File(getFilePath(filename));
                        return !file.exists() || file.length() == 0;
                    }
                
                    /**
                     * Создание директории
                     */
                    public static boolean createDirectory(String directory) {
                        String dirPath = getFilePath(directory);
                        File dir = new File(dirPath);
                        return dir.mkdirs();
                    }
                
                    /**
                     * Получение статистики файлового хранилища
                     */
                    public static Map<String, Object> getStorageStats() {
                        Map<String, Object> stats = new HashMap<>();
                
                        String dataDir = Config.getString("storage.data.dir", "./data");
                        File dir = new File(dataDir);
                
                        if (!dir.exists()) {
                            stats.put("status", "directory_not_exists");
                            return stats;
                        }
                
                        stats.put("directory", dataDir);
                        stats.put("exists", true);
                        stats.put("totalSpace", dir.getTotalSpace());
                        stats.put("freeSpace", dir.getFreeSpace());
                        stats.put("usableSpace", dir.getUsableSpace());
                
                        // Подсчет файлов
                        File[] files = dir.listFiles();
                        if (files != null) {
                            stats.put("totalFiles", files.length);
                
                            long totalSize = 0;
                            for (File file : files) {
                                totalSize += file.length();
                            }
                            stats.put("totalSizeBytes", totalSize);
                            stats.put("totalSizeMB", totalSize / (1024 * 1024));
                        }
                
                        return stats;
                    }
                }
                ----------------------------------------
            [DIR] telegram

              [FILE] TelegramNotificationService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/telegram/TelegramNotificationService.java
                Размер: 9465 байт
                Дата изменения: 2026-01-17T14:49:12.908926501Z
                Содержимое:
                ----------------------------------------
                package com.parser.telegram;
                
                import com.parser.config.Config;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
                import org.telegram.telegrambots.meta.api.methods.send.SendPhoto;
                import org.telegram.telegrambots.meta.api.objects.InputFile;
                import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
                
                import java.net.URL;
                import java.util.Date;
                
                /**
                 * Сервис для отправки уведомлений через Telegram
                 */
                public class TelegramNotificationService {
                    private static final Logger logger = LoggerFactory.getLogger(TelegramNotificationService.class);
                
                    private static TelegramBotService botInstance;
                
                    /**
                     * Установка экземпляра бота для отправки уведомлений
                     */
                    public static void setBotInstance(TelegramBotService bot) {
                        botInstance = bot;
                        logger.info("TelegramNotificationService initialized with bot instance");
                    }
                
                    /**
                     * Отправка простого текстового сообщения
                     */
                    public static boolean sendMessage(long userId, String text) {
                        return sendMessage(userId, text, false);
                    }
                
                    /**
                     * Отправка текстового сообщения с HTML форматированием
                     */
                    public static boolean sendHtmlMessage(long userId, String htmlText) {
                        return sendMessage(userId, htmlText, true);
                    }
                
                    /**
                     * Основной метод отправки сообщения
                     */
                    private static boolean sendMessage(long userId, String text, boolean useHtml) {
                        if (botInstance == null) {
                            logger.error("Bot instance not set for TelegramNotificationService");
                            return false;
                        }
                
                        if (text == null || text.trim().isEmpty()) {
                            logger.warn("Attempted to send empty message to user {}", userId);
                            return false;
                        }
                
                        try {
                            SendMessage message = new SendMessage();
                            message.setChatId(String.valueOf(userId));
                
                            if (useHtml) {
                                message.setText(text);
                                message.setParseMode("HTML");
                                message.disableWebPagePreview();
                            } else {
                                message.setText(text);
                            }
                
                            botInstance.execute(message);
                            logger.debug("Message sent to user {}", userId);
                            return true;
                
                        } catch (TelegramApiException e) {
                            logger.error("Error sending message to user {}: {}", userId, e.getMessage());
                
                            if (useHtml) {
                                logger.info("Retrying without HTML formatting...");
                                String plainText = stripHtml(text);
                                return sendMessage(userId, plainText, false);
                            }
                            return false;
                        }
                    }
                
                    /**
                     * Отправка фото с подписью (HTML форматирование)
                     */
                    public static boolean sendPhotoWithHtmlCaption(long userId, String photoUrl, String htmlCaption) {
                        if (botInstance == null) {
                            logger.error("Bot instance not set for TelegramNotificationService");
                            return false;
                        }
                
                        if (photoUrl == null || photoUrl.isEmpty()) {
                            logger.warn("Empty photo URL for user {}", userId);
                            return false;
                        }
                
                        try {
                            // Проверяем, является ли URL валидным
                            if (!isValidUrl(photoUrl)) {
                                logger.warn("Invalid photo URL: {}", photoUrl);
                                return sendHtmlMessage(userId, htmlCaption);
                            }
                
                            SendPhoto photo = new SendPhoto();
                            photo.setChatId(String.valueOf(userId));
                
                            // Используем URL напрямую
                            photo.setPhoto(new InputFile(photoUrl));
                
                            if (htmlCaption != null && !htmlCaption.isEmpty()) {
                                // Обрезаем подпись если она слишком длинная (макс 1024 символа для Telegram)
                                if (htmlCaption.length() > 1024) {
                                    htmlCaption = htmlCaption.substring(0, 1020) + "...";
                                }
                                photo.setCaption(htmlCaption);
                                photo.setParseMode("HTML");
                            }
                
                            botInstance.execute(photo);
                            logger.debug("Photo with caption sent to user {}", userId);
                            return true;
                
                        } catch (TelegramApiException e) {
                            logger.error("Error sending photo to user {}: {}", userId, e.getMessage());
                
                            // Если не удалось отправить фото, отправляем текстовое сообщение
                            if (htmlCaption != null && !htmlCaption.isEmpty()) {
                                String textMessage = "📸 " + stripHtml(htmlCaption);
                                return sendMessage(userId, textMessage);
                            }
                            return false;
                        } catch (Exception e) {
                            logger.error("Unexpected error sending photo to user {}: {}", userId, e.getMessage());
                            return sendHtmlMessage(userId, htmlCaption);
                        }
                    }
                
                    /**
                     * Проверка валидности URL
                     */
                    private static boolean isValidUrl(String url) {
                        try {
                            new URL(url).toURI();
                            return true;
                        } catch (Exception e) {
                            return false;
                        }
                    }
                
                    /**
                     * Удаление HTML тегов из текста
                     */
                    private static String stripHtml(String html) {
                        if (html == null) return "";
                        return html.replaceAll("<[^>]*>", "")
                                .replace("&amp;", "&")
                                .replace("&lt;", "<")
                                .replace("&gt;", ">")
                                .replace("&quot;", "\"")
                                .replace("&#39;", "'");
                    }
                
                    /**
                     * Экранирование для HTML
                     */
                    public static String escapeHtml(String text) {
                        if (text == null) return "";
                
                        return text.replace("&", "&amp;")
                                .replace("<", "&lt;")
                                .replace(">", "&gt;")
                                .replace("\"", "&quot;")
                                .replace("'", "&#39;");
                    }
                
                    /**
                     * Отправка тестового уведомления
                     */
                    public static boolean sendTestNotification(long userId) {
                        logger.info("Sending test notification to user {}", userId);
                
                        String message = "<b>✅ Test notification</b>\n\n" +
                                "Parser is working correctly!\n" +
                                "This is a test message to confirm that the notification system is functioning.\n\n" +
                                "<i>Time: " + new Date() + "</i>";
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления о найденных товарах
                     */
                    public static boolean sendProductsNotification(long userId, int count, String query) {
                        String message = String.format("<b>🛍️ Found products!</b>\n\n" +
                                "Query: %s\n" +
                                "Products found: %d\n\n" +
                                "<i>Sending details...</i>", escapeHtml(query), count);
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления об ошибке
                     */
                    public static boolean sendErrorNotification(long userId, String errorMessage) {
                        String message = String.format("<b>❌ Parser error</b>\n\n" +
                                        "An error occurred:\n" +
                                        "<code>%s</code>\n\n" +
                                        "<i>The parser will be restarted automatically.</i>",
                                escapeHtml(errorMessage));
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления о состоянии парсера
                     */
                    public static boolean sendStatusNotification(long userId, String status, String details) {
                        String emoji = "🟢";
                        if (status.contains("stopped")) emoji = "🔴";
                        if (status.contains("paused")) emoji = "⏸️";
                        if (status.contains("error")) emoji = "❌";
                
                        String message = String.format("%s <b>Parser status changed</b>\n\n" +
                                "New status: %s\n\n" +
                                "%s", emoji, status, escapeHtml(details));
                
                        return sendHtmlMessage(userId, message);
                    }
                
                    /**
                     * Отправка уведомления администратору
                     */
                    public static boolean sendAdminNotification(String message) {
                        long adminId = Config.getTelegramAdminId();
                        if (adminId == 0) {
                            logger.warn("Admin ID not configured");
                            return false;
                        }
                
                        String adminMessage = String.format("<b>👑 Admin notification</b>\n\n" +
                                        "%s\n\n" +
                                        "<i>Time: %s</i>",
                                escapeHtml(message),
                                new Date());
                
                        return sendHtmlMessage(adminId, adminMessage);
                    }
                
                    /**
                     * Проверка доступности бота
                     */
                    public static boolean isBotAvailable() {
                        return botInstance != null;
                    }
                
                    /**
                     * Отправка фото с подписью (удобный метод для использования из других классов)
                     */
                    public static boolean sendPhotoWithCaption(long userId, String photoUrl, String caption) {
                        return sendPhotoWithHtmlCaption(userId, photoUrl, caption);
                    }
                }
                ----------------------------------------

              [FILE] TelegramStateManager.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/telegram/TelegramStateManager.java
                Размер: 5969 байт
                Дата изменения: 2026-01-15T20:06:31.263938095Z
                Содержимое:
                ----------------------------------------
                package com.parser.telegram;
                
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import java.util.Map;
                import java.util.concurrent.ConcurrentHashMap;
                
                /**
                 * Менеджер состояний для хранения промежуточных данных пользователей
                 */
                public class TelegramStateManager {
                    private static final Logger logger = LoggerFactory.getLogger(TelegramStateManager.class);
                
                    // Хранилище состояний пользователей
                    private final Map<Integer, UserState> userStates = new ConcurrentHashMap<>();
                
                    /**
                     * Внутренний класс для хранения состояния пользователя
                     */
                    private static class UserState {
                        private String state;
                        private Map<String, String> data;
                        private long lastActivity;
                
                        public UserState() {
                            this.state = null;
                            this.data = new ConcurrentHashMap<>();
                            this.lastActivity = System.currentTimeMillis();
                        }
                
                        public void updateActivity() {
                            this.lastActivity = System.currentTimeMillis();
                        }
                
                        public boolean isExpired(long timeoutMs) {
                            return System.currentTimeMillis() - lastActivity > timeoutMs;
                        }
                    }
                
                    // Таймаут состояния (30 минут)
                    private static final long STATE_TIMEOUT = 30 * 60 * 1000;
                
                    /**
                     * Установка состояния пользователя
                     */
                    public void setUserState(int userId, String state) {
                        UserState userState = userStates.computeIfAbsent(userId, k -> new UserState());
                        userState.state = state;
                        userState.updateActivity();
                        logger.debug("State set for user {}: {}", userId, state);
                    }
                
                    /**
                     * Получение состояния пользователя
                     */
                    public String getUserState(int userId) {
                        UserState userState = userStates.get(userId);
                        if (userState != null) {
                            if (userState.isExpired(STATE_TIMEOUT)) {
                                userStates.remove(userId);
                                logger.debug("State expired for user {}", userId);
                                return null;
                            }
                            userState.updateActivity();
                            return userState.state;
                        }
                        return null;
                    }
                
                    /**
                     * Очистка состояния пользователя
                     */
                    public void clearUserState(int userId) {
                        userStates.remove(userId);
                        logger.debug("State cleared for user {}", userId);
                    }
                
                    /**
                     * Установка данных пользователя
                     */
                    public void setUserData(int userId, String key, String value) {
                        UserState userState = userStates.computeIfAbsent(userId, k -> new UserState());
                        userState.data.put(key, value);
                        userState.updateActivity();
                        logger.debug("Data set for user {}: {} = {}", userId, key, value);
                    }
                
                    /**
                     * Получение данных пользователя
                     */
                    public String getUserData(int userId, String key) {
                        UserState userState = userStates.get(userId);
                        if (userState != null) {
                            if (userState.isExpired(STATE_TIMEOUT)) {
                                userStates.remove(userId);
                                return null;
                            }
                            userState.updateActivity();
                            return userState.data.get(key);
                        }
                        return null;
                    }
                
                    /**
                     * Очистка всех данных пользователя
                     */
                    public void clearUserData(int userId) {
                        UserState userState = userStates.get(userId);
                        if (userState != null) {
                            userState.data.clear();
                            userState.state = null;
                            userState.updateActivity();
                            logger.debug("All data cleared for user {}", userId);
                        }
                    }
                
                    /**
                     * Получение всех данных пользователя
                     */
                    public Map<String, String> getAllUserData(int userId) {
                        UserState userState = userStates.get(userId);
                        if (userState != null) {
                            if (userState.isExpired(STATE_TIMEOUT)) {
                                userStates.remove(userId);
                                return Map.of();
                            }
                            userState.updateActivity();
                            return new ConcurrentHashMap<>(userState.data);
                        }
                        return Map.of();
                    }
                
                    /**
                     * Проверка наличия состояния у пользователя
                     */
                    public boolean hasUserState(int userId) {
                        return getUserState(userId) != null;
                    }
                
                    /**
                     * Очистка устаревших состояний
                     */
                    public void cleanupExpiredStates() {
                        int initialSize = userStates.size();
                        userStates.entrySet().removeIf(entry -> entry.getValue().isExpired(STATE_TIMEOUT));
                        int removed = initialSize - userStates.size();
                
                        if (removed > 0) {
                            logger.info("Cleaned up {} expired user states", removed);
                        }
                    }
                
                    /**
                     * Получение статистики менеджера состояний
                     */
                    public Map<String, Object> getStats() {
                        Map<String, Object> stats = new java.util.HashMap<>();
                        stats.put("totalUsers", userStates.size());
                        stats.put("timeoutMs", STATE_TIMEOUT);
                
                        // Подсчет состояний по типам
                        Map<String, Integer> stateCounts = new java.util.HashMap<>();
                        for (UserState state : userStates.values()) {
                            if (state.state != null) {
                                stateCounts.put(state.state, stateCounts.getOrDefault(state.state, 0) + 1);
                            }
                        }
                        stats.put("stateCounts", stateCounts);
                
                        return stats;
                    }
                
                    /**
                     * Сброс всех состояний (для тестирования)
                     */
                    public void reset() {
                        int count = userStates.size();
                        userStates.clear();
                        logger.info("Reset all user states ({} cleared)", count);
                    }
                }
                ----------------------------------------

              [FILE] TelegramBotService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/telegram/TelegramBotService.java
                Размер: 65887 байт
                Дата изменения: 2026-01-19T07:46:09.559896366Z
                Содержимое:
                ----------------------------------------
                package com.parser.telegram;
                
                import com.parser.config.Config;
                import com.parser.core.ThreadManager;
                import com.parser.model.UserSettings;
                import com.parser.service.CookieService;
                import com.parser.storage.WhitelistManager;
                import com.parser.storage.UserDataManager;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                import org.telegram.telegrambots.bots.TelegramLongPollingBot;
                import org.telegram.telegrambots.meta.api.methods.AnswerCallbackQuery;
                import org.telegram.telegrambots.meta.api.methods.send.SendMessage;
                import org.telegram.telegrambots.meta.api.methods.updatingmessages.DeleteMessage;
                import org.telegram.telegrambots.meta.api.objects.CallbackQuery;
                import org.telegram.telegrambots.meta.api.objects.Update;
                import org.telegram.telegrambots.meta.api.objects.commands.BotCommand;
                import org.telegram.telegrambots.meta.api.objects.commands.scope.BotCommandScopeDefault;
                import org.telegram.telegrambots.meta.api.objects.replykeyboard.InlineKeyboardMarkup;
                import org.telegram.telegrambots.meta.api.objects.replykeyboard.buttons.InlineKeyboardButton;
                import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
                
                import java.util.*;
                
                /**
                 * Основной сервис Telegram бота
                 */
                public class TelegramBotService extends TelegramLongPollingBot {
                    private static final Logger logger = LoggerFactory.getLogger(TelegramBotService.class);
                
                    private final ThreadManager threadManager;
                    private final TelegramStateManager stateManager;
                    private final long adminId;
                
                    // Кэш сообщений для редактирования
                    private final Map<Long, Integer> lastMessageIdCache = new HashMap<>();
                
                    public TelegramBotService(String token, ThreadManager threadManager) {
                        super(token);
                        this.threadManager = threadManager;
                        this.stateManager = new TelegramStateManager();
                        this.adminId = Config.getInt("telegram.admin.id", 0);
                
                        // Регистрация команд
                        registerCommands();
                        logger.info("TelegramBotService initialized");
                    }
                
                    @Override
                    public void onUpdateReceived(Update update) {
                        try {
                            if (update.hasMessage() && update.getMessage().hasText()) {
                                handleMessage(update.getMessage());
                            } else if (update.hasCallbackQuery()) {
                                handleCallbackQuery(update.getCallbackQuery());
                            }
                        } catch (Exception e) {
                            logger.error("Error processing update: {}", e.getMessage(), e);
                        }
                    }
                
                    /**
                     * Обработка текстовых сообщений
                     */
                    private void handleMessage(org.telegram.telegrambots.meta.api.objects.Message message) {
                        Long chatId = message.getChatId();
                        String text = message.getText();
                        long userId = chatId; // Используем long напрямую
                
                        logger.info("Message from {} (user {}): {}", chatId, userId, text);
                
                        // Обработка команд
                        if (text.startsWith("/")) {
                            handleCommand(chatId, userId, text, message.getMessageId());
                        } else {
                            // Обработка текстовых ответов
                            handleTextResponse(chatId, userId, text, message.getMessageId());
                        }
                    }
                
                    /**
                     * Обработка команд
                     */
                    private void handleCommand(Long chatId, long userId, String command, Integer messageId) {
                        try {
                            String[] parts = command.split(" ", 2);
                            String cmd = parts[0].toLowerCase();
                            String args = parts.length > 1 ? parts[1] : "";
                
                            logger.debug("Command: {}, Args: {}", cmd, args);
                
                            switch (cmd) {
                                case "/start":
                                    handleStart(chatId, userId);
                                    break;
                
                                case "/help":
                                    sendHelpMessage(chatId);
                                    break;
                
                                case "/status":
                                    handleStatus(chatId, userId);
                                    break;
                
                                case "/addquery":
                                    handleAddQuery(chatId, userId, args);
                                    break;
                
                                case "/listqueries":
                                    handleListQueries(chatId, userId);
                                    break;
                
                                case "/removequery":
                                    handleRemoveQuery(chatId, userId, args);
                                    break;
                
                                case "/settings":
                                    showSettingsMenu(chatId, userId);
                                    break;
                
                                case "/start_parser":
                                    handleStartParser(chatId, userId);
                                    break;
                
                                case "/stop_parser":
                                    handleStopParser(chatId, userId);
                                    break;
                
                                case "/pause_parser":
                                    handlePauseParser(chatId, userId);
                                    break;
                
                                case "/resume_parser":
                                    handleResumeParser(chatId, userId);
                                    break;
                
                                case "/stats":
                                    handleStats(chatId, userId);
                                    break;
                
                                case "/clear":
                                    handleClear(chatId, userId, args);
                                    break;
                
                                case "/admin":
                                    handleAdmin(chatId, userId, args);
                                    break;
                
                                case "/cookies":
                                    handleCookiesCommand(chatId, userId, args);
                                    break;
                
                                case "/checkwhitelist":
                                    handleCheckWhitelist(chatId, userId);
                                    break;
                
                                case "/debug":
                                    handleDebug(chatId, userId);
                                    break;
                
                                case "/getid":
                                    handleGetIdCommand(chatId, userId);
                                    break;
                
                                default:
                                    sendMessage(chatId, "❓ Неизвестная команда. Используйте /help для списка команд.");
                            }
                
                        } catch (Exception e) {
                            logger.error("Error handling command: {}", e.getMessage(), e);
                            sendMessage(chatId, "❌ Ошибка: " + e.getMessage());
                        }
                    }
                
                    /**
                     * Обработка текстовых ответов
                     */
                    private void handleTextResponse(Long chatId, long userId, String text, Integer messageId) {
                        // Проверка состояния пользователя
                        String state = stateManager.getUserState((int) userId); // Приводим к int для stateManager
                
                        if (state == null) {
                            sendMessage(chatId, "Для работы с ботом используйте команды. /help - список команд");
                            return;
                        }
                
                        switch (state) {
                            case "AWAITING_QUERY":
                                // Добавление нового запроса
                                if (UserDataManager.addUserQuery(userId, text)) {
                                    sendMessage(chatId, "✅ Запрос добавлен: " + text);
                                    stateManager.clearUserState((int) userId);
                                } else {
                                    sendMessage(chatId, "⚠️ Этот запрос уже существует");
                                }
                                break;
                
                            case "AWAITING_SETTING_VALUE":
                                // Обработка значения настройки
                                handleSettingValue(chatId, userId, text);
                                break;
                
                            case "AWAITING_MIN_PRICE":
                            case "AWAITING_MAX_PRICE":
                                // Обработка ценового фильтра
                                handlePriceFilter(chatId, userId, state, text);
                                break;
                
                            default:
                                sendMessage(chatId, "Используйте команды для взаимодействия. /help - список команд");
                        }
                    }
                
                    /**
                     * Обработка callback запросов (инлайн-кнопки)
                     */
                    private void handleCallbackQuery(CallbackQuery callbackQuery) {
                        String callbackData = callbackQuery.getData();
                        Long chatId = callbackQuery.getMessage().getChatId();
                        long userId = chatId; // Используем chatId как userId
                        Integer messageId = callbackQuery.getMessage().getMessageId();
                
                        logger.debug("Callback from {}: {}", chatId, callbackData);
                
                        try {
                            // Подтверждение получения callback
                            answerCallbackQuery(callbackQuery.getId());
                
                            // Обработка callback данных
                            if (callbackData.startsWith("setting_")) {
                                handleSettingCallback(chatId, userId, callbackData, messageId);
                            } else if (callbackData.startsWith("page_")) {
                                handlePageCallback(chatId, userId, callbackData, messageId);
                            } else if (callbackData.equals("save_settings")) {
                                handleSaveSettings(chatId, userId, messageId);
                            } else if (callbackData.equals("cancel")) {
                                handleCancel(chatId, userId, messageId);
                            }
                
                        } catch (Exception e) {
                            logger.error("Error handling callback: {}", e.getMessage(), e);
                            sendMessage(chatId, "❌ Ошибка обработки запроса");
                        }
                    }
                
                    /**
                     * Команда /start
                     */
                    private void handleStart(Long chatId, long userId) {
                        logger.info("Processing /start for user {} (chat {})", userId, chatId);
                
                        // Проверяем текущий статус пользователя
                        boolean isInWhitelistBefore = WhitelistManager.isUserAllowed(userId);
                        logger.info("User {} in whitelist before /start: {}", userId, isInWhitelistBefore);
                
                        boolean isNewUser = WhitelistManager.addUser(userId);
                
                        // Получаем обновленный статус
                        boolean isInWhitelistAfter = WhitelistManager.isUserAllowed(userId);
                        logger.info("User {} in whitelist after /start: {} (isNewUser: {})",
                                userId, isInWhitelistAfter, isNewUser);
                
                        String welcomeMessage;
                        if (isNewUser) {
                            welcomeMessage = String.format("""
                                🎉 Добро пожаловать в Парсер товаров с динамическими куками!
                                
                                🆔 **Ваш ID:** `%d`
                                
                                🆕 **Новые возможности:**
                                • Автоматическое обновление кук через Selenium
                                • Динамическое получение свежих кук с сайта Goofish
                                • Автоматическое восстановление при ошибках авторизации
                                
                                📋 **Основные команды:**
                                /addquery [текст] - добавить поисковый запрос
                                /listqueries - список ваших запросов
                                /settings - настройки парсера
                                /start_parser - запустить парсер
                                /status - статус работы
                                /help - подробная справка
                                
                                👑 **Админские команды:**
                                /cookies - управление динамическими куками
                                
                                ⚡ **Быстрый старт:**
                                1. Добавьте запросы командой /addquery
                                2. Настройте параметры в /settings
                                3. Запустите парсер /start_parser
                                4. Получайте уведомления о новых товарах!
                                
                                Удачи в поисках выгодных предложений! 🛍️
                                """, userId);
                        } else {
                            welcomeMessage = String.format("""
                                👋 С возвращением!
                                
                                🆔 **Ваш ID:** `%d`
                                ✅ **В whitelist:** ДА
                                
                                Используйте /help для списка команд.
                                """, userId);
                        }
                
                        sendMessage(chatId, welcomeMessage);
                
                        // Дополнительная отладочная информация для новых пользователей
                        if (isNewUser) {
                            String debugInfo = String.format(
                                    "\n\n📊 **Отладочная информация:**\n" +
                                            "Ваш ID: %d\n" +
                                            "Добавлен в whitelist: ✅ ДА\n" +
                                            "Всего пользователей: %d",
                                    userId, WhitelistManager.getUserCount()
                            );
                            sendMessage(chatId, debugInfo);
                        }
                    }
                
                    /**
                     * Команда /getid - для получения ID
                     */
                    private void handleGetIdCommand(Long chatId, long userId) {
                        String message = String.format("""
                            🆔 **Ваши идентификаторы:**
                            
                            • **Chat ID:** `%d`
                            • **User ID для системы:** `%d`
                            
                            **Важно:** Используйте второй ID (`%d`) для регистрации.
                            
                            **Если ID отрицательный:** Это нормально для Telegram.
                            Система автоматически преобразует его.
                            """, chatId, userId, userId);
                
                        sendMessage(chatId, message);
                    }
                
                    /**
                     * Команда /checkwhitelist - для отладки
                     */
                    private void handleCheckWhitelist(Long chatId, long userId) {
                        boolean isInWhitelist = WhitelistManager.isUserAllowed(userId);
                        List<Long> allUsers = WhitelistManager.getAllUsers();
                
                        String message = String.format(
                                "📋 **Whitelist Status**\n\n" +
                                        "Ваш ID: `%d`\n" +
                                        "В whitelist: %s\n\n" +
                                        "Все пользователи в whitelist (%d):\n%s\n\n" +
                                        "**Отладочная информация:**\n" +
                                        "Путь к файлу: %s\n" +
                                        "Admin ID: %d\n" +
                                        "Ваш Chat ID: %d",
                                userId,
                                isInWhitelist ? "✅ YES" : "❌ NO",
                                allUsers.size(),
                                allUsers.isEmpty() ? "Пользователей пока нет" :
                                        allUsers.stream()
                                                .map(id -> "• " + id + (id == userId ? " (вы)" : ""))
                                                .collect(java.util.stream.Collectors.joining("\n")),
                                com.parser.storage.FileStorage.getFilePath("whitelist.txt"),
                                adminId,
                                chatId
                        );
                
                        sendMessage(chatId, message);
                    }
                
                    /**
                     * Команда /debug - дополнительная отладка
                     */
                    private void handleDebug(Long chatId, long userId) {
                        boolean isInWhitelist = WhitelistManager.isUserAllowed(userId);
                        List<Long> allUsers = WhitelistManager.getAllUsers();
                        boolean isParserRunning = threadManager.isUserParserRunning(userId);
                
                        String message = String.format(
                                "🔧 **Отладочная информация**\n\n" +
                                        "👤 **Пользователь:**\n" +
                                        "• User ID: %d\n" +
                                        "• Chat ID: %d\n" +
                                        "• В whitelist: %s\n\n" +
                                        "🤖 **Бот:**\n" +
                                        "• Admin ID: %d\n" +
                                        "• Вы админ: %s\n\n" +
                                        "🔄 **Парсер:**\n" +
                                        "• Парсер запущен: %s\n" +
                                        "• Активных пользователей: %d\n\n" +
                                        "📋 **Whitelist:**\n" +
                                        "• Всего пользователей: %d\n" +
                                        "• Пользователи: %s",
                                userId,
                                chatId,
                                isInWhitelist ? "✅ ДА" : "❌ НЕТ",
                                adminId,
                                (userId == adminId) ? "✅ ДА" : "❌ НЕТ",
                                isParserRunning ? "✅ ДА" : "❌ НЕТ",
                                threadManager.getActiveUsers().size(),
                                allUsers.size(),
                                allUsers.isEmpty() ? "Нет пользователей" :
                                        allUsers.stream()
                                                .map(String::valueOf)
                                                .collect(java.util.stream.Collectors.joining(", "))
                        );
                
                        sendMessage(chatId, message);
                    }
                
                    /**
                     * Команда /help
                     */
                    private void sendHelpMessage(Long chatId) {
                        String helpMessage = """
                            📚 **Справка по командам**
                            
                            🔑 **Получение ID:**
                            /getid - показать ваш Telegram ID
                            /checkwhitelist - проверить статус в белом списке
                            
                            🎯 **Управление запросами:**
                            /addquery [текст] - добавить поисковый запрос
                            /listqueries - показать все запросы
                            /removequery [номер] - удалить запрос
                            /clear queries - очистить все запросы
                            
                            ⚙️ **Настройки парсера:**
                            /settings - меню настроек
                            /stats - статистика работы
                            
                            ▶️ **Управление парсером:**
                            /start_parser - запустить парсер
                            /stop_parser - остановить парсер
                            /pause_parser - приостановить
                            /resume_parser - возобновить
                            /status - статус работы
                            
                            🍪 **Управление куками (админ):**
                            /cookies - меню управления динамическими куками
                            
                            🛠️ **Другие команды:**
                            /help - эта справка
                            /clear history - очистить историю товаров
                            /debug - отладочная информация
                            
                            🔄 **Новые возможности:**
                            • Автоматическое обновление кук через Selenium
                            • Динамические куки с сайта Goofish
                            • Самовосстановление при ошибках
                            
                            💡 **Совет:** Используйте точные запросы для лучших результатов.
                            """;
                
                        sendMessage(chatId, helpMessage);
                    }
                
                    /**
                     * Команда /status
                     */
                    private void handleStatus(Long chatId, long userId) {
                        Map<String, Object> status = threadManager.getUserStatus(userId);
                
                        if (status == null) {
                            String message = """
                                📊 **Статус парсера**
                                
                                🔴 Парсер не запущен
                                
                                Чтобы начать работу:
                                1. Добавьте запросы: /addquery [текст]
                                2. Настройте параметры: /settings
                                3. Запустите парсер: /start_parser
                                """;
                            sendMessage(chatId, message);
                            return;
                        }
                
                        StringBuilder message = new StringBuilder();
                        message.append("📊 **Статус парсера**\n\n");
                
                        boolean isRunning = (Boolean) status.get("running");
                        boolean isPaused = (Boolean) status.get("paused");
                
                        if (isRunning && !isPaused) {
                            message.append("🟢 **Запущен**\n");
                        } else if (isPaused) {
                            message.append("⏸ **Приостановлен**\n");
                        } else {
                            message.append("🔴 **Остановлен**\n");
                        }
                
                        message.append("\n📈 **Статистика:**\n");
                        message.append("Найдено товаров: ").append(status.get("totalProductsFound")).append("\n");
                        message.append("Выполнено запросов: ").append(status.get("requestsMade")).append("\n");
                        message.append("Ошибок: ").append(status.get("errorsCount")).append("\n");
                
                        if (status.get("uptime") != null) {
                            message.append("Время работы: ").append(status.get("uptime")).append("\n");
                        }
                
                        message.append("Активных запросов: ").append(status.get("queriesCount")).append("\n");
                
                        // Кнопки управления
                        InlineKeyboardMarkup keyboard = createStatusKeyboard(isRunning, isPaused);
                        SendMessage sendMessage = new SendMessage();
                        sendMessage.setChatId(chatId.toString());
                        sendMessage.setText(message.toString());
                        sendMessage.setReplyMarkup(keyboard);
                        sendMessage.enableMarkdown(true);
                
                        try {
                            execute(sendMessage);
                        } catch (TelegramApiException e) {
                            logger.error("Error sending status message: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Создание клавиатуры для статуса
                     */
                    private InlineKeyboardMarkup createStatusKeyboard(boolean isRunning, boolean isPaused) {
                        InlineKeyboardMarkup keyboard = new InlineKeyboardMarkup();
                        List<List<InlineKeyboardButton>> rows = new ArrayList<>();
                
                        if (isRunning && !isPaused) {
                            // Парсер запущен
                            rows.add(List.of(
                                    createButton("⏸ Приостановить", "pause_parser"),
                                    createButton("🛑 Остановить", "stop_parser")
                            ));
                        } else if (isPaused) {
                            // Парсер приостановлен
                            rows.add(List.of(
                                    createButton("▶️ Возобновить", "resume_parser"),
                                    createButton("🛑 Остановить", "stop_parser")
                            ));
                        } else {
                            // Парсер остановлен
                            rows.add(List.of(
                                    createButton("▶️ Запустить", "start_parser")
                            ));
                        }
                
                        rows.add(List.of(
                                createButton("⚙️ Настройки", "settings"),
                                createButton("📋 Запросы", "listqueries")
                        ));
                
                        keyboard.setKeyboard(rows);
                        return keyboard;
                    }
                
                    /**
                     * Команда /addquery
                     */
                    private void handleAddQuery(Long chatId, long userId, String query) {
                        if (query == null || query.trim().isEmpty()) {
                            // Запрашиваем запрос у пользователя
                            stateManager.setUserState((int) userId, "AWAITING_QUERY");
                            sendMessage(chatId, "Введите поисковый запрос:");
                            return;
                        }
                
                        if (UserDataManager.addUserQuery(userId, query.trim())) {
                            sendMessage(chatId, "✅ Запрос добавлен: " + query);
                        } else {
                            sendMessage(chatId, "⚠️ Этот запрос уже существует");
                        }
                    }
                
                    /**
                     * Команда /listqueries
                     */
                    private void handleListQueries(Long chatId, long userId) {
                        List<String> queries = UserDataManager.getUserQueries(userId);
                
                        if (queries.isEmpty()) {
                            sendMessage(chatId, "📭 У вас нет поисковых запросов.\n" +
                                    "Добавьте запрос командой /addquery [текст]");
                            return;
                        }
                
                        StringBuilder message = new StringBuilder();
                        message.append("📋 **Ваши поисковые запросы:**\n\n");
                
                        for (int i = 0; i < queries.size(); i++) {
                            message.append(i + 1).append(". ").append(queries.get(i)).append("\n");
                        }
                
                        message.append("\n**Управление:**\n");
                        message.append("/removequery [номер] - удалить запрос\n");
                        message.append("/addquery [текст] - добавить новый\n");
                        message.append("/clear queries - очистить все");
                
                        sendMessage(chatId, message.toString());
                    }
                
                    /**
                     * Команда /removequery
                     */
                    private void handleRemoveQuery(Long chatId, long userId, String arg) {
                        try {
                            if (arg == null || arg.trim().isEmpty()) {
                                sendMessage(chatId, "Используйте: /removequery [номер]\n" +
                                        "Номер можно посмотреть в /listqueries");
                                return;
                            }
                
                            int index = Integer.parseInt(arg.trim()) - 1;
                            List<String> queries = UserDataManager.getUserQueries(userId);
                
                            if (index < 0 || index >= queries.size()) {
                                sendMessage(chatId, "❌ Неверный номер запроса");
                                return;
                            }
                
                            String removedQuery = queries.get(index);
                            UserDataManager.removeUserQuery(userId, removedQuery);
                
                            sendMessage(chatId, "✅ Запрос удален: " + removedQuery);
                
                        } catch (NumberFormatException e) {
                            sendMessage(chatId, "❌ Неверный формат номера");
                        }
                    }
                
                    /**
                     * Меню настроек
                     */
                    private void showSettingsMenu(Long chatId, long userId) {
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                
                        InlineKeyboardMarkup keyboard = new InlineKeyboardMarkup();
                        List<List<InlineKeyboardButton>> rows = new ArrayList<>();
                
                        // Основные настройки
                        rows.add(List.of(
                                createButton("⏱️ Интервал: " + settings.getCheckInterval() + " сек",
                                        "setting_check_interval")
                        ));
                
                        rows.add(List.of(
                                createButton("📅 Возраст: " + settings.getMaxAgeMinutes() + " мин",
                                        "setting_max_age")
                        ));
                
                        rows.add(List.of(
                                createButton("📄 Страниц: " + settings.getMaxPages(),
                                        "setting_max_pages")
                        ));
                
                        rows.add(List.of(
                                createButton("🛒 Товаров на стр: " + settings.getRowsPerPage(),
                                        "setting_rows_per_page")
                        ));
                
                        // Валюта
                        String currencyText = settings.getPriceCurrency().equals("rubles") ? "🇷🇺 Рубли" : "¥ Юани";
                        rows.add(List.of(
                                createButton("💰 Валюта: " + currencyText, "setting_price_currency")
                        ));
                
                        // Уведомления
                        String notifyText = settings.isNotifyNewOnly() ? "Только новые" : "Все";
                        rows.add(List.of(
                                createButton("🔔 Уведомления: " + notifyText, "setting_notify_new_only")
                        ));
                
                        // Дополнительные настройки
                        rows.add(List.of(
                                createButton("⚙️ Дополнительно", "setting_advanced")
                        ));
                
                        // Управление
                        rows.add(List.of(
                                createButton("💾 Сохранить", "save_settings"),
                                createButton("❌ Отмена", "cancel")
                        ));
                
                        keyboard.setKeyboard(rows);
                
                        String messageText = """
                            ⚙️ **Настройки парсера**
                            
                            Текущие параметры:
                            • Интервал проверки: %d сек
                            • Макс. возраст товара: %d мин
                            • Страниц для парсинга: %d
                            • Товаров на странице: %d
                            • Валюта отображения: %s
                            • Уведомления: %s
                            
                            Выберите параметр для изменения:
                            """.formatted(
                                settings.getCheckInterval(),
                                settings.getMaxAgeMinutes(),
                                settings.getMaxPages(),
                                settings.getRowsPerPage(),
                                currencyText,
                                notifyText
                        );
                
                        SendMessage message = new SendMessage();
                        message.setChatId(chatId.toString());
                        message.setText(messageText);
                        message.setReplyMarkup(keyboard);
                
                        try {
                            execute(message);
                        } catch (TelegramApiException e) {
                            logger.error("Error showing settings menu: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Обработка callback настроек
                     */
                    private void handleSettingCallback(Long chatId, long userId, String callbackData, Integer messageId) {
                        String setting = callbackData.substring(8); // Убираем "setting_"
                
                        switch (setting) {
                            case "check_interval":
                                requestSettingValue(chatId, userId, "Интервал проверки (сек)",
                                        "10-3600", "check_interval");
                                break;
                
                            case "max_age":
                                requestSettingValue(chatId, userId, "Максимальный возраст товара (мин)",
                                        "1-10080", "max_age_minutes");
                                break;
                
                            case "max_pages":
                                requestSettingValue(chatId, userId, "Количество страниц",
                                        "1-50", "max_pages");
                                break;
                
                            case "rows_per_page":
                                requestSettingValue(chatId, userId, "Товаров на странице",
                                        "10-1000", "rows_per_page");
                                break;
                
                            case "price_currency":
                                togglePriceCurrency(chatId, userId, messageId);
                                break;
                
                            case "notify_new_only":
                                toggleNotifyNewOnly(chatId, userId, messageId);
                                break;
                
                            case "advanced":
                                showAdvancedSettings(chatId, userId);
                                break;
                        }
                    }
                
                    /**
                     * Запрос значения настройки у пользователя
                     */
                    private void requestSettingValue(Long chatId, long userId, String settingName,
                                                     String range, String settingKey) {
                        stateManager.setUserState((int) userId, "AWAITING_SETTING_VALUE");
                        stateManager.setUserData((int) userId, "setting_key", settingKey);
                
                        String message = String.format("""
                            ✏️ **%s**
                            
                            Введите новое значение:
                            Допустимый диапазон: %s
                            
                            Например: 300
                            """, settingName, range);
                
                        sendMessage(chatId, message);
                    }
                
                    /**
                     * Обработка введенного значения настройки
                     */
                    private void handleSettingValue(Long chatId, long userId, String value) {
                        String settingKey = stateManager.getUserData((int) userId, "setting_key");
                
                        if (settingKey == null) {
                            sendMessage(chatId, "❌ Ошибка: не указана настройка");
                            stateManager.clearUserState((int) userId);
                            return;
                        }
                
                        try {
                            int intValue = Integer.parseInt(value.trim());
                            UserSettings settings = UserDataManager.getUserSettings(userId);
                
                            switch (settingKey) {
                                case "check_interval":
                                    settings.setCheckInterval(intValue);
                                    break;
                                case "max_age_minutes":
                                    settings.setMaxAgeMinutes(intValue);
                                    break;
                                case "max_pages":
                                    settings.setMaxPages(intValue);
                                    break;
                                case "rows_per_page":
                                    settings.setRowsPerPage(intValue);
                                    break;
                            }
                
                            UserDataManager.saveUserSettings(userId, settings);
                            sendMessage(chatId, "✅ Настройка сохранена");
                
                        } catch (NumberFormatException e) {
                            sendMessage(chatId, "❌ Неверный формат числа");
                        } finally {
                            stateManager.clearUserState((int) userId);
                        }
                    }
                
                    /**
                     * Переключение валюты
                     */
                    private void togglePriceCurrency(Long chatId, long userId, Integer messageId) {
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                
                        if ("rubles".equals(settings.getPriceCurrency())) {
                            settings.setPriceCurrency("yuan");
                        } else {
                            settings.setPriceCurrency("rubles");
                        }
                
                        UserDataManager.saveUserSettings(userId, settings);
                
                        // Обновляем сообщение с настройками
                        showSettingsMenu(chatId, userId);
                
                        // Удаляем старое сообщение
                        if (messageId != null) {
                            deleteMessage(chatId, messageId);
                        }
                    }
                
                    /**
                     * Переключение режима уведомлений
                     */
                    private void toggleNotifyNewOnly(Long chatId, long userId, Integer messageId) {
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                        settings.setNotifyNewOnly(!settings.isNotifyNewOnly());
                        UserDataManager.saveUserSettings(userId, settings);
                
                        showSettingsMenu(chatId, userId);
                
                        if (messageId != null) {
                            deleteMessage(chatId, messageId);
                        }
                    }
                
                    /**
                     * Показать расширенные настройки
                     */
                    private void showAdvancedSettings(Long chatId, long userId) {
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                
                        InlineKeyboardMarkup keyboard = new InlineKeyboardMarkup();
                        List<List<InlineKeyboardButton>> rows = new ArrayList<>();
                
                        // Ценовые фильтры
                        String minPrice = settings.getMinPrice() > 0 ? String.valueOf(settings.getMinPrice()) : "Нет";
                        String maxPrice = settings.getMaxPrice() > 0 ? String.valueOf(settings.getMaxPrice()) : "Нет";
                
                        rows.add(List.of(
                                createButton("💰 Мин. цена: " + minPrice, "setting_min_price"),
                                createButton("💰 Макс. цена: " + maxPrice, "setting_max_price")
                        ));
                
                        // Задержка запросов
                        rows.add(List.of(
                                createButton("⏱️ Задержка: " + settings.getRequestDelay() + " мс",
                                        "setting_request_delay")
                        ));
                
                        // Максимальное количество повторов
                        rows.add(List.of(
                                createButton("🔄 Повторов: " + settings.getMaxRetries(),
                                        "setting_max_retries")
                        ));
                
                        // Назад
                        rows.add(List.of(
                                createButton("🔙 Назад", "settings")
                        ));
                
                        keyboard.setKeyboard(rows);
                
                        String messageText = """
                            ⚙️ **Расширенные настройки**
                            
                            Текущие параметры:
                            • Минимальная цена: %s
                            • Максимальная цена: %s
                            • Задержка между запросами: %d мс
                            • Макс. количество повторов: %d
                            
                            Выберите параметр для изменения:
                            """.formatted(
                                minPrice,
                                maxPrice,
                                settings.getRequestDelay(),
                                settings.getMaxRetries()
                        );
                
                        SendMessage message = new SendMessage();
                        message.setChatId(chatId.toString());
                        message.setText(messageText);
                        message.setReplyMarkup(keyboard);
                
                        try {
                            execute(message);
                        } catch (TelegramApiException e) {
                            logger.error("Error showing advanced settings: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Обработка ценового фильтра
                     */
                    private void handlePriceFilter(Long chatId, long userId, String state, String value) {
                        try {
                            double price = Double.parseDouble(value.trim());
                            UserSettings settings = UserDataManager.getUserSettings(userId);
                
                            if ("AWAITING_MIN_PRICE".equals(state)) {
                                settings.setMinPrice(price);
                                sendMessage(chatId, "✅ Минимальная цена установлена: " + price);
                            } else {
                                settings.setMaxPrice(price);
                                sendMessage(chatId, "✅ Максимальная цена установлена: " + price);
                            }
                
                            UserDataManager.saveUserSettings(userId, settings);
                            stateManager.clearUserState((int) userId);
                
                        } catch (NumberFormatException e) {
                            sendMessage(chatId, "❌ Неверный формат цены");
                        }
                    }
                
                    /**
                     * Сохранение настроек
                     */
                    private void handleSaveSettings(Long chatId, long userId, Integer messageId) {
                        UserSettings settings = UserDataManager.getUserSettings(userId);
                
                        if (!settings.isValid()) {
                            sendMessage(chatId, "❌ Некорректные настройки. Проверьте значения.");
                            return;
                        }
                
                        UserDataManager.saveUserSettings(userId, settings);
                
                        String message = """
                            ✅ **Настройки сохранены!**
                            
                            Текущие параметры:
                            • Интервал проверки: %d сек
                            • Макс. возраст товара: %d мин (%d ч)
                            • Страниц для парсинга: %d
                            • Товаров на странице: %d
                            • Валюта: %s
                            
                            Для запуска парсера используйте /start_parser
                            """.formatted(
                                settings.getCheckInterval(),
                                settings.getMaxAgeMinutes(),
                                settings.getMaxAgeMinutes() / 60,
                                settings.getMaxPages(),
                                settings.getRowsPerPage(),
                                settings.getPriceCurrency().equals("rubles") ? "Рубли" : "Юани"
                        );
                
                        sendMessage(chatId, message);
                
                        if (messageId != null) {
                            deleteMessage(chatId, messageId);
                        }
                    }
                
                    /**
                     * Команда /start_parser
                     */
                    private void handleStartParser(Long chatId, long userId) {
                        logger.info("User {} requested to start parser", userId);
                
                        // Проверяем whitelist перед запуском
                        if (!WhitelistManager.isUserAllowed(userId)) {
                            logger.warn("User {} not in whitelist, cannot start parser", userId);
                            sendMessage(chatId, "⛔ Вы не авторизованы для использования парсера.\n" +
                                    "Используйте команду /start для регистрации");
                            return;
                        }
                
                        if (threadManager.startUserParser(userId)) {
                            sendMessage(chatId, "✅ Парсер успешно запущен!");
                        } else {
                            sendMessage(chatId, "❌ Не удалось запустить парсер. Проверьте логи.");
                        }
                    }
                
                    /**
                     * Команда /stop_parser
                     */
                    private void handleStopParser(Long chatId, long userId) {
                        if (threadManager.stopUserParser(userId)) {
                            sendMessage(chatId, "🛑 Парсер остановлен");
                        } else {
                            sendMessage(chatId, "ℹ️ Парсер не был запущен");
                        }
                    }
                
                    /**
                     * Команда /pause_parser
                     */
                    private void handlePauseParser(Long chatId, long userId) {
                        if (threadManager.pauseUserParser(userId)) {
                            sendMessage(chatId, "⏸ Парсер приостановлен");
                        } else {
                            sendMessage(chatId, "ℹ️ Парсер не запущен или уже приостановлен");
                        }
                    }
                
                    /**
                     * Команда /resume_parser
                     */
                    private void handleResumeParser(Long chatId, long userId) {
                        if (threadManager.resumeUserParser(userId)) {
                            sendMessage(chatId, "▶️ Парсер возобновлен");
                        } else {
                            sendMessage(chatId, "ℹ️ Парсер не был приостановлен");
                        }
                    }
                
                    /**
                     * Команда /stats
                     */
                    private void handleStats(Long chatId, long userId) {
                        Map<String, Object> userStats = threadManager.getUserStatus(userId);
                        Map<String, Object> globalStats = threadManager.getGlobalStatistics();
                
                        StringBuilder message = new StringBuilder();
                        message.append("📊 **Статистика**\n\n");
                
                        if (userStats != null) {
                            message.append("👤 **Ваша статистика:**\n");
                            message.append("Найдено товаров: ").append(userStats.get("totalProductsFound")).append("\n");
                            message.append("Выполнено запросов: ").append(userStats.get("requestsMade")).append("\n");
                            message.append("Ошибок: ").append(userStats.get("errorsCount")).append("\n");
                
                            if (userStats.get("uptime") != null) {
                                message.append("Время работы: ").append(userStats.get("uptime")).append("\n");
                            }
                            message.append("\n");
                        }
                
                        message.append("🌐 **Общая статистика:**\n");
                        message.append("Активных пользователей: ").append(globalStats.get("totalUsers")).append("\n");
                        message.append("Всего найдено товаров: ").append(globalStats.get("totalProductsFound")).append("\n");
                        message.append("Всего запросов: ").append(globalStats.get("totalRequestsMade")).append("\n");
                
                        long uptime = (Long) globalStats.get("uptime");
                        long hours = uptime / (1000 * 60 * 60);
                        long minutes = (uptime % (1000 * 60 * 60)) / (1000 * 60);
                        message.append("Время работы сервиса: ").append(hours).append("ч ").append(minutes).append("м\n");
                
                        message.append("Активных потоков: ").append(globalStats.get("activeThreads")).append("\n");
                        message.append("Размер пула: ").append(globalStats.get("poolSize")).append("\n");
                
                        // Добавляем статистику кук
                        Map<String, Object> cookieStats = CookieService.getCacheStats();
                        message.append("\n🍪 **Статистика кук:**\n");
                        message.append("Динамические куки: ").append(Config.isDynamicCookiesEnabled() ? "Включено" : "Выключено").append("\n");
                        message.append("Последнее обновление: ").append(cookieStats.get("lastRefreshTime")).append("\n");
                
                        sendMessage(chatId, message.toString());
                    }
                
                    /**
                     * Команда /clear
                     */
                    private void handleClear(Long chatId, long userId, String arg) {
                        if (arg == null || arg.trim().isEmpty()) {
                            sendMessage(chatId, """
                                🗑️ **Очистка данных**
                                
                                Доступные опции:
                                /clear queries - очистить все поисковые запросы
                                /clear history - очистить историю найденных товаров
                                /clear settings - сбросить настройки к значениям по умолчанию
                                """);
                            return;
                        }
                
                        String option = arg.trim().toLowerCase();
                
                        switch (option) {
                            case "queries":
                                UserDataManager.clearUserQueries(userId);
                                sendMessage(chatId, "✅ Все поисковые запросы очищены");
                                break;
                
                            case "history":
                                UserDataManager.clearUserProducts(userId);
                                sendMessage(chatId, "✅ История товаров очищена");
                                break;
                
                            case "settings":
                                UserSettings defaultSettings = new UserSettings();
                                UserDataManager.saveUserSettings(userId, defaultSettings);
                                sendMessage(chatId, "✅ Настройки сброшены к значениям по умолчанию");
                                break;
                
                            default:
                                sendMessage(chatId, "❌ Неверная опция очистки");
                        }
                    }
                
                    /**
                     * Админские команды
                     */
                    private void handleAdmin(Long chatId, long userId, String arg) {
                        if (userId != adminId) {
                            sendMessage(chatId, "⛔ У вас нет прав администратора");
                            return;
                        }
                
                        if (arg == null || arg.trim().isEmpty()) {
                            showAdminMenu(chatId);
                            return;
                        }
                
                        String[] parts = arg.split(" ", 2);
                        String command = parts[0].toLowerCase();
                        String param = parts.length > 1 ? parts[1] : "";
                
                        switch (command) {
                            case "stats":
                                showAdminStats(chatId);
                                break;
                
                            case "users":
                                showAdminUsers(chatId);
                                break;
                
                            case "adduser":
                                handleAdminAddUser(chatId, param);
                                break;
                
                            case "removeuser":
                                handleAdminRemoveUser(chatId, param);
                                break;
                
                            case "broadcast":
                                handleAdminBroadcast(chatId, param);
                                break;
                
                            case "restart":
                                handleAdminRestart(chatId);
                                break;
                
                            default:
                                sendMessage(chatId, "❌ Неизвестная админская команда");
                        }
                    }
                
                    /**
                     * Меню администратора
                     */
                    private void showAdminMenu(Long chatId) {
                        String menu = """
                            👑 **Панель администратора**
                            
                            Доступные команды:
                            /admin stats - подробная статистика
                            /admin users - список пользователей
                            /admin adduser [id] - добавить пользователя
                            /admin removeuser [id] - удалить пользователя
                            /admin broadcast [текст] - рассылка всем
                            /admin restart - перезапуск парсеров
                            
                            Пользователей в системе: %d
                            """.formatted(WhitelistManager.getAllUsers().size());
                
                        sendMessage(chatId, menu);
                    }
                
                    /**
                     * Команда /cookies (только для админа)
                     */
                    private void handleCookiesCommand(Long chatId, long userId, String arg) {
                        if (userId != adminId) {
                            sendMessage(chatId, "⛔ Only admin can use this command");
                            return;
                        }
                
                        if (arg == null || arg.trim().isEmpty()) {
                            showCookiesMenu(chatId);
                            return;
                        }
                
                        String[] parts = arg.split(" ", 2);
                        String command = parts[0].toLowerCase();
                        String param = parts.length > 1 ? parts[1] : "";
                
                        switch (command) {
                            case "refresh":
                                refreshCookies(chatId, param);
                                break;
                            case "status":
                                showCookiesStats(chatId);
                                break;
                            case "clear":
                                clearCookies(chatId, param);
                                break;
                            default:
                                sendMessage(chatId, "❌ Unknown command. Use /cookies for menu");
                        }
                    }
                
                    /**
                     * Меню управления куки
                     */
                    private void showCookiesMenu(Long chatId) {
                        String menu = """
                        🍪 **Управление cookies через Selenium**
                        
                        🆕 *Новые команды:*
                        /cookies refresh goofish - получить свежие cookies для Goofish
                        /cookies status - статус cookies
                        /cookies clear - очистить кэш
                        
                        ⚙️ *Настройки:*
                        • Автоматическое обновление: каждые 25 минут
                        • Кэширование: 20 минут
                        
                        Cookies обновляются автоматически через Selenium.
                        Если парсер не работает, используйте /cookies refresh goofish
                        """;
                
                        sendMessage(chatId, menu);
                    }
                
                    /**
                     * Обновление cookies
                     */
                    private void refreshCookies(Long chatId, String domain) {
                        String site = domain.trim();
                        if (site.isEmpty()) {
                            site = "goofish";
                        }
                
                        sendMessage(chatId, "🔄 Refreshing cookies for " + site + "...");
                
                        try {
                            boolean success = CookieService.refreshCookies(site);
                            if (success) {
                                sendMessage(chatId, String.format(
                                        "✅ Cookies successfully refreshed\n" +
                                                "Time: %s",
                                        new java.util.Date()
                                ));
                            } else {
                                sendMessage(chatId, "❌ Failed to refresh cookies");
                            }
                        } catch (Exception e) {
                            logger.error("Error refreshing cookies: {}", e.getMessage());
                            sendMessage(chatId, "❌ Error: " + e.getMessage());
                        }
                    }
                
                    /**
                     * Обновление cookies через GUI
                     */
                    private void refreshCookiesWithGUI(Long chatId, String domain) {
                        String targetDomain = domain.trim();
                        if (targetDomain.isEmpty()) {
                            targetDomain = "h5api.m.goofish.com";
                        }
                
                        sendMessage(chatId, "🔄 Получаю свежие cookies через Selenium с GUI для " + targetDomain + "...");
                
                        try {
                            boolean success = CookieService.refreshCookies(targetDomain);
                            if (success) {
                                sendMessage(chatId, String.format(
                                        "✅ Cookies успешно обновлены через GUI\n" +
                                                "Время: %s",
                                        new Date()
                                ));
                            } else {
                                sendMessage(chatId, "❌ Не удалось получить свежие cookies через GUI");
                            }
                        } catch (Exception e) {
                            logger.error("Error refreshing cookies with GUI: {}", e.getMessage());
                            sendMessage(chatId, "❌ Ошибка при обновлении cookies через GUI: " + e.getMessage());
                        }
                    }
                
                    /**
                     * Очистка cookies
                     */
                    private void clearCookies(Long chatId, String domain) {
                        try {
                            CookieService.clearCache();
                            sendMessage(chatId, "✅ Cookie cache cleared");
                        } catch (Exception e) {
                            logger.error("Error clearing cookies: {}", e.getMessage());
                            sendMessage(chatId, "❌ Error: " + e.getMessage());
                        }
                    }
                
                
                    /**
                     * Статистика cookies
                     */
                    private void showCookiesStats(Long chatId) {
                        try {
                            Map<String, Object> stats = CookieService.getStats();
                
                            StringBuilder message = new StringBuilder();
                            message.append("📊 **Cookie Statistics**\n\n");
                
                            message.append("⚙️ *Settings:*\n");
                            message.append("Cache TTL: ").append(stats.get("cache_ttl_minutes")).append(" minutes\n");
                            message.append("Auto-refresh: every 25 minutes\n\n");
                
                            message.append("🌐 *Sites:*\n");
                            @SuppressWarnings("unchecked")
                            Map<String, Object> sites = (Map<String, Object>) stats.get("sites");
                            if (sites != null && !sites.isEmpty()) {
                                for (Map.Entry<String, Object> entry : sites.entrySet()) {
                                    @SuppressWarnings("unchecked")
                                    Map<String, Object> siteData = (Map<String, Object>) entry.getValue();
                                    message.append("• ").append(entry.getKey()).append(": ");
                                    message.append(siteData.get("cookies")).append(" cookies, ");
                                    message.append("age: ").append(siteData.get("age_minutes")).append("m\n");
                                }
                            } else {
                                message.append("No cached cookies yet\n");
                            }
                
                            sendMessage(chatId, message.toString());
                
                        } catch (Exception e) {
                            logger.error("Error showing cookie stats: {}", e.getMessage());
                            sendMessage(chatId, "❌ Error: " + e.getMessage());
                        }
                    }
                
                    /**
                     * Переключение динамических cookies
                     */
                    private void toggleDynamicCookies(Long chatId) {
                        boolean current = Config.isDynamicCookiesEnabled();
                        Config.setProperty("cookie.dynamic.enabled", String.valueOf(!current));
                        Config.saveConfig();
                
                        if (!current) {
                            sendMessage(chatId, "✅ Динамические cookies включены");
                        } else {
                            sendMessage(chatId, "✅ Динамические cookies выключены");
                        }
                    }
                
                    // Вспомогательные методы
                
                    private void sendMessage(Long chatId, String text) {
                        SendMessage message = new SendMessage();
                        message.setChatId(chatId.toString());
                        message.setText(text);
                        message.enableMarkdown(true);
                
                        try {
                            execute(message);
                        } catch (TelegramApiException e) {
                            logger.error("Error sending message to {}: {}", chatId, e.getMessage());
                        }
                    }
                
                    private void deleteMessage(Long chatId, Integer messageId) {
                        DeleteMessage deleteMessage = new DeleteMessage();
                        deleteMessage.setChatId(chatId.toString());
                        deleteMessage.setMessageId(messageId);
                
                        try {
                            execute(deleteMessage);
                        } catch (TelegramApiException e) {
                            logger.error("Error deleting message: {}", e.getMessage());
                        }
                    }
                
                    private void answerCallbackQuery(String callbackId) {
                        AnswerCallbackQuery answer = new AnswerCallbackQuery();
                        answer.setCallbackQueryId(callbackId);
                
                        try {
                            execute(answer);
                        } catch (TelegramApiException e) {
                            logger.error("Error answering callback query: {}", e.getMessage());
                        }
                    }
                
                    private InlineKeyboardButton createButton(String text, String callbackData) {
                        return InlineKeyboardButton.builder()
                                .text(text)
                                .callbackData(callbackData)
                                .build();
                    }
                
                    private void handleCancel(Long chatId, long userId, Integer messageId) {
                        stateManager.clearUserState((int) userId);
                        sendMessage(chatId, "❌ Действие отменено");
                
                        if (messageId != null) {
                            deleteMessage(chatId, messageId);
                        }
                    }
                
                    private void handlePageCallback(Long chatId, long userId, String callbackData, Integer messageId) {
                        // Реализация пагинации
                        // В реальном проекте здесь будет обработка переключения страниц
                    }
                
                    private void registerCommands() {
                        try {
                            List<BotCommand> commands = new ArrayList<>();
                            commands.add(new BotCommand("start", "Запустить бота"));
                            commands.add(new BotCommand("help", "Помощь и справка"));
                            commands.add(new BotCommand("addquery", "Добавить поисковый запрос"));
                            commands.add(new BotCommand("listqueries", "Список запросов"));
                            commands.add(new BotCommand("settings", "Настройки парсера"));
                            commands.add(new BotCommand("status", "Статус работы"));
                            commands.add(new BotCommand("start_parser", "Запустить парсер"));
                            commands.add(new BotCommand("stop_parser", "Остановить парсер"));
                            commands.add(new BotCommand("stats", "Статистика"));
                            commands.add(new BotCommand("cookies", "Управление куками (админ)"));
                            commands.add(new BotCommand("checkwhitelist", "Проверить whitelist"));
                            commands.add(new BotCommand("debug", "Отладочная информация"));
                            commands.add(new BotCommand("getid", "Получить свой ID"));
                
                            this.execute(new org.telegram.telegrambots.meta.api.methods.commands.SetMyCommands(
                                    commands, new BotCommandScopeDefault(), null
                            ));
                
                            logger.info("Bot commands registered");
                        } catch (TelegramApiException e) {
                            logger.error("Error registering commands: {}", e.getMessage());
                        }
                    }
                
                    private void showAdminStats(Long chatId) {
                        Map<String, Object> stats = threadManager.getGlobalStatistics();
                        Map<String, Object> cookieStats = CookieService.getCacheStats();
                
                        StringBuilder message = new StringBuilder();
                        message.append("📊 **Админская статистика**\n\n");
                
                        message.append("👥 **Пользователи:**\n");
                        message.append("Всего пользователей: ").append(WhitelistManager.getUserCount()).append("\n");
                        message.append("Активных сессий: ").append(stats.get("totalUsers")).append("\n");
                
                        message.append("\n⚙️ **Система:**\n");
                        message.append("Всего товаров найдено: ").append(stats.get("totalProductsFound")).append("\n");
                        message.append("Всего запросов: ").append(stats.get("totalRequestsMade")).append("\n");
                        message.append("Активных потоков: ").append(stats.get("activeThreads")).append("/").append(stats.get("poolSize")).append("\n");
                
                        long uptime = (Long) stats.get("uptime");
                        long days = uptime / (1000 * 60 * 60 * 24);
                        long hours = (uptime % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60);
                        long minutes = (uptime % (1000 * 60 * 60)) / (1000 * 60);
                        message.append("Время работы: ").append(days).append("д ").append(hours).append("ч ").append(minutes).append("м\n");
                
                        message.append("\n🍪 **Cookies:**\n");
                        message.append("Динамические cookies: ").append(Config.isDynamicCookiesEnabled() ? "Включено" : "Выключено").append("\n");
                        message.append("Последнее обновление: ").append(cookieStats.get("lastRefreshTime")).append("\n");
                
                        sendMessage(chatId, message.toString());
                    }
                
                    private void showAdminUsers(Long chatId) {
                        List<Long> users = WhitelistManager.getAllUsers();
                
                        if (users.isEmpty()) {
                            sendMessage(chatId, "📭 Нет пользователей в системе");
                            return;
                        }
                
                        StringBuilder message = new StringBuilder();
                        message.append("👥 **Список пользователей**\n\n");
                        message.append("Всего пользователей: ").append(users.size()).append("\n\n");
                
                        // Показываем первых 20 пользователей
                        int count = Math.min(20, users.size());
                        for (int i = 0; i < count; i++) {
                            long userId = users.get(i);
                            boolean isActive = threadManager.isUserParserRunning(userId);
                            message.append(i + 1).append(". ID: ").append(userId);
                            message.append(isActive ? " 🟢" : " 🔴").append("\n");
                        }
                
                        if (users.size() > 20) {
                            message.append("\n... и еще ").append(users.size() - 20).append(" пользователей");
                        }
                
                        message.append("\n\n**Команды управления:**\n");
                        message.append("/admin adduser [id] - добавить пользователя\n");
                        message.append("/admin removeuser [id] - удалить пользователя");
                
                        sendMessage(chatId, message.toString());
                    }
                
                    private void handleAdminAddUser(Long chatId, String param) {
                        if (param == null || param.trim().isEmpty()) {
                            sendMessage(chatId, "⚠️ Используйте: /admin adduser [id]\nПример: /admin adduser 123456789");
                            return;
                        }
                
                        try {
                            long userId = Long.parseLong(param.trim());
                            if (WhitelistManager.addUser(userId)) {
                                sendMessage(chatId, "✅ Пользователь " + userId + " добавлен в белый список");
                            } else {
                                sendMessage(chatId, "ℹ️ Пользователь " + userId + " уже в белом списке");
                            }
                        } catch (NumberFormatException e) {
                            sendMessage(chatId, "❌ Неверный формат ID пользователя");
                        }
                    }
                
                    private void handleAdminRemoveUser(Long chatId, String param) {
                        if (param == null || param.trim().isEmpty()) {
                            sendMessage(chatId, "⚠️ Используйте: /admin removeuser [id]\nПример: /admin removeuser 123456789");
                            return;
                        }
                
                        try {
                            long userId = Long.parseLong(param.trim());
                            if (WhitelistManager.removeUser(userId)) {
                                sendMessage(chatId, "✅ Пользователь " + userId + " удален из белого списка");
                
                                // Останавливаем парсер пользователя, если он запущен
                                threadManager.stopUserParser(userId);
                            } else {
                                sendMessage(chatId, "ℹ️ Пользователь " + userId + " не найден в белом списке");
                            }
                        } catch (NumberFormatException e) {
                            sendMessage(chatId, "❌ Неверный формат ID пользователя");
                        }
                    }
                
                    private void handleAdminBroadcast(Long chatId, String param) {
                        if (param == null || param.trim().isEmpty()) {
                            sendMessage(chatId, "⚠️ Используйте: /admin broadcast [текст]\nПример: /admin broadcast Обновление системы");
                            return;
                        }
                
                        String message = param.trim();
                        List<Long> users = WhitelistManager.getAllUsers();
                        int sent = 0;
                        int failed = 0;
                
                        sendMessage(chatId, "📢 Начинаю рассылку для " + users.size() + " пользователей...");
                
                        for (long userId : users) {
                            try {
                                TelegramNotificationService.sendMessage(userId,
                                        "📢 **Административное сообщение**\n\n" + message + "\n\n_Это автоматическое сообщение от администратора_");
                                sent++;
                                Thread.sleep(100); // Небольшая задержка чтобы не спамить
                            } catch (Exception e) {
                                logger.error("Failed to send broadcast to user {}: {}", userId, e.getMessage());
                                failed++;
                            }
                        }
                
                        sendMessage(chatId, String.format(
                                "✅ Рассылка завершена\n" +
                                        "Отправлено: %d\n" +
                                        "Не отправлено: %d",
                                sent, failed
                        ));
                    }
                
                    private void handleAdminRestart(Long chatId) {
                        sendMessage(chatId, "🔄 Перезапускаю все парсеры...");
                
                        try {
                            // Получаем список активных пользователей
                            List<Long> activeUsers = threadManager.getActiveUsers();
                            int stopped = 0;
                            int started = 0;
                
                            // Останавливаем все парсеры
                            for (long userId : activeUsers) {
                                if (threadManager.stopUserParser(userId)) {
                                    stopped++;
                                }
                            }
                
                            // Небольшая пауза
                            Thread.sleep(2000);
                
                            // Запускаем парсеры для пользователей с запросами
                            for (long userId : WhitelistManager.getAllUsers()) {
                                if (!UserDataManager.getUserQueries(userId).isEmpty()) {
                                    if (threadManager.startUserParser(userId)) {
                                        started++;
                                    }
                                }
                            }
                
                            sendMessage(chatId, String.format(
                                    "✅ Перезапуск завершен\n" +
                                            "Остановлено парсеров: %d\n" +
                                            "Запущено парсеров: %d",
                                    stopped, started
                            ));
                
                        } catch (Exception e) {
                            logger.error("Error restarting parsers: {}", e.getMessage());
                            sendMessage(chatId, "❌ Ошибка при перезапуске: " + e.getMessage());
                        }
                    }
                
                    @Override
                    public String getBotUsername() {
                        return Config.getString("telegram.bot.username", "");
                    }
                }
                ----------------------------------------

            [FILE] Main.java
              Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/Main.java
              Размер: 6012 байт
              Дата изменения: 2026-01-18T21:41:41.895051669Z
              Содержимое:
              ----------------------------------------
              package com.parser;
              
              import com.parser.config.Config;
              import com.parser.core.ThreadManager;
              import com.parser.service.CookieService;
              import com.parser.storage.FileStorage;
              import com.parser.storage.WhitelistManager;
              import com.parser.telegram.TelegramBotService;
              import com.parser.telegram.TelegramNotificationService;
              import org.slf4j.Logger;
              import org.slf4j.LoggerFactory;
              import org.telegram.telegrambots.meta.TelegramBotsApi;
              import org.telegram.telegrambots.meta.exceptions.TelegramApiException;
              import org.telegram.telegrambots.updatesreceivers.DefaultBotSession;
              
              /**
               * Главная точка входа приложения
               */
              public class Main {
                  private static final Logger logger = LoggerFactory.getLogger(Main.class);
              
                  private static ThreadManager threadManager;
                  private static TelegramBotService botService;
                  private static final String SEPARATOR = "=".repeat(70);
              
                  public static void main(String[] args) {
                      try {
                          logger.info(SEPARATOR);
                          logger.info("🚀 MULTI-PARSER WITH SELENIUM COOKIES");
                          logger.info(SEPARATOR);
              
                          // 1. Проверка конфигурации
                          validateConfig();
              
                          // 2. Создание директорий
                          logger.info("🔄 Creating data directories...");
                          FileStorage.ensureDataDir();
                          logger.info("✅ Data directories ready");
              
                          // 3. Инициализация ThreadManager
                          logger.info("🔄 Initializing ThreadManager...");
                          threadManager = new ThreadManager();
                          logger.info("✅ ThreadManager initialized");
              
                          // 4. Инициализация CookieService (Selenium)
                          logger.info("🔄 Initializing CookieService with Selenium...");
                          CookieService.initialize();
                          logger.info("✅ CookieService ready (auto-refresh every 25 minutes)");
              
                          // 5. Запуск Telegram бота
                          logger.info("🔄 Initializing Telegram bot...");
                          initializeTelegramBot();
              
                          logger.info(SEPARATOR);
                          logger.info("✅ APPLICATION STARTED SUCCESSFULLY");
                          logger.info(SEPARATOR);
              
                          logStatus();
              
                          logger.info(SEPARATOR);
                          logger.info("📱 Ready for commands!");
                          logger.info(SEPARATOR);
              
                          // 6. Основной цикл
                          keepRunning();
              
                      } catch (Exception e) {
                          logger.error("❌ Fatal error: {}", e.getMessage(), e);
                          shutdown();
                          System.exit(1);
                      }
                  }
              
                  /**
                   * Валидация конфигурации
                   */
                  private static void validateConfig() {
                      String token = Config.getTelegramBotToken();
                      String username = Config.getTelegramBotUsername();
              
                      if (token.isEmpty() || "ВАШ_ТОКЕН_БОТА".equals(token)) {
                          logger.error("❌ Telegram bot token not configured!");
                          throw new RuntimeException("Set telegram.bot.token in config.properties");
                      }
              
                      if (username.isEmpty()) {
                          logger.error("❌ Telegram bot username not configured!");
                          throw new RuntimeException("Set telegram.bot.username in config.properties");
                      }
              
                      logger.info("✅ Config validated:");
                      logger.info("   Token: {}...", token.substring(0, 10));
                      logger.info("   Username: @{}", username);
                      logger.info("   Admin ID: {}", Config.getTelegramAdminId());
                  }
              
                  /**
                   * Инициализация Telegram бота
                   */
                  private static void initializeTelegramBot() {
                      try {
                          String token = Config.getTelegramBotToken();
                          botService = new TelegramBotService(token, threadManager);
              
                          TelegramBotsApi api = new TelegramBotsApi(DefaultBotSession.class);
                          api.registerBot(botService);
              
                          TelegramNotificationService.setBotInstance(botService);
                          logger.info("✅ Telegram bot registered (@{})", botService.getBotUsername());
              
                      } catch (TelegramApiException e) {
                          String msg = e.getMessage();
                          if (msg != null) {
                              if (msg.contains("409") || msg.contains("terminated")) {
                                  logger.error("❌ Another bot instance already running!");
                              } else if (msg.contains("401")) {
                                  logger.error("❌ Invalid bot token!");
                              } else if (msg.contains("timed out")) {
                                  logger.error("❌ Cannot connect to Telegram API!");
                              }
                          }
                          throw new RuntimeException("Failed to register bot: " + e.getMessage(), e);
                      }
                  }
              
                  /**
                   * Логирование статуса
                   */
                  private static void logStatus() {
                      logger.info("📊 System status:");
                      logger.info("   Whitelist users: {}", WhitelistManager.getUserCount());
                      logger.info("   Active sessions: {}", threadManager.getActiveUsers().size());
                  }
              
                  /**
                   * Поддержание работы приложения
                   */
                  private static void keepRunning() {
                      try {
                          int counter = 0;
                          while (true) {
                              Thread.sleep(30000);
                              counter++;
              
                              if (counter % 10 == 0) {
                                  logger.info("⏱️ Heartbeat #{}", counter);
                                  logStatus();
                              }
                          }
                      } catch (InterruptedException e) {
                          Thread.currentThread().interrupt();
                          logger.info("Main loop interrupted");
                      }
                  }
              
                  /**
                   * Корректное завершение
                   */
                  private static void shutdown() {
                      logger.info("🛑 Shutting down...");
              
                      if (threadManager != null) {
                          threadManager.shutdown();
                          logger.info("✅ ThreadManager shutdown");
                      }
              
                      CookieService.shutdown();
                      logger.info("✅ CookieService shutdown");
              
                      logger.info("✅ Shutdown complete");
                  }
              }
              ----------------------------------------
            [DIR] model

              [FILE] Product.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/model/Product.java
                Размер: 5217 байт
                Дата изменения: 2026-01-18T21:08:56.013999647Z
                Содержимое:
                ----------------------------------------
                package com.parser.model;
                
                import com.fasterxml.jackson.annotation.JsonIgnore;
                import com.fasterxml.jackson.annotation.JsonProperty;
                import com.parser.config.ParserSettings;
                
                import java.util.ArrayList;
                import java.util.List;
                
                /**
                 * Класс, представляющий товар
                 */
                public class Product {
                    private String id;
                    private String title;
                    private double price;
                    private String url;
                    private String site;
                    private String location;
                    private int ageMinutes;
                    private String query;
                    private List<String> images;
                    private String seller;
                    private String sellerRating;
                    private String category;
                    private boolean isNew;
                    private long foundTimestamp;
                
                    public Product() {
                        this.images = new ArrayList<>();
                        this.isNew = true;
                        this.foundTimestamp = System.currentTimeMillis();
                    }
                
                    // Геттеры и сеттеры
                    @JsonProperty("id") public String getId() { return id; }
                    public void setId(String id) { this.id = id; }
                
                    @JsonProperty("title") public String getTitle() { return title; }
                    public void setTitle(String title) {
                        if (title == null) {
                            this.title = "Без названия";
                        } else if (title.length() > 200) {
                            this.title = title.substring(0, 197) + "...";
                        } else {
                            this.title = title.trim();
                        }
                    }
                
                    @JsonProperty("price") public double getPrice() { return price; }
                    public void setPrice(double price) { this.price = Math.max(0, price); }
                
                    @JsonProperty("url") public String getUrl() { return url; }
                    public void setUrl(String url) { this.url = url; }
                
                    @JsonProperty("site") public String getSite() { return site; }
                    public void setSite(String site) { this.site = site; }
                
                    @JsonProperty("location") public String getLocation() { return location; }
                    public void setLocation(String location) { this.location = location; }
                
                    @JsonProperty("ageMinutes") public int getAgeMinutes() { return ageMinutes; }
                    public void setAgeMinutes(int ageMinutes) { this.ageMinutes = Math.max(0, ageMinutes); }
                
                    @JsonProperty("query") public String getQuery() { return query; }
                    public void setQuery(String query) { this.query = query; }
                
                    @JsonProperty("images") public List<String> getImages() { return new ArrayList<>(images); }
                    public void setImages(List<String> images) { this.images = new ArrayList<>(images); }
                    public void addImage(String image) {
                        if (image != null && !image.trim().isEmpty()) {
                            this.images.add(image.trim());
                        }
                    }
                
                    @JsonProperty("seller") public String getSeller() { return seller; }
                    public void setSeller(String seller) { this.seller = seller; }
                
                    @JsonProperty("sellerRating") public String getSellerRating() { return sellerRating; }
                    public void setSellerRating(String sellerRating) { this.sellerRating = sellerRating; }
                
                    @JsonProperty("category") public String getCategory() { return category; }
                    public void setCategory(String category) { this.category = category; }
                
                    @JsonProperty("isNew") public boolean isNew() { return isNew; }
                    public void setNew(boolean isNew) { this.isNew = isNew; }
                
                    @JsonProperty("foundTimestamp") public long getFoundTimestamp() { return foundTimestamp; }
                    public void setFoundTimestamp(long foundTimestamp) { this.foundTimestamp = foundTimestamp; }
                
                    // Методы для конвертации цены
                    @JsonIgnore public double getPriceRubles() {
                        return Math.round(price * ParserSettings.getCurrencyRate(
                                ParserSettings.CURRENCY_YUAN, ParserSettings.CURRENCY_RUBLES) * 100.0) / 100.0;
                    }
                
                    @JsonIgnore public String getPriceDisplay() {
                        return String.format("%.2f ¥", price);
                    }
                
                    @JsonIgnore public String getPriceDisplayRub() {
                        return String.format("%.2f руб.", getPriceRubles());
                    }
                
                    // Методы для удобства
                    @JsonIgnore public String getShortTitle() {
                        if (title.length() <= 50) return title;
                        return title.substring(0, 47) + "...";
                    }
                
                    @JsonIgnore public String getAgeDisplay() {
                        if (ageMinutes < 60) return ageMinutes + " мин";
                        else if (ageMinutes < 1440) return (ageMinutes / 60) + " ч";
                        else return (ageMinutes / 1440) + " дн";
                    }
                
                    @JsonIgnore public boolean hasImages() { return !images.isEmpty(); }
                    @JsonIgnore public String getMainImage() { return images.isEmpty() ? null : images.get(0); }
                    @JsonIgnore public String getCoverImageUrl() { return getMainImage(); }
                    @JsonIgnore public boolean hasCoverImage() { return getCoverImageUrl() != null; }
                
                    @Override
                    public boolean equals(Object obj) {
                        if (this == obj) return true;
                        if (obj == null || getClass() != obj.getClass()) return false;
                        Product product = (Product) obj;
                        return id != null && id.equals(product.id);
                    }
                
                    @Override
                    public int hashCode() { return id != null ? id.hashCode() : 0; }
                
                    @Override
                    public String toString() {
                        return String.format("Product{id='%s', title='%s', price=%.2f¥, age=%dmin, location=%s}",
                                id, getShortTitle(), price, ageMinutes, location);
                    }
                }
                ----------------------------------------

              [FILE] UserSettings.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/model/UserSettings.java
                Размер: 5914 байт
                Дата изменения: 2026-01-18T22:03:43.858667987Z
                Содержимое:
                ----------------------------------------
                package com.parser.model;
                
                import com.fasterxml.jackson.annotation.JsonIgnore;
                import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
                import com.fasterxml.jackson.annotation.JsonProperty;
                import com.parser.config.ParserSettings;
                
                import java.io.Serializable;
                
                /**
                 * Класс настроек пользователя для парсера
                 */
                @JsonIgnoreProperties(ignoreUnknown = true)  // Добавьте эту аннотацию
                public class UserSettings implements Serializable {
                    private static final long serialVersionUID = 1L;
                
                    // Основные настройки
                    private int checkInterval = 300; // секунды
                    private int maxAgeMinutes = 1440; // 24 часа
                    private int maxPages = 3;
                    private int rowsPerPage = 100;
                
                    // Валютные настройки
                    private String priceCurrency = ParserSettings.CURRENCY_RUBLES;
                
                    // Настройки уведомлений
                    private boolean notifyNewOnly = true;
                    private boolean notifyTelegram = true;
                    private boolean notifyEmail = false;
                
                    // Удалите или закомментируйте это поле, если оно не используется
                    // private boolean notifySound = true;
                
                    // Настройки фильтрации
                    private double minPrice = 0;
                    private double maxPrice = 0; // 0 = без ограничения
                
                    // Расширенные настройки
                    private int requestDelay = 2000; // мс
                    private int maxRetries = 3;
                
                    public UserSettings() {
                        // Конструктор по умолчанию
                    }
                
                    // Геттеры и сеттеры с валидацией
                    @JsonProperty("checkInterval")
                    public int getCheckInterval() { return checkInterval; }
                    public void setCheckInterval(int checkInterval) {
                        this.checkInterval = ParserSettings.normalizeCheckInterval(checkInterval);
                    }
                
                    @JsonProperty("maxAgeMinutes")
                    public int getMaxAgeMinutes() { return maxAgeMinutes; }
                    public void setMaxAgeMinutes(int maxAgeMinutes) {
                        this.maxAgeMinutes = ParserSettings.normalizeMaxAge(maxAgeMinutes);
                    }
                
                    @JsonProperty("maxPages")
                    public int getMaxPages() { return maxPages; }
                    public void setMaxPages(int maxPages) {
                        this.maxPages = Math.max(ParserSettings.MIN_MAX_PAGES,
                                Math.min(maxPages, ParserSettings.MAX_MAX_PAGES));
                    }
                
                    @JsonProperty("rowsPerPage")
                    public int getRowsPerPage() { return rowsPerPage; }
                    public void setRowsPerPage(int rowsPerPage) {
                        this.rowsPerPage = Math.max(ParserSettings.MIN_ROWS_PER_PAGE,
                                Math.min(rowsPerPage, ParserSettings.MAX_ROWS_PER_PAGE));
                    }
                
                    @JsonProperty("priceCurrency")
                    public String getPriceCurrency() { return priceCurrency; }
                    public void setPriceCurrency(String priceCurrency) {
                        if (ParserSettings.CURRENCY_YUAN.equals(priceCurrency) ||
                                ParserSettings.CURRENCY_RUBLES.equals(priceCurrency)) {
                            this.priceCurrency = priceCurrency;
                        }
                    }
                
                    @JsonProperty("notifyNewOnly")
                    public boolean isNotifyNewOnly() { return notifyNewOnly; }
                    public void setNotifyNewOnly(boolean notifyNewOnly) { this.notifyNewOnly = notifyNewOnly; }
                
                    @JsonProperty("notifyTelegram")
                    public boolean isNotifyTelegram() { return notifyTelegram; }
                    public void setNotifyTelegram(boolean notifyTelegram) { this.notifyTelegram = notifyTelegram; }
                
                    @JsonProperty("notifyEmail")
                    public boolean isNotifyEmail() { return notifyEmail; }
                    public void setNotifyEmail(boolean notifyEmail) { this.notifyEmail = notifyEmail; }
                
                    // Удалите или закомментируйте этот геттер/сеттер
                    // @JsonProperty("notifySound")
                    // public boolean isNotifySound() { return notifySound; }
                    // public void setNotifySound(boolean notifySound) { this.notifySound = notifySound; }
                
                    @JsonProperty("minPrice")
                    public double getMinPrice() { return minPrice; }
                    public void setMinPrice(double minPrice) { this.minPrice = Math.max(0, minPrice); }
                
                    @JsonProperty("maxPrice")
                    public double getMaxPrice() { return maxPrice; }
                    public void setMaxPrice(double maxPrice) { this.maxPrice = maxPrice < 0 ? 0 : maxPrice; }
                
                    @JsonProperty("requestDelay")
                    public int getRequestDelay() { return requestDelay; }
                    public void setRequestDelay(int requestDelay) {
                        this.requestDelay = Math.max(500, Math.min(requestDelay, 10000));
                    }
                
                    @JsonProperty("maxRetries")
                    public int getMaxRetries() { return maxRetries; }
                    public void setMaxRetries(int maxRetries) {
                        this.maxRetries = Math.max(0, Math.min(maxRetries, 10));
                    }
                
                    // Методы для удобства
                    @JsonIgnore
                    public boolean hasPriceFilter() {
                        return maxPrice > 0 && maxPrice > minPrice;
                    }
                
                    @JsonIgnore
                    public boolean isPriceInRange(double price) {
                        if (minPrice > 0 && price < minPrice) return false;
                        if (maxPrice > 0 && price > maxPrice) return false;
                        return true;
                    }
                
                    @JsonIgnore
                    public boolean isValid() {
                        return ParserSettings.isValidCheckInterval(checkInterval) &&
                                ParserSettings.isValidMaxAge(maxAgeMinutes) &&
                                maxPages >= ParserSettings.MIN_MAX_PAGES &&
                                rowsPerPage >= ParserSettings.MIN_ROWS_PER_PAGE;
                    }
                
                    @JsonIgnore
                    public String getSummary() {
                        return String.format(
                                "Интервал: %d сек, Возраст: %d мин, Страниц: %d, Товаров на странице: %d",
                                checkInterval, maxAgeMinutes, maxPages, rowsPerPage
                        );
                    }
                
                    @Override
                    public String toString() {
                        return String.format(
                                "UserSettings{checkInterval=%d, maxAge=%d, maxPages=%d, rowsPerPage=%d}",
                                checkInterval, maxAgeMinutes, maxPages, rowsPerPage
                        );
                    }
                }
                ----------------------------------------
            [DIR] service

              [FILE] CookieService.java
                Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/service/CookieService.java
                Размер: 25884 байт
                Дата изменения: 2026-01-19T08:22:49.590049187Z
                Содержимое:
                ----------------------------------------
                package com.parser.service;
                
                import io.github.bonigarcia.wdm.WebDriverManager;
                import org.openqa.selenium.*;
                import org.openqa.selenium.chrome.ChromeDriver;
                import org.openqa.selenium.chrome.ChromeOptions;
                import org.openqa.selenium.support.ui.WebDriverWait;
                import org.slf4j.Logger;
                import org.slf4j.LoggerFactory;
                
                import java.io.FileOutputStream;
                import java.text.SimpleDateFormat;
                import java.time.Duration;
                import java.util.*;
                import java.util.concurrent.*;
                
                /**
                 * Сервис управления cookies через Selenium БЕЗ АУТЕНТИФИКАЦИИ
                 * Исправленная версия - работает как Python-версия
                 */
                public class CookieService {
                    private static final Logger logger = LoggerFactory.getLogger(CookieService.class);
                
                    private static final Map<String, CookieCache> cookieCache = new ConcurrentHashMap<>();
                    private static final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
                    private static final long CACHE_TTL = 20 * 60 * 1000; // 20 минут
                
                    static class CookieCache {
                        Map<String, String> cookies;
                        long timestamp;
                        String domain;
                
                        CookieCache(String domain) {
                            this.domain = domain;
                            this.cookies = new HashMap<>();
                            this.timestamp = 0;
                        }
                
                        boolean isExpired() {
                            return System.currentTimeMillis() - timestamp > CACHE_TTL;
                        }
                    }
                
                    // Конфигурация сайтов
                    public static class SiteConfig {
                        public String domain;
                        public String url;
                        public String[] requiredCookies;
                
                        public SiteConfig(String domain, String url, String... requiredCookies) {
                            this.domain = domain;
                            this.url = url;
                            this.requiredCookies = requiredCookies;
                        }
                    }
                
                    private static final Map<String, SiteConfig> SITES = new ConcurrentHashMap<>(Map.ofEntries(
                            Map.entry("goofish", new SiteConfig(
                                    "goofish",
                                    "https://www.goofish.com",
                                    "_m_h5_tk", "_tb_token_", "cna", "t", "cookie2"
                            ))
                    ));
                
                    /**
                     * Инициализация сервиса
                     */
                    public static void initialize() {
                        logger.info("🍪 Initializing CookieService with Selenium");
                
                        // Начальная загрузка
                        refreshAllCookies();
                
                        // Автоматическое обновление каждые 25 минут
                        scheduler.scheduleAtFixedRate(
                                CookieService::refreshAllCookies,
                                25, 25, TimeUnit.MINUTES
                        );
                
                        logger.info("✅ CookieService initialized with auto-refresh every 25 minutes");
                    }
                
                    /**
                     * Обновить все cookies
                     */
                    public static void refreshAllCookies() {
                        logger.info("🔄 Refreshing all cookies...");
                        for (String site : SITES.keySet()) {
                            try {
                                refreshCookies(site);
                                Thread.sleep(3000);
                            } catch (Exception e) {
                                logger.error("❌ Failed to refresh cookies for {}: {}", site, e.getMessage());
                            }
                        }
                    }
                
                    /**
                     * Извлечь cookies со ВСЕХ доступных доменов
                     */
                    private static Map<String, String> extractAllCookies(WebDriver driver) {
                        Map<String, String> cookies = new LinkedHashMap<>();
                
                        try {
                            Set<Cookie> allCookies = driver.manage().getCookies();
                            logger.info("Found {} total cookies from browser", allCookies.size());
                
                            // Собираем ВСЕ cookies
                            for (Cookie cookie : allCookies) {
                                String name = cookie.getName();
                                String value = cookie.getValue();
                                String domain = cookie.getDomain();
                
                                // Сохраняем все куки, особенно с API домена
                                if (domain != null && (domain.contains("goofish") ||
                                        domain.contains("taobao") ||
                                        domain.contains("alibaba") ||
                                        domain.contains("h5api"))) {
                                    cookies.put(name, value);
                                    logger.info("✅ Saved cookie '{}' from domain '{}'", name, domain);
                                }
                            }
                
                            // Также получаем куки через JavaScript (localStorage, sessionStorage)
                            try {
                                JavascriptExecutor js = (JavascriptExecutor) driver;
                                // Получаем токены из localStorage
                                Object localStorage = js.executeScript("return window.localStorage;");
                                logger.debug("localStorage: {}", localStorage);
                
                                // Получаем токены из sessionStorage
                                Object sessionStorage = js.executeScript("return window.sessionStorage;");
                                logger.debug("sessionStorage: {}", sessionStorage);
                
                            } catch (Exception e) {
                                logger.debug("Could not access storage: {}", e.getMessage());
                            }
                
                        } catch (Exception e) {
                            logger.error("Error extracting cookies: {}", e.getMessage());
                        }
                
                        return cookies;
                    }
                
                    /**
                     * Сохранить cookies в файл для отладки
                     */
                    private static void saveCookiesToFile(Map<String, String> cookies) {
                        try {
                            Properties props = new Properties();
                            props.putAll(cookies);
                
                            String timestamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
                            String filename = "cookies_debug_" + timestamp + ".properties";
                
                            try (FileOutputStream fos = new FileOutputStream(filename)) {
                                props.store(fos, "Debug cookies from Selenium");
                                logger.info("💾 Saved debug cookies to: {}", filename);
                            }
                
                            // Также сохраняем в основной файл
                            updateCookiesProperties(cookies);
                
                        } catch (Exception e) {
                            logger.error("Error saving cookies to file: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Обновить основной файл cookies.properties
                     */
                    private static void updateCookiesProperties(Map<String, String> cookies) {
                        try {
                            StringBuilder cookieString = new StringBuilder();
                            for (Map.Entry<String, String> entry : cookies.entrySet()) {
                                if (cookieString.length() > 0) {
                                    cookieString.append("; ");
                                }
                                // Экранируем специальные символы
                                String key = entry.getKey().replace("=", "\\=").replace(";", "\\;");
                                String value = entry.getValue().replace("=", "\\=").replace(";", "\\;");
                                cookieString.append(key).append("=").append(value);
                            }
                
                            Properties props = new Properties();
                            props.setProperty("goofish.cookies", cookieString.toString());
                            props.setProperty("last.updated", new Date().toString());
                
                            try (FileOutputStream fos = new FileOutputStream("cookies.properties")) {
                                props.store(fos, "Auto-generated by CookieService");
                                logger.info("💾 Updated main cookies.properties file");
                            }
                
                        } catch (Exception e) {
                            logger.error("Error updating cookies.properties: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Обновить cookies для Goofish (гостевой доступ без аутентификации)
                     */
                    public static boolean refreshCookies(String site) {
                        SiteConfig config = SITES.get(site);
                        if (config == null) {
                            logger.warn("⚠️ Unknown site: {}", site);
                            return false;
                        }
                
                        logger.info("🔄 Refreshing guest cookies for: {}", site);
                
                        WebDriver driver = null;
                        try {
                            // Используем headless=false для отладки
                            driver = createChromeDriver(false);
                
                            // ШАГ 1: Идем напрямую на API без аутентификации
                            String apiUrl = "https://www.goofish.com";
                            logger.info("📍 Step 1: Direct API access (no auth): {}", apiUrl);
                            driver.get(apiUrl);
                            waitForPageLoad(driver);
                            Thread.sleep(5000);
                
                            // Проверяем, не редиректит ли на логин
                            String currentUrl = driver.getCurrentUrl();
                            if (currentUrl.contains("passport.goofish.com") || currentUrl.contains("login")) {
                                logger.warn("⚠️ Redirected to login page. Trying alternative approach...");
                                // Альтернативный подход: получить куки через HTML страницу
                                return getCookiesViaHtml(driver);
                            }
                
                            // ШАГ 2: Делаем простой запрос через браузер
                            String searchUrl = "https://www.goofish.com/search?q=test";
                            logger.info("🔍 Step 2: Making search request: {}", searchUrl);
                            driver.get(searchUrl);
                            waitForPageLoad(driver);
                            Thread.sleep(3000);
                
                            // ШАГ 3: Пробуем получить данные через iframe или script
                            logger.info("📜 Step 3: Executing scripts for API tokens...");
                            executeApiScripts(driver);
                
                            // ШАГ 4: Собираем ВСЕ куки
                            logger.info("📦 Step 4: Collecting all cookies...");
                            Map<String, String> cookies = collectAllCookies(driver);
                
                            if (cookies.isEmpty()) {
                                logger.error("❌ No cookies collected");
                                return false;
                            }
                
                            // Сохраняем для отладки
                //            saveDebugInfo(driver, cookies);
                
                            // Проверяем обязательные куки
                            String[] required = {"_m_h5_tk", "t", "cookie2"};
                            for (String req : required) {
                                if (!cookies.containsKey(req)) {
                                    logger.warn("⚠️ Missing required cookie: {}", req);
                                }
                            }
                
                            saveCookies(site, config, cookies);
                            logger.info("✅ Guest cookies updated ({} cookies)", cookies.size());
                            return true;
                
                        } catch (Exception e) {
                            logger.error("❌ Error refreshing guest cookies: {}", e.getMessage(), e);
                            return false;
                        } finally {
                            if (driver != null) {
                                try {
                                    driver.quit();
                                } catch (Exception e) {
                                    logger.debug("Error closing driver: {}", e.getMessage());
                                }
                            }
                        }
                    }
                
                    /**
                     * Получение кук через HTML страницу (альтернативный метод)
                     */
                    private static boolean getCookiesViaHtml(WebDriver driver) {
                        try {
                            logger.info("🔄 Alternative: Getting cookies via HTML page...");
                
                            // Идем на главную страницу через мобильный user-agent
                            driver.manage().deleteAllCookies();
                
                            Map<String, String> mobileHeaders = new HashMap<>();
                            mobileHeaders.put("User-Agent", "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15");
                            // Установить заголовки сложно в Selenium, используем другой подход
                
                            // Просто загружаем страницу
                            driver.get("https://m.goofish.com");
                            waitForPageLoad(driver);
                            Thread.sleep(3000);
                
                            // Выполняем JavaScript для получения токенов
                            JavascriptExecutor js = (JavascriptExecutor) driver;
                            String script = """
                            // Пробуем получить токены из разных источников
                            var tokens = {};
                            
                            // Из localStorage
                            try {
                                for (var i = 0; i < localStorage.length; i++) {
                                    var key = localStorage.key(i);
                                    if (key.includes('token') || key.includes('tk') || key.includes('auth')) {
                                        tokens[key] = localStorage.getItem(key);
                                    }
                                }
                            } catch(e) {}
                            
                            // Из document.cookie
                            var cookies = document.cookie.split(';');
                            for (var cookie of cookies) {
                                var parts = cookie.split('=');
                                if (parts.length == 2) {
                                    var key = parts[0].trim();
                                    var value = parts[1].trim();
                                    tokens[key] = value;
                                }
                            }
                            
                            return tokens;
                        """;
                
                            @SuppressWarnings("unchecked")
                            Map<String, String> jsTokens = (Map<String, String>) js.executeScript(script);
                
                            logger.info("📋 JS tokens found: {}", jsTokens.size());
                
                            // Собираем все куки из браузера
                            Set<Cookie> browserCookies = driver.manage().getCookies();
                            Map<String, String> allCookies = new HashMap<>();
                
                            for (Cookie cookie : browserCookies) {
                                allCookies.put(cookie.getName(), cookie.getValue());
                            }
                
                            // Добавляем JS токены
                            allCookies.putAll(jsTokens);
                
                            logger.info("📦 Total cookies/tokens: {}", allCookies.size());
                            return !allCookies.isEmpty();
                
                        } catch (Exception e) {
                            logger.error("Error in getCookiesViaHtml: {}", e.getMessage());
                            return false;
                        }
                    }
                
                    /**
                     * Выполнить скрипты для получения API токенов
                     */
                    private static void executeApiScripts(WebDriver driver) {
                        try {
                            JavascriptExecutor js = (JavascriptExecutor) driver;
                
                            // Скрипт 1: Имитируем запрос к API
                            String script1 = """
                            // Создаем fake XMLHttpRequest для получения кук
                            var xhr = new XMLHttpRequest();
                            xhr.open('GET', 'https://h5api.m.goofish.com/h5/mtop.taobao.idlemtopsearch.pc.search/1.0/', true);
                            xhr.withCredentials = true;
                            xhr.send();
                            
                            // Возвращаем статус
                            return 'XHR sent for API cookies';
                        """;
                
                            Object result1 = js.executeScript(script1);
                            logger.debug("Script 1 result: {}", result1);
                            Thread.sleep(2000);
                
                            // Скрипт 2: Пробуем получить данные через fetch
                            String script2 = """
                            // Пробуем fetch с credentials
                            fetch('https://h5api.m.goofish.com', {
                                method: 'GET',
                                credentials: 'include',
                                mode: 'no-cors'
                            }).then(() => {
                                return 'Fetch completed';
                            }).catch(e => {
                                return 'Fetch error: ' + e.message;
                            });
                        """;
                
                            Object result2 = js.executeScript(script2);
                            logger.debug("Script 2 result: {}", result2);
                            Thread.sleep(2000);
                
                        } catch (Exception e) {
                            logger.debug("Error executing API scripts: {}", e.getMessage());
                        }
                    }
                
                    /**
                     * Собрать все куки из всех источников
                     */
                    private static Map<String, String> collectAllCookies(WebDriver driver) {
                        Map<String, String> allCookies = new HashMap<>();
                
                        try {
                            // Куки из браузера
                            Set<Cookie> browserCookies = driver.manage().getCookies();
                            for (Cookie cookie : browserCookies) {
                                allCookies.put(cookie.getName(), cookie.getValue());
                                logger.debug("Browser cookie: {} = {}...",
                                        cookie.getName(),
                                        cookie.getValue().substring(0, Math.min(20, cookie.getValue().length()))
                                );
                            }
                
                            // Куки из JavaScript
                            JavascriptExecutor js = (JavascriptExecutor) driver;
                            String cookieScript = "return document.cookie;";
                            String jsCookies = (String) js.executeScript(cookieScript);
                            if (jsCookies != null && !jsCookies.isEmpty()) {
                                for (String cookie : jsCookies.split(";")) {
                                    String[] parts = cookie.trim().split("=", 2);
                                    if (parts.length == 2) {
                                        allCookies.put(parts[0], parts[1]);
                                    }
                                }
                            }
                
                            logger.info("📊 Collected {} cookies total", allCookies.size());
                
                        } catch (Exception e) {
                            logger.error("Error collecting cookies: {}", e.getMessage());
                        }
                
                        return allCookies;
                    }
                
                    /**
                     * Создать настроенный Chrome WebDriver
                     */
                    private static WebDriver createChromeDriver(boolean headless) {
                        WebDriverManager.chromedriver().setup();
                
                        ChromeOptions options = new ChromeOptions();
                
                        if (headless) {
                            options.addArguments("--headless=new");
                            options.addArguments("--no-sandbox");
                            options.addArguments("--disable-dev-shm-usage");
                        }
                
                        // Критичные настройки для обхода детекции
                        options.addArguments(
                                "--disable-blink-features=AutomationControlled",
                                "--disable-gpu",
                                "--window-size=1920,1080",
                                "--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
                        );
                
                        options.setExperimentalOption("excludeSwitches", new String[]{"enable-automation"});
                        options.setExperimentalOption("useAutomationExtension", false);
                
                        // Добавляем скрипт для скрытия webdriver
                        options.addArguments("--disable-blink-features=AutomationControlled");
                
                        ChromeDriver driver = new ChromeDriver(options);
                
                        // Удаляем navigator.webdriver
                        driver.executeScript("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})");
                
                        return driver;
                    }
                
                    /**
                     * Ожидание загрузки страницы
                     */
                    private static void waitForPageLoad(WebDriver driver) {
                        try {
                            new WebDriverWait(driver, Duration.ofSeconds(30))
                                    .until(d -> ((JavascriptExecutor) d)
                                            .executeScript("return document.readyState").equals("complete"));
                        } catch (org.openqa.selenium.TimeoutException e) {
                            logger.warn("⚠️ Page load timeout, continuing anyway...");
                        }
                    }
                
                    /**
                     * Извлечь cookies со ВСЕХ доменов Goofish
                     */
                    private static Map<String, String> extractCookies(WebDriver driver, SiteConfig config) {
                        Map<String, String> cookies = new LinkedHashMap<>();
                
                        try {
                            Set<Cookie> allCookies = driver.manage().getCookies();
                            logger.info("Found {} total cookies from browser", allCookies.size());
                
                            // Собираем ВСЕ cookies, связанные с goofish
                            for (Cookie cookie : allCookies) {
                                String name = cookie.getName();
                                String value = cookie.getValue();
                                String domain = cookie.getDomain();
                
                                // Логируем все cookies для отладки
                                logger.debug("Cookie: name={}, domain={}, value={}",
                                        name, domain, value.substring(0, Math.min(20, value.length())) + "...");
                
                                // Сохраняем cookies от всех доменов goofish/taobao/alibaba
                                if (domain.contains("goofish") || domain.contains("taobao") || domain.contains("alibaba")) {
                                    cookies.put(name, value);
                                    logger.info("✅ Saved cookie '{}' from domain '{}'", name, domain);
                                }
                            }
                
                            // Проверяем наличие обязательных куки
                            for (String required : config.requiredCookies) {
                                if (cookies.containsKey(required)) {
                                    logger.info("✅ Required cookie '{}' found", required);
                                } else {
                                    logger.warn("❌ Required cookie '{}' NOT found", required);
                                }
                            }
                
                            logger.info("📦 Extracted {} cookies total", cookies.size());
                
                        } catch (Exception e) {
                            logger.error("Error extracting cookies: {}", e.getMessage());
                        }
                
                        return cookies;
                    }
                
                    /**
                     * Логирование деталей cookies для отладки
                     */
                    private static void logCookieDetails(Map<String, String> cookies) {
                        logger.info("📋 Cookie details:");
                        for (Map.Entry<String, String> entry : cookies.entrySet()) {
                            String value = entry.getValue();
                            logger.info("  • {}: {}...",
                                    entry.getKey(),
                                    value.substring(0, Math.min(30, value.length())));
                        }
                    }
                
                    /**
                     * Валидация cookies
                     */
                    private static boolean validateCookies(Map<String, String> cookies, SiteConfig config) {
                        if (cookies.isEmpty()) {
                            logger.warn("❌ No cookies found");
                            return false;
                        }
                
                        int missingCount = 0;
                        for (String required : config.requiredCookies) {
                            if (!cookies.containsKey(required) || cookies.get(required).isEmpty()) {
                                logger.warn("❌ Missing required cookie: {}", required);
                                missingCount++;
                            }
                        }
                
                        // Допускаем отсутствие некоторых cookies, но не всех
                        if (missingCount >= config.requiredCookies.length) {
                            logger.error("❌ Too many missing cookies ({}/{})", missingCount, config.requiredCookies.length);
                            return false;
                        }
                
                        logger.info("✅ Cookies validation passed ({} cookies, {} missing)",
                                cookies.size(), missingCount);
                        return true;
                    }
                
                    /**
                     * Сохранить cookies в кэш
                     */
                    private static void saveCookies(String site, SiteConfig config, Map<String, String> cookies) {
                        CookieCache cache = cookieCache.computeIfAbsent(site, k -> new CookieCache(site));
                        cache.cookies = new HashMap<>(cookies);
                        cache.timestamp = System.currentTimeMillis();
                
                        logger.info("💾 Saved {} cookies for site '{}'", cookies.size(), site);
                    }
                
                    /**
                     * Получить cookies для сайта (с автообновлением если нужно)
                     */
                    public static Map<String, String> getCookies(String site) {
                        CookieCache cache = cookieCache.get(site);
                
                        if (cache == null || cache.isExpired()) {
                            logger.info("🔄 Cache expired or missing, refreshing cookies for {}", site);
                            refreshCookies(site);
                            cache = cookieCache.get(site);
                        }
                
                        if (cache != null && !cache.cookies.isEmpty()) {
                            logger.debug("🍪 Returning {} cookies for {}", cache.cookies.size(), site);
                            return new HashMap<>(cache.cookies);
                        }
                
                        logger.warn("⚠️ No cookies available for {}", site);
                        return new HashMap<>();
                    }
                
                    /**
                     * Получить строку cookies для HTTP заголовка
                     */
                    public static String getCookieHeader(String site) {
                        Map<String, String> cookies = getCookies(site);
                        StringBuilder header = new StringBuilder();
                
                        for (Map.Entry<String, String> entry : cookies.entrySet()) {
                            if (header.length() > 0) {
                                header.append("; ");
                            }
                            header.append(entry.getKey()).append("=").append(entry.getValue());
                        }
                
                        String result = header.toString();
                        logger.debug("📤 Cookie header for {}: {} chars", site, result.length());
                        return result;
                    }
                
                    /**
                     * Получить статистику
                     */
                    public static Map<String, Object> getStats() {
                        Map<String, Object> stats = new HashMap<>();
                        Map<String, Object> sites = new HashMap<>();
                
                        for (Map.Entry<String, CookieCache> entry : cookieCache.entrySet()) {
                            CookieCache cache = entry.getValue();
                            sites.put(entry.getKey(), Map.of(
                                    "cookies", cache.cookies.size(),
                                    "expired", cache.isExpired(),
                                    "age_minutes", (System.currentTimeMillis() - cache.timestamp) / 60000
                            ));
                        }
                
                        stats.put("sites", sites);
                        stats.put("cache_ttl_minutes", CACHE_TTL / 60000);
                        stats.put("lastRefreshTime", new Date());
                        return stats;
                    }
                
                    /**
                     * Получить статистику кэша
                     */
                    public static Map<String, Object> getCacheStats() {
                        return getStats();
                    }
                
                    /**
                     * Очистить кэш
                     */
                    public static void clearCache() {
                        cookieCache.clear();
                        logger.info("🗑️ Cookie cache cleared");
                    }
                
                    /**
                     * Завершение
                     */
                    public static void shutdown() {
                        scheduler.shutdown();
                        try {
                            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                                scheduler.shutdownNow();
                            }
                        } catch (InterruptedException e) {
                            scheduler.shutdownNow();
                            Thread.currentThread().interrupt();
                        }
                        logger.info("🛑 CookieService shutdown");
                    }
                }
                ----------------------------------------

            [FILE] ProjectStructureExporter.java
              Путь: /Users/yanmore/IdeaProjects/multiParser/src/main/java/com/parser/ProjectStructureExporter.java
              Размер: 5639 байт
              Дата изменения: 2026-01-18T19:50:03.384565602Z
              Содержимое:
              ----------------------------------------
              package com.parser;
              
              import java.io.*;
              import java.nio.file.*;
              import java.nio.file.attribute.BasicFileAttributes;
              
              public class ProjectStructureExporter {
                  private static final String OUTPUT_FILE = "project_structure.txt";
                  private static final String[] IGNORED_DIRS = {".git", ".idea", "target", "build", "node_modules", "out", "bin"};
                  private static final int MAX_FILE_SIZE = 1024 * 1024 * 1024; // 1MB - максимальный размер файла для чтения
              
                  public static void main(String[] args) throws IOException {
                      Path currentDir = Paths.get(".").toAbsolutePath().normalize();
                      System.out.println("Сканирую директорию: " + currentDir);
              
                      try (PrintWriter writer = new PrintWriter(new FileWriter(OUTPUT_FILE))) {
                          writer.println("СТРУКТУРА ПРОЕКТА");
                          writer.println("=================");
                          writer.println("Директория: " + currentDir);
                          writer.println("Дата создания отчета: " + java.time.LocalDateTime.now());
                          writer.println("\n" + "=".repeat(80) + "\n");
              
                          Files.walkFileTree(currentDir, new SimpleFileVisitor<Path>() {
                              private int depth = 0;
              
                              @Override
                              public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) {
                                  // Пропускаем игнорируемые директории
                                  for (String ignored : IGNORED_DIRS) {
                                      if (dir.toString().contains(File.separator + ignored)) {
                                          return FileVisitResult.SKIP_SUBTREE;
                                      }
                                  }
              
                                  // Печатаем структуру директорий
                                  String indent = "  ".repeat(depth);
                                  writer.println(indent + "[DIR] " + dir.getFileName());
                                  depth++;
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                                  String indent = "  ".repeat(depth);
                                  String fileName = file.getFileName().toString();
              
                                  // Пропускаем сам файл отчета
                                  if (fileName.equals(OUTPUT_FILE)) {
                                      return FileVisitResult.CONTINUE;
                                  }
              
                                  writer.println("\n" + indent + "[FILE] " + fileName);
                                  writer.println(indent + "  Путь: " + file);
                                  writer.println(indent + "  Размер: " + attrs.size() + " байт");
                                  writer.println(indent + "  Дата изменения: " + attrs.lastModifiedTime());
              
                                  // Читаем содержимое текстовых файлов
                                  if (isTextFile(fileName) && attrs.size() <= MAX_FILE_SIZE) {
                                      writer.println(indent + "  Содержимое:");
                                      writer.println(indent + "  " + "-".repeat(40));
                                      try {
                                          String content = Files.readString(file);
                                          String[] lines = content.split("\n");
                                          for (int i = 0; i < Math.min(lines.length, 10000); i++) { // Ограничиваем 100 строками
                                              writer.println(indent + "  " + lines[i]);
                                          }
                                          if (lines.length > 10000) {
                                              writer.println(indent + "  ... (файл усечен, показано 100 из " + lines.length + " строк)");
                                          }
                                      } catch (IOException e) {
                                          writer.println(indent + "  Невозможно прочитать файл (возможно, бинарный)");
                                      }
                                      writer.println(indent + "  " + "-".repeat(40));
                                  } else {
                                      writer.println(indent + "  [БИНАРНЫЙ ФАЙЛ ИЛИ СЛИШКОМ БОЛЬШОЙ]");
                                  }
              
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult postVisitDirectory(Path dir, IOException exc) {
                                  depth--;
                                  return FileVisitResult.CONTINUE;
                              }
              
                              @Override
                              public FileVisitResult visitFileFailed(Path file, IOException exc) {
                                  writer.println("\nОшибка при доступе к файлу: " + file);
                                  return FileVisitResult.CONTINUE;
                              }
                          });
              
                          writer.println("\n" + "=".repeat(80));
                          writer.println("Отчет успешно создан!");
                      }
              
                      System.out.println("Отчет сохранен в файл: " + OUTPUT_FILE);
                  }
              
                  private static boolean isTextFile(String fileName) {
                      String[] textExtensions = {
                              ".java", ".txt", ".xml", ".html", ".htm", ".css", ".js", ".json",
                              ".properties", ".yml", ".yaml", ".md", ".gradle", ".kt", ".py",
                              ".cpp", ".c", ".h", ".hpp", ".sql", ".sh", ".bat", ".cfg", ".ini"
                      };
              
                      String lowerName = fileName.toLowerCase();
                      for (String ext : textExtensions) {
                          if (lowerName.endsWith(ext)) {
                              return true;
                          }
                      }
                      return false;
                  }
              }
              ----------------------------------------

================================================================================
Отчет успешно создан!
